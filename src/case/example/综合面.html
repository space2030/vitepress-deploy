<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>综合面</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_case_example_综合面.md.f493e2fa.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#_01-什么的是bean的自动装配，它有哪些方式？" data-v-2d325df8>01 什么的是bean的自动装配，它有哪些方式？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-如何理解springboot中的starter？" data-v-2d325df8>02 如何理解springboot中的starter？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-mybatis的缺点" data-v-2d325df8>03 mybatis的缺点</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-mysql聚簇和非聚簇索引的区别是什么？" data-v-2d325df8>04 mysql聚簇和非聚簇索引的区别是什么？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_05-mysql索引结构有哪些，各自的优劣是什么？" data-v-2d325df8>05 mysql索引结构有哪些，各自的优劣是什么？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-索引的设计原则有哪些？" data-v-2d325df8>06 索引的设计原则有哪些？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-mysql锁的类型有哪些？" data-v-2d325df8>07 mysql锁的类型有哪些？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-怎么处理mysql的慢查询？" data-v-2d325df8>08 怎么处理mysql的慢查询？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-什么是mvcc？" data-v-2d325df8>09 什么是mvcc？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-mvcc解决的问题是什么？" data-v-2d325df8>10 mvcc解决的问题是什么？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-rc-rr级别下的innodb快照读有什么不同" data-v-2d325df8>11 rc\rr级别下的innodb快照读有什么不同</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-什么是mysql的主从复制？" data-v-2d325df8>12 什么是mysql的主从复制？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-mysql为什么需要主从同步？" data-v-2d325df8>13 mysql为什么需要主从同步？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-mysql复制原理是什么？" data-v-2d325df8>14 mysql复制原理是什么？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-简述mysql中索引类型有哪些，以及对数据库的性能的影响？" data-v-2d325df8>15 简述mysql中索引类型有哪些，以及对数据库的性能的影响？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-spring-cloud" data-v-2d325df8>16 spring cloud</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_17-服务发现原理" data-v-2d325df8>17 服务发现原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_18-spring-cloud熔断器" data-v-2d325df8>18 spring cloud熔断器</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_19-服务注册发现过程" data-v-2d325df8>19 服务注册发现过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_20-zk与eureka区别" data-v-2d325df8>20 zk与eureka区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_21-rest-vs-rpc" data-v-2d325df8>21 rest  vs  rpc</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_22-feign" data-v-2d325df8>22 feign</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_23-ribbon和feign" data-v-2d325df8>23 ribbon和feign</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_24-服务网关" data-v-2d325df8>24 服务网关</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_25-常见问题" data-v-2d325df8>25 常见问题</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_26-eureka服务注册与发现原理" data-v-2d325df8>26 eureka服务注册与发现原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_27-dubbo服务注册与发现原理" data-v-2d325df8>27 dubbo服务注册与发现原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_28-服务限流" data-v-2d325df8>28 服务限流</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_29-eureka缓存机制" data-v-2d325df8>29 eureka缓存机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_30-接口限流" data-v-2d325df8>30 接口限流</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_31-不同类型的双因素身份认证" data-v-2d325df8>31 不同类型的双因素身份认证</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_32-nacos工作原理" data-v-2d325df8>32 nacos工作原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_33-dubbo的注册中心原理" data-v-2d325df8>33 dubbo的注册中心原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_34-分布式事务" data-v-2d325df8>34 分布式事务</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_35-mq事务" data-v-2d325df8>35 MQ事务</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_36-seata" data-v-2d325df8>36 Seata</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_37-sentinel" data-v-2d325df8>37 sentinel</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_38-sentinel原理" data-v-2d325df8>38 sentinel原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_39-什么是流量控制" data-v-2d325df8>39 什么是流量控制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_40-限流-熔断-降级分别是什么" data-v-2d325df8>40 限流 熔断 降级分别是什么</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_case_example_%E7%BB%BC%E5%90%88%E9%9D%A2" data-v-3886f8ec><div><h1 id="综合面" tabindex="-1">综合面 <a class="header-anchor" href="#综合面" aria-hidden="true">#</a></h1><h2 id="_01-什么的是bean的自动装配，它有哪些方式？" tabindex="-1">01 什么的是bean的自动装配，它有哪些方式？ <a class="header-anchor" href="#_01-什么的是bean的自动装配，它有哪些方式？" aria-hidden="true">#</a></h2><p>bean的自动装配指的是bean的属性值在进行注入的时候通过某种特定的规则和方式去容器中查找，并设置到具体的对象属性中， 主要有五种方式：</p><ul><li>no 缺省情况下，自动配置是通过“ref”属性手动设定，在项目中最常用</li><li>byName 根据属性名称自动装配。如果一个bean的名称和其他bean属性的名称是一样的，将会自装配它。</li><li>bytype 按数据类型自动装配，如果bean的数据类型是用其它bean属性的数据类型，兼容并自动装配它。</li><li>constructor 在构造函数参数的bytype方式。</li><li>autodetect 如果找到默认的构造函数，使用“自动装配用构造”; 否则，使用“按类型自动装配”。</li></ul><h2 id="_02-如何理解springboot中的starter？" tabindex="-1">02 如何理解springboot中的starter？ <a class="header-anchor" href="#_02-如何理解springboot中的starter？" aria-hidden="true">#</a></h2><ol><li>使用spring+springmvc框架进行开发的时候，如果需要引入mybatis框架，那么需要在xml中定义需要的bean对象，</li><li>这个过程很明显是很麻烦的，如果需要引入额外的其他组件，那么也需要进行复杂的配置，因此在springboot中引入了starter</li><li>starter就是一个jar包，写一个@configuration的配置类，将这些bean定义在其中，</li><li>然后再starter包的meta-iNf/spring.factories中写入配置类，那么springboot程序在启动的时候就会按照约定来加载该配置类</li><li>开发人员只需要将相应的starter包依赖进应用中，进行相关的属性配置，就可以进行代码开发，而不需要单独进行bean对象的配置</li></ol><h2 id="_03-mybatis的缺点" tabindex="-1">03 mybatis的缺点 <a class="header-anchor" href="#_03-mybatis的缺点" aria-hidden="true">#</a></h2><ol><li><p>关联表多时，字段多的时候，sql工作量很大。</p></li><li><p>sql依赖于数据库，导致数据库移植性差。</p></li><li><p>由于xml里标签id必须唯一，导致dao中方法不支持方法重载。</p></li><li><p>对象关系映射标签和字段映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。</p></li><li><p>dao层过于简单，对象组装的工作量较大。</p></li><li><p>不支持级联更新. 级联删除。</p></li><li><p>mybatis的日志除了基本记录功能外，其它功能薄弱很多。</p></li><li><p>编写动态sql时,不方便调试，尤其逻辑复杂时。</p></li><li><p>提供的写动态sql的xml标签功能简单，编写动态sql仍然受限，且可读性低。</p></li></ol><h2 id="_04-mysql聚簇和非聚簇索引的区别是什么？" tabindex="-1">04 mysql聚簇和非聚簇索引的区别是什么？ <a class="header-anchor" href="#_04-mysql聚簇和非聚簇索引的区别是什么？" aria-hidden="true">#</a></h2><ol><li>mysql的索引类型跟存储引擎是相关的，</li><li>innodb存储引擎数据文件跟索引文件全部放在ibd文件中，</li><li>而myisam的数据文件放在myd文件中，索引放在myi文件中，</li><li>其实区分聚簇索引和非聚簇索引非常简单，只要判断数据跟索引是否存储在一起就可以了。</li></ol><ul><li>innodb存储引擎在进行数据插入的时候，数据必须要跟索引放在一起，</li><li>如果有主键就使用主键，没有主键就使用唯一键，没有唯一键就使用6字节的rowid，</li><li>因此跟数据绑定在一起的就是聚簇索引，而为了避免数据冗余存储，其他的索引的叶子节点中存储的都是聚簇索引的key值，</li><li>因此innodb中既有聚簇索引也有非聚簇索引，而myisam中只有非聚簇索引。</li></ul><h2 id="_05-mysql索引结构有哪些，各自的优劣是什么？" tabindex="-1">05 mysql索引结构有哪些，各自的优劣是什么？ <a class="header-anchor" href="#_05-mysql索引结构有哪些，各自的优劣是什么？" aria-hidden="true">#</a></h2><p>索引的数据结构和具体存储引擎的实现有关</p><blockquote><p>mysql中使用较多的索引有hash索引，b+树索引，innodb的索引实现为b+树，memory存储引擎为hash索引。</p></blockquote><ul><li><p>b+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的二节点间有指针相关连接，在b+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因为，b+树索引被广泛应用于数据库. 文件系统等场景。</p></li><li><p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似b+树那样从根节点到叶子节点逐级查找，</p></li><li><p>只需一次哈希算法即可立刻定位到相应的位置，速度非常快。</p></li><li><p>如果是<strong>等值查询</strong>，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值，前提是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，知道找到对应的数据</p></li><li><p>如果是<strong>范围查询</strong>检索，这时候哈徐索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索</p></li><li><p>哈希所有也没办法利用索引完成排序，以及like这样的部分模糊查询</p></li><li><p>哈希索引也不支持多列联合索引的最左匹配规则</p></li><li><p>b+树索引的关键字检索效率比较平均，不像b树那样波动大，在有大量重复键值情况下，哈希索引的效率也是极低的，因此存在哈希碰撞问题。</p></li></ul><h2 id="_06-索引的设计原则有哪些？" tabindex="-1">06 索引的设计原则有哪些？ <a class="header-anchor" href="#_06-索引的设计原则有哪些？" aria-hidden="true">#</a></h2><p>在进行索引设计的时候，应该保证索引字段占用的空间越小越好，这只是一个大的方向，还有一些细节点需要注意下：</p><ol><li><p>适合索引的列是出现在where字句中的列，或者连接子句中指定的列</p></li><li><p>基数较小的表，索引效果差，没必要创建索引</p></li><li><p>在选择索引列的时候，越短越好，可以指定某些列的一部分，没必要用全部字段的值</p></li><li><p>不要给表中的每一个字段都创建索引，并不是索引越多越好</p></li><li><p>定义有外键的数据列一定要创建索引</p></li><li><p>更新频繁的字段不要有索引</p></li><li><p>创建索引的列不要过多，可以创建组合索引，但是组合索引的列的个数不建议太多</p></li><li><p>大文本. 大对象不要创建索引</p></li></ol><h2 id="_07-mysql锁的类型有哪些？" tabindex="-1">07 mysql锁的类型有哪些？ <a class="header-anchor" href="#_07-mysql锁的类型有哪些？" aria-hidden="true">#</a></h2><blockquote><p>基于锁的属性分类：共享锁. 排他锁。</p></blockquote><blockquote><p>基于锁的粒度分类：行级锁（innodb ）. 表级锁（ innodb . myisam）. 页级锁（ innodb引擎）. 记录锁. 间隙锁. 临键锁。</p></blockquote><blockquote><p>基于锁的状态分类：意向共享锁. 意向排它锁。</p></blockquote><ul><li><p>共享锁（share lock）： 共享锁又称读锁，简称 s 锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</p></li><li><p>排他锁（exclusive lock）：排他锁又称写锁，简称 x 锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取，避免了出现脏数据和脏读的问题。</p></li><li><p>表锁（table lock）：表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；特点：粒度大，加锁简单，容易冲突；</p></li><li><p>行锁：行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问，特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高</p></li><li><p>记录锁（record lock）:记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录，加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题</p></li><li><p>页锁：页级锁是 mysql 中锁定粒度介于行级锁和表级锁中间的一种锁．表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。特点：开销和加锁时间界于表锁和行锁之间，会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p></li><li><p>间隙锁：是属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻id之间出现空隙则会形成一个区间，遵循左开右闭原则。范围查询并且查询未命中记录，查询条件必须命中索引. 间隙锁只会出现在repeatabLe_read（重复读）的事务级别中。</p></li><li><p>临键锁（Next-Key lock)：也属于行锁的一种，并且它是iNNodb的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。</p></li></ul><h2 id="_08-怎么处理mysql的慢查询？" tabindex="-1">08 怎么处理mysql的慢查询？ <a class="header-anchor" href="#_08-怎么处理mysql的慢查询？" aria-hidden="true">#</a></h2><ol><li><p>开启慢查询日志，准确定位到哪个sql语句出现了问题</p></li><li><p>分析sql语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写</p></li><li><p>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引</p></li><li><p>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p></li></ol><h2 id="_09-什么是mvcc？" tabindex="-1">09 什么是mvcc？ <a class="header-anchor" href="#_09-什么是mvcc？" aria-hidden="true">#</a></h2><ol><li>mvcc 全称multi-version concurrency control，即多版本并发控制。</li><li>mvcc是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</li><li>mvcc在mysql innodb中的实现主要是为了提高数据库并发性能，用更好的方式去处理读写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</li></ol><ul><li><p>当前读 像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p></li><li><p>快照读（提高数据库的并发查询能力） 像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即mvcc,可以认为mvcc是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p></li></ul><div class="tip custom-block"><p class="custom-block-title">当前读. 快照读. mvcc关系</p><p>mvcc多版本并发控制指的是维持一个数据的多个版本，使得读写操作没有冲突，快照读是mysql为实现mvcc的一个非阻塞读功能。 mvcc模块在mysql中的具体实现是由三个隐式字段，undo日志. read view三个组件来实现的。</p></div><h2 id="_10-mvcc解决的问题是什么？" tabindex="-1">10 mvcc解决的问题是什么？ <a class="header-anchor" href="#_10-mvcc解决的问题是什么？" aria-hidden="true">#</a></h2><p>数据库并发场景有三种，分别为：</p><ol><li><p>读读：不存在任何问题，也不需要并发控制</p></li><li><p>读写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读. 幻读. 不可重复读</p></li><li><p>写写：有线程安全问题，可能存在更新丢失问题</p></li></ol><blockquote><p>mvcc是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联， 读操作只读该事务开始前的数据库的快照</p></blockquote><div class="tip custom-block"><p class="custom-block-title">所以mvcc可以为数据库解决一下问题：</p><ol><li><p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</p></li><li><p>解决脏读. 幻读. 不可重复读等事务隔离问题，但是不能解决更新丢失问题</p></li></ol></div><h2 id="_11-rc-rr级别下的innodb快照读有什么不同" tabindex="-1">11 rc\rr级别下的innodb快照读有什么不同 <a class="header-anchor" href="#_11-rc-rr级别下的innodb快照读有什么不同" aria-hidden="true">#</a></h2><p>因为read view生成时机的不同，从而造成rc. rr级别下快照读的结果的不同</p><ol><li><p>在rr级别下的某个事务的对某条记录的第一次快照读会创建一个快照即read view,将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个read view,所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个read view,所以对之后的修改不可见</p></li><li><p>在rr级别下，快照读生成read view时，read view会记录此时所有其他活动和事务的快照，这些事务的修改对于当前事务都是不可见的，而早于read view创建的事务所做的修改均是可见</p></li><li><p>在rc级别下，事务中，每次快照读都会新生成一个快照和read view,这就是我们在rc级别下的事务中可以看到别的事务提交的更新的原因。</p></li><li><p><strong>总结：在rc隔离级别下，是每个快照读都会生成并获取最新的read view,而在rr隔离级别下，则是同一个事务中的第一个快照读才会创建read view，之后的快照读获取的都是同一个read view.</strong></p></li></ol><h2 id="_12-什么是mysql的主从复制？" tabindex="-1">12 什么是mysql的主从复制？ <a class="header-anchor" href="#_12-什么是mysql的主从复制？" aria-hidden="true">#</a></h2><p>mysql 主从复制是指数据可以从一个mysql数据库服务器主节点复制到一个或多个从节点。</p><p><strong>mysql 默认采用异步复制方式，</strong></p><ul><li>这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，</li><li>从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</li></ul><h2 id="_13-mysql为什么需要主从同步？" tabindex="-1">13 mysql为什么需要主从同步？ <a class="header-anchor" href="#_13-mysql为什么需要主从同步？" aria-hidden="true">#</a></h2><ol><li><p>在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p></li><li><p>做数据的热备</p></li><li><p>架构的扩展。业务量越来越大，i/o访问频率过高，单机无法满足，此时做多库的存储，降低磁盘i/o访问的频率，提高单个机器的i/o性能。</p></li></ol><h2 id="_14-mysql复制原理是什么？" tabindex="-1">14 mysql复制原理是什么？ <a class="header-anchor" href="#_14-mysql复制原理是什么？" aria-hidden="true">#</a></h2><ol><li>master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；</li><li>slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个i/othread请求master二进制事件</li><li>同时主节点为每个i/o线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动sql线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后i/othread和sqlthread将进入睡眠状态，等待下一次被唤醒。</li></ol><p>也就是说：</p><ul><li>从库会生成两个线程,一个i/o线程,一个sql线程;</li><li>i/o线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li><li>主库会生成一个log dump线程,用来给从库i/o线程传binlog;</li><li>sql线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li></ul><blockquote><p>注意：</p></blockquote><ol><li>master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</li><li>slave开启两个线程：io线程和sql线程。</li></ol><ul><li>其中：io线程负责读取master的binlog内容到中继日志relay log里；</li><li>sql线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。</li></ul><ol start="3"><li><p>mysql复制至少需要两个mysql的服务，当然mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</p></li><li><p>mysql复制最好确保master和slave服务器上的mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</p></li><li><p>master和slave两节点间时间需同步<strong>具体步骤：</strong></p></li><li><p>从库通过手工执行change master to 语句连接主库，提供了连接的用户一切条件（user . password. port. ip）， 并且让从库知道，二进制日志的起点位置（file名 position 号）； start slave</p></li><li><p>从库的io线程和主库的dump线程建立连接。</p></li><li><p>从库根据change master to 语句提供的file名和position号，io线程向主库发起binlog的请求。</p></li><li><p>主库dump线程根据从库的请求，将本地binlog以events的方式发给从库io线程。</p></li><li><p>从库io线程接收binlog events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中</p></li><li><p>从库sql线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge</p></li></ol><h2 id="_15-简述mysql中索引类型有哪些，以及对数据库的性能的影响？" tabindex="-1">15 简述mysql中索引类型有哪些，以及对数据库的性能的影响？ <a class="header-anchor" href="#_15-简述mysql中索引类型有哪些，以及对数据库的性能的影响？" aria-hidden="true">#</a></h2><ul><li><p>普通索引：允许被索引的数据列包含重复的值</p></li><li><p>唯一索引：可以保证数据记录的唯一性</p></li><li><p>主键索引：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字primary key来创建</p></li><li><p>联合索引：索引可以覆盖多个数据列</p></li><li><p>全文索引：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术</p></li><li><p>索引可以极大地提高数据的查询速度</p></li><li><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</p></li><li><p>但是会降低插入. 删除. 更新表的速度，因为在执行这些写操作的时候，还要操作索引文件</p></li><li><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要简历聚簇索引，那么需要的空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，那么所有非聚簇索引都会跟着变</p></li></ul><h2 id="_16-spring-cloud" tabindex="-1">16 spring cloud <a class="header-anchor" href="#_16-spring-cloud" aria-hidden="true">#</a></h2><p>分布式系统基础设施开发，服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控</p><h2 id="_17-服务发现原理" tabindex="-1">17 服务发现原理 <a class="header-anchor" href="#_17-服务发现原理" aria-hidden="true">#</a></h2><ol><li>服务发布时指定对应的服务名（IP地址+端口）将服务注册到注册中心，这一个过程spring cloud自动实现，只需要main方法添加@EnableDisscoveryClient即可，同一个服务修改端口可启动多个实例。</li><li>调用方法，传递服务名称通过注册中心获取所有的可用实例，通过负载均衡策略调用（Ribbon和Feign）对应的服务</li></ol><h2 id="_18-spring-cloud熔断器" tabindex="-1">18 spring cloud熔断器 <a class="header-anchor" href="#_18-spring-cloud熔断器" aria-hidden="true">#</a></h2><ol><li>当一个服务调用另一个服务，由于网络原因或者自身原因出现问题时，调用者就会等待被调用的响应，当更多的服务请求到这些资源时，导致更多的请求等待，这样就会发生连锁效应，断路器就是解决这一问题的</li><li>断路器的状态有以下几种： <ul><li>a. 完全打开：一定时间内，达到一定的次数无法调用，并且多次检测没有恢复的迹象，断路器完全打开，那么下次请求不会请求到该服务</li><li>b. 半开：短时间内有恢复迹象，断路器会将部分请求发送给服务，当能正常调用时，断路器关闭。</li><li>c. 关闭：服务一直处于正常状态，能正常调用，断路器关闭。</li></ul></li></ol><h2 id="_19-服务注册发现过程" tabindex="-1">19 服务注册发现过程 <a class="header-anchor" href="#_19-服务注册发现过程" aria-hidden="true">#</a></h2><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置，随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂，有些服务可能会下降，而某些位置可能会发生变化，手动更改属性可能会产生问题，Eureka服务注册和发现可提供帮助，由于所有服务都在Eureka服务器上注册并通过调用eureka服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><h2 id="_20-zk与eureka区别" tabindex="-1">20 zk与eureka区别 <a class="header-anchor" href="#_20-zk与eureka区别" aria-hidden="true">#</a></h2><ol><li>zk保证的是CP、eureka保证AP</li><li>zk在选举期间注册服务瘫痪，虽然服务最终会恢复，但是选举期间不可用的</li><li>eureka各个节点是平等关系，只要有一台eureka就可以保证服务可用，而查询到的数据并不是最新的自我保护机制会导致eureka不再从注册列表移除因长时间没收到心跳而应该过期服务</li><li>eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点（高可用）。当网络稳定时，当前实例新的注册信息会被同步到其他节点中（最终一致性）。eureka可很好的应对因网络故障导致部分节点失去联系的情况，而不会像zk一样使得整个注册系统瘫痪。 <ul><li>a. zk有leader和follower角色，eureka各节点平等</li><li>b. zk采用过半数存活原则，eureka采用自我保护机制解决分区问题</li><li>c. eureka本质上是一个工程，zk只是一个进程</li></ul></li></ol><h2 id="_21-rest-vs-rpc" tabindex="-1">21 rest vs rpc <a class="header-anchor" href="#_21-rest-vs-rpc" aria-hidden="true">#</a></h2><ol><li>rpc主要缺陷是服务提供方和调用方式之间的依赖太强，需要对每一个微服务进行接口的定义，并通过持续继承发布，严格版本控制才不会出现冲突</li><li>rest是轻量级的接口，服务的提供和调用不存在代码之间的耦合，只需要一个约定进行规范</li></ol><h2 id="_22-feign" tabindex="-1">22 feign <a class="header-anchor" href="#_22-feign" aria-hidden="true">#</a></h2><ol><li>feign采用的基于接口的注解</li><li>feign整合ribbon，具有负载均衡的能力</li><li>hystrix具有熔断能力</li><li>使用 <ul><li>a. 添加pom依赖</li><li>b. 启动类添加@EnableFeignClients</li><li>c. 定义一个接口@FeignClient(name = &quot;xxx&quot;)指定调用哪个服务</li></ul></li></ol><h2 id="_23-ribbon和feign" tabindex="-1">23 ribbon和feign <a class="header-anchor" href="#_23-ribbon和feign" aria-hidden="true">#</a></h2><ol><li>ribbon都是调用其他服务的，但方式不同</li><li>启动类注解不同，ribbon是@RibbonClient。feign是@EnableFeignClients</li><li>服务指定的位置不同，ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</li><li>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐，Feign需要将调用的方法定义成抽象方法即可。</li></ol><h2 id="_24-服务网关" tabindex="-1">24 服务网关 <a class="header-anchor" href="#_24-服务网关" aria-hidden="true">#</a></h2><ol><li>简化客户端调用复杂度，统一处理外部请求</li><li>数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。</li><li>多渠道支持，针对不同的客户端提供不同的网关支持。</li><li>遗留系统的微服务化改造，可作为新老系统的中转组件</li><li>统一处理调用过程中的安全，权限问题</li></ol><h2 id="_25-常见问题" tabindex="-1">25 常见问题 <a class="header-anchor" href="#_25-常见问题" aria-hidden="true">#</a></h2><ol><li>超时：确保Hystrix超时时间配置为长于配置的Ribbon超时时间</li><li>feign path：feign客户端在部署时若有contextpath应该设置path= &quot;/****&quot;来匹配你的服务名</li><li>版本：springboot和springcloud版本要兼容</li></ol><h2 id="_26-eureka服务注册与发现原理" tabindex="-1">26 eureka服务注册与发现原理 <a class="header-anchor" href="#_26-eureka服务注册与发现原理" aria-hidden="true">#</a></h2><ol><li>每30s发送心跳检测重新进行租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中心移除</li><li>注册信息和更新会被复制到其他Eureka节点，来自任何区域的客户端可查找到注册中心信息，每30s发生一次复制来定位它们的服务，并进行远程调用</li><li>客户端还可以缓存一些服务实例信息，即使eureka全挂掉，客户端可定位服务地址的</li></ol><h2 id="_27-dubbo服务注册与发现原理" tabindex="-1">27 dubbo服务注册与发现原理 <a class="header-anchor" href="#_27-dubbo服务注册与发现原理" aria-hidden="true">#</a></h2><ol><li>服务容器负责启动，加载，运行服务提供者</li><li>服务提供者在启动时，向注册中心注册自己提供服务</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用</li><li>服务消费者和提供者，在内存中累计调用次数和调用时机，定时每分钟发送一次统计数据到监控中心。</li></ol><h2 id="_28-服务限流" tabindex="-1">28 服务限流 <a class="header-anchor" href="#_28-服务限流" aria-hidden="true">#</a></h2><p>http限流：我们使用nginx的limitzone来完成：</p><ol><li>这个表示使用ip进行限流zone名称为req_zone分配了10m空间使用漏桶算法每秒允许1个请求limit_req_zone $binary_remote_addr zone=req_one:10m rate=1r/s;</li><li>这边burst表示可瞬间超过20个请求，由于没有noDelay参数因此需要排队，如果超过这20个那么直接返回503，limit_req zone = req_three burst = 20; <ul><li>dubbo限流：dubbo提供了多个和请求相关的filter：ActiveLimitFilter ExecuteLimitFilter TPSLimiterFilter</li></ul></li><li>ActiveLimitFilter <ul><li>@Activate(Constants.CONSUMER，value=Constants.ACTIVES_KEY)</li><li>作用于客户端，主要作用是控制客户端方法的并发度</li><li>当超过了指定的active值之后该请求将等待前面的请求完成，何时结束呢，依赖于该方法的timeout，如果没有设置timeout的话，可能就是多个请求一直被阻塞，然后等待随机唤醒。</li></ul></li><li>ExecuteLimitFilter <ul><li>@Activate(group = Constants.PROVIDER，value=Constants.EXECUTES_KEY)</li><li>作用于服务端，一旦超出指定的数目直接报错，其实是指在服务端的并行度，需要注意这些都是指的是在单台服务上而不是整个服务集群</li></ul></li><li>TPSLimiterFilter <ul><li>@Activate(group=Constants.PROVIDER，value=Constants.TPS_LIMIT_RATE_KEY)</li><li>作用于服务端，控制一段时间内的请求数</li><li>默认情况下取得tps.interval字段表示请求间隔，如果无法找到则使用60s，根据tps字段表示允许调用次数，使用atomicInteger表示允许调用的次数，每次调用减少1次，当结果小于0之后返回不允许调用。</li></ul></li></ol><div class="tip custom-block"><p class="custom-block-title">spring cloud限流</p><ol><li>可通过semaphore.maxConcurrentRequests，coreSize，maxQueueSize和queueSizeRejectionThreshold设置信号量模式下的最大并发量、线程池大小、缓冲区大小和缓存区降级阈值</li><li>漏桶算法：水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大，会直接溢出，可看出漏桶算法能强行限制数据的传输速率。</li><li>令牌桶算法：除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输，令牌桶算法的原理是系统会以一个恒定的速度往桶里放令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。</li></ol></div><h2 id="_29-eureka缓存机制" tabindex="-1">29 eureka缓存机制 <a class="header-anchor" href="#_29-eureka缓存机制" aria-hidden="true">#</a></h2><ol><li>第一层缓存。readOnlyCacheMap，本质上是ConcurrentHashMap：这是一个JVM的CurrentHashMap只读缓存，这个主要是为了客户端获取注册信息时使用，其缓存更新，依赖于定时器的更新，通过和readWriteCacheMap的值做对比，如果数据不一致，则以readWriteCacheMap的数据为准，readOnlyCacheMap缓存更新的定时器时间间隔，默认为30秒</li><li>第二层缓存。readWriteCacheMap，本质上是Guava缓存，此处存放的是最终的缓存，当服务下线，过期，注册，状态变更，都会来清除这个缓存里面的数据，然后通过CacheLoader进行缓存加载，在进行readWriteCacheMap.get(key)的时候，首先看这个缓存里面有没有该数据，如果没有则通过CacheLoader的load方法去加载，加载成功之后将数据放入缓存，同时返回数据，readWriteCacheMap缓存过期时间，默认为180秒</li><li>缓存机制。设置一个每30秒执行一次的定时任务，定时去服务端获取注册信息，获取之后存入本地内存</li></ol><h2 id="_30-接口限流" tabindex="-1">30 接口限流 <a class="header-anchor" href="#_30-接口限流" aria-hidden="true">#</a></h2><ul><li>限制总并发数（比如：数据库连接池、线程池）</li><li>a. 限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）</li><li>b. 限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块、限制每秒的平均速率）</li><li>c. 限制远程接口，调用速率</li><li>d. 限制mq的消费速率</li><li>e. 可根据网络连接数、网络流量、CPU或内存负载等来限流</li></ul><h2 id="_31-不同类型的双因素身份认证" tabindex="-1">31 不同类型的双因素身份认证 <a class="header-anchor" href="#_31-不同类型的双因素身份认证" aria-hidden="true">#</a></h2><p>执行双因素身份验证需要三种类型的凭据</p><ol><li>一件你知道的事情，比如密码、密码或屏幕锁定模式</li><li>您拥有的物理凭证，如OTP、电话或ATM卡，换句话说，您在外部或第三方设备中拥有的任何类型的凭证</li><li>您的物理身份，如语言认证或生物特征安全，如指纹或眼睛扫描仪</li></ol><div class="tip custom-block"><p class="custom-block-title">客户证书</p><ul><li>客户端系统用于向远程服务器发出经过身份验证的请求的一种数字证书称为客户端证书，</li><li>客户端证书在许多相互认证设计中起非常重要的作用，为请求者的身份提供强有力的保证。</li></ul></div><h2 id="_32-nacos工作原理" tabindex="-1">32 nacos工作原理 <a class="header-anchor" href="#_32-nacos工作原理" aria-hidden="true">#</a></h2><ol><li>服务注册原理：在nacos的服务端，有一个用来管理微服务实例的容器，注册中心将微服务的实例交由ServiceHolder处理，ServiceHolder为微服务提供空间并将它的所有实例挂在该空间下。服务注册完成后提供者将于注册中心维护心跳机制，心跳机制可以保证注册中心可以及时的剔除失效的实例。</li><li>服务发现原理：服务完成注册之后，消费者可以向注册中心订阅某个服务，并提交一个监视器，当注册中心的服务发生变更时监听器会收到通知，然后消费者可以更新本地的服务实例列表，以保证所有的服务均可用。</li><li>nacos的负载均衡：Nacos 的客户端在获取到服务的完整实例列表后，会在客户端进行负载均衡算法来获取一个可用的实例，模式使用的是随机获取的方式。</li></ol><h2 id="_33-dubbo的注册中心原理" tabindex="-1">33 dubbo的注册中心原理 <a class="header-anchor" href="#_33-dubbo的注册中心原理" aria-hidden="true">#</a></h2><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h2 id="_34-分布式事务" tabindex="-1">34 分布式事务 <a class="header-anchor" href="#_34-分布式事务" aria-hidden="true">#</a></h2><p>分布式事务是指事务的参与方位于不同的分布式系统的节点上。</p><div class="tip custom-block"><p class="custom-block-title">分布式事务的基础理论</p><ul><li>CAP理论：是设计分布式系统的基础理论依据。强一致性 可用性 分区容错性。</li><li>BASE理论，是 Basically Available(基本可用) Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展。软状态：相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">分布式事务协议两阶段提交协议2PC</p><p>两阶段提交协议中，存在一个节点作为协调者，其他参与事务的节点作为参与者。</p><ol><li>第一阶段（准备阶段）：</li></ol><ul><li>协调者询问所有参与者是否可以执行提交操作，并等待参与者节点的响应。</li><li>参与者执行各自的本地事务操作，并将操作写入undo 日志。</li><li>若参与者事务执行成功，返回给协调者同意信号，否则返回终止信息。</li></ul><ol start="2"><li>第二阶段（提交阶段）：当协调者节点从所有参与者节点获得的相应消息都为&quot;同意&quot;时</li></ol><ul><li><p>协调者向所有参与者发出commit请求。</p></li><li><p>参与者节点完成事务提交操作并释放整个事务期间占用的资源。</p></li><li><p>参与者向协调者返回完成信息。协调者接收到所有参与者返回的完成信息后完成事务。</p></li><li><p><strong>若任一参与者节点在第一阶段返回的响应消息为&quot;中止&quot;。</strong></p></li><li><p>协调者节点向所有参与者节点发出&quot;回滚操作(rollback)&quot;的请求。</p></li><li><p>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p></li><li><p>参与者节点向协调者节点发送&quot;回滚完成&quot;消息。</p></li><li><p>协调者节点受到所有参与者节点反馈的&quot;回滚完成&quot;消息后，取消事务。</p></li></ul></div><div class="tip custom-block"><p class="custom-block-title">三阶段提交协议3PC</p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><ul><li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li><li>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit PreCommit DoCommit三个阶段</li></ul></div><div class="danger custom-block"><p class="custom-block-title">分布式事务的解决方案</p><ol><li>XA：该协议采用两阶段提交（2PC），即整个事务控制过程经历了两个阶段。</li><li>第一阶段：所有分支的操作都准备好了，由TM告知每个分支准备提交，此时，作为全局事物中的每个RM记录着在稳定存储中的动作（也就是说记录着准备好的这个动作）。</li><li>第二阶段：TM会告诉RM是提交或回滚，如果所有分支表明准备好能够提交时，RM会被告知提交，如果任何一个RM表明没有准备好或者不能提交，则进行全部回滚。</li><li>TCC（try-confirm-cancel）： <ul><li>try阶段：尝试执行，完成所有的业务检查，预留完成业务所必须的资源。</li><li>confirm阶段：当TCC事务管理器决定commit全局事务时，就会逐个执行Try操作指定的Confirm操作，将Try未完成的事项最终完成。不作任何业务检查，只使用Try阶段预留的业务资源。</li><li>cancel阶段：Cancel 是对Try操作的一个回撤。当TCC事务管理器决定rollback全局事务时，就会逐个执行Try操作指定的Cancel操作，将Try操作已完成的事项全部撤回。</li></ul></li></ol></div><h2 id="_35-mq事务" tabindex="-1">35 MQ事务 <a class="header-anchor" href="#_35-mq事务" aria-hidden="true">#</a></h2><ol><li>在系统A处理任务A前，首先向消息中间件发送一条消息</li><li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li><li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li><li>系统A收到确认应答后，则可以开始处理任务A；</li><li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。 但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成。</li><li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li><li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li></ol><h2 id="_36-seata" tabindex="-1">36 Seata <a class="header-anchor" href="#_36-seata" aria-hidden="true">#</a></h2><p>Seata提供一站式的分布式事务解决方案。可以提供AT（默认使用，基于2PC两阶段模式） TCC SAGA XA事务模式。</p><div class="tip custom-block"><p class="custom-block-title">Seata的3 + 1个概念</p><ul><li>TC：事务协调器，负责维护分布式事务的运行状态。负责协调并驱动全局事务的提交或者回滚。</li><li>TM： 事务管理器，是一个分布式的发起者和终结者。最终发起全局提交或回滚决议。</li><li>RM：资源管理器，负责本地事务的运行。负责分支注册，状态汇报，接收事务协调器的指令，驱动本地事务的提交和回滚。</li><li>Transaction ID：全局事务的唯一ID ， XID。</li></ul></div><blockquote><p>TM是一个分布式事务的发起者和终结者，TC负责维护分布式事务的运行状态，而RM则负责本地事务的运行。</p></blockquote><div class="warning custom-block"><p class="custom-block-title">Seata工作流程</p><ol><li>TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID</li><li>XID在微服务的调用链路中传播</li><li>RM向TC注册分支事务，将其纳入XID对应的全局事务管辖</li><li>TM向TC发起针对XID的全局提交或者回滚决议</li><li>TC调度XID下管辖的全部分支事务完成提交或者回滚请求</li></ol></div><div class="danger custom-block"><p class="custom-block-title">怎么用</p><ol><li>对于每个微服务对应的数据库都需要添加一张回滚日志表。用于自动的回滚一些数据。</li><li>下载seata-server软件包，<a href="http://github.com/seata/seata/releases" target="_blank" rel="noopener noreferrer">github.com/seata/seata/releases</a></li><li>导入依赖 spring-cloud-starter-alibaba-seata</li><li>启动 seata-server</li><li>所有想要使用到分布式事务的微服务使用seata DatasourceProxy代理自己的数据源</li><li>@GlobaTransactional 开启全局事务。（只需要给分布式事务入口标上该注解即可），对于远程调用的方法不需要标。</li><li>启动各个微服务即可。</li></ol></div><h2 id="_37-sentinel" tabindex="-1">37 sentinel <a class="header-anchor" href="#_37-sentinel" aria-hidden="true">#</a></h2><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式服务架构的轻量级高可用流量控制产品，由阿里中间件团队开源。主要以流量为切入点，从流量限制 服务熔断降级 系统负载保护等多个维度来帮助您保护服务的稳定性。</p><h2 id="_38-sentinel原理" tabindex="-1">38 sentinel原理 <a class="header-anchor" href="#_38-sentinel原理" aria-hidden="true">#</a></h2><p>sentinel项目分为7个主要部分，其中最主要的 就是sentinel-core模块。限流 熔断 降级 系统保护等都在这里实现。</p><h2 id="_39-什么是流量控制" tabindex="-1">39 什么是流量控制 <a class="header-anchor" href="#_39-什么是流量控制" aria-hidden="true">#</a></h2><ul><li>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。</li><li>任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。</li><li>Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状。</li></ul><h2 id="_40-限流-熔断-降级分别是什么" tabindex="-1">40 限流 熔断 降级分别是什么 <a class="header-anchor" href="#_40-限流-熔断-降级分别是什么" aria-hidden="true">#</a></h2><ul><li><p>限流：对于打入集群的请求流量在入口处进行控制，使服务能够承担不超过自己能力的流量压力。</p></li><li><p>熔断：A服务调用B服务，由于各种各样的原因导致请求时间过长。这样的情况次数过多就应该考虑将B服务直接断路。凡是调用B服务直接返回错误数据。</p></li><li><p>降级：由于服务器的压力较大而对一些服务进行有针对的降级，从而保证核心业务的正常运行。</p></li></ul></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-17T06:48:31.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>