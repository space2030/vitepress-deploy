<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_case_example_网络.md.2753f5be.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#_01-路由回路" data-v-2d325df8>01 路由回路</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-四次挥手最后等待为什么2msl" data-v-2d325df8>02 四次挥手最后等待为什么2MSL</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-https怎么保证安全" data-v-2d325df8>03 https怎么保证安全</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-ssl-tls连接怎么建立" data-v-2d325df8>04 SSL/TLS连接怎么建立</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_05-为什么是四次挥手-为什么time-wait等待2msl时间" data-v-2d325df8>05 为什么是四次挥手 为什么time-wait等待2MSL时间</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-tcp与udp" data-v-2d325df8>06 TCP与UDP</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-tcp的流量控制" data-v-2d325df8>07 TCP的流量控制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-tcp三次握手过程中客户机与服务端的状态变化" data-v-2d325df8>08 TCP三次握手过程中客户机与服务端的状态变化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-arp工作原理" data-v-2d325df8>09 ARP工作原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-icmp协议" data-v-2d325df8>10 ICMP协议</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-数据链路层的作用" data-v-2d325df8>11 数据链路层的作用</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-传输层协议与网络层协议的区别" data-v-2d325df8>12 传输层协议与网络层协议的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-静态路由和动态路由的区别" data-v-2d325df8>13 静态路由和动态路由的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-io-同步-异步区别-阻塞-非阻塞区别" data-v-2d325df8>14 IO 同步 异步区别 阻塞 非阻塞区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-数据链路层的协议" data-v-2d325df8>15 数据链路层的协议</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-dns寻址过程" data-v-2d325df8>16 DNS寻址过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_17-输入网址的过程" data-v-2d325df8>17 输入网址的过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_18-http1-0-和-http1-1-和-http2的区别" data-v-2d325df8>18 HTTP1.0 和 HTTP1.1 和 HTTP2的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_19-http协议的标准请求头有哪些" data-v-2d325df8>19 Http协议的标准请求头有哪些</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_20-如何预防tcp三次握手期间的syn攻击" data-v-2d325df8>20 如何预防TCP三次握手期间的SYN攻击</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_21-tcp与udp的区别" data-v-2d325df8>21 TCP与UDP的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_22-http协议为什么设计为无状态的" data-v-2d325df8>22 HTTP协议为什么设计为无状态的</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_23-tcp如何保证可靠传输" data-v-2d325df8>23 TCP如何保证可靠传输</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_24-http常用状态码" data-v-2d325df8>24 http常用状态码</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_25-tcp的三次握手为什么不是两次" data-v-2d325df8>25 TCP的三次握手为什么不是两次</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_26-session-vs-cookie" data-v-2d325df8>26 session vs cookie</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_27-session-工作原理" data-v-2d325df8>27 session 工作原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_28-如果客户端禁止-cookie-能实现-session-还能用吗？" data-v-2d325df8>28 如果客户端禁止 cookie 能实现 session 还能用吗？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_29-csrf-攻击" data-v-2d325df8>29 CSRF 攻击</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_30-tcp-vs-udp" data-v-2d325df8>30 tcp vs udp</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_31-tcp-为什么要三次握手，两次不行吗？为什么？" data-v-2d325df8>31 tcp 为什么要三次握手，两次不行吗？为什么？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_32-tcp-粘包" data-v-2d325df8>32 tcp 粘包</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_33-get-vs-post" data-v-2d325df8>33 get vs post</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_34-rpc的实现原理" data-v-2d325df8>34 RPC的实现原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_35-dubbo实现原理" data-v-2d325df8>35 Dubbo实现原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_36-servlet生命周期" data-v-2d325df8>36 Servlet生命周期</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_37-servlet链" data-v-2d325df8>37 Servlet链</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_38-cookie-vs-session" data-v-2d325df8>38 cookie  vs  session</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_39-认证-authentication-vs-授权-authorization" data-v-2d325df8>39 认证 (Authentication) vs 授权 (Authorization)</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_40-token-vs-jwt" data-v-2d325df8>40 Token vs JWT</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_41-分布式架构下，session-共享有什么方案" data-v-2d325df8>41 分布式架构下，Session 共享有什么方案</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_42-cookies、sessionstorage、localstorage" data-v-2d325df8>42 cookies、sessionStorage、localStorage</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_43-http协议" data-v-2d325df8>43 HTTP协议</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_44-cookies-vs-session" data-v-2d325df8>44 cookies vs session</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_45-get-vs-post" data-v-2d325df8>45 get vs  post</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_46-http优化方案" data-v-2d325df8>46 HTTP优化方案</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_47-doctype作用" data-v-2d325df8>47 DOCTYPE作用</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_48-dtd" data-v-2d325df8>48 DTD</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_49-var、let、const之间的区别" data-v-2d325df8>49 var、let、const之间的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_50-ajax" data-v-2d325df8>50 ajax</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_51-get-vs-post" data-v-2d325df8>51 get vs post</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_52-javascript-规范" data-v-2d325df8>52 JavaScript 规范</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_case_example_%E7%BD%91%E7%BB%9C" data-v-3886f8ec><div><h1 id="网络" tabindex="-1">网络 <a class="header-anchor" href="#网络" aria-hidden="true">#</a></h1><h2 id="_01-路由回路" tabindex="-1">01 路由回路 <a class="header-anchor" href="#_01-路由回路" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">路由是网络层组件，在维护路由表信息的时候，如果在拓扑发生改变后，网络收敛缓慢产生了不协调或者矛盾的路由选择条目，</p><p>就会发生路由环路的问题。这种情况下会导致用户的IP数据包不停在网络上循环发送，最终造成网络资源的严重浪费。</p></div><blockquote><p>RIP协议解决路由回路问题，RIP协议是一种基于距离度量的路由选择协议。</p></blockquote><ol><li>最大跳数：距离是指跳数，直接相邻的路由器跳数为1，跳数超过15表示不可达。</li><li>水平分割：</li><li>路由中毒：</li><li>毒性逆转：</li><li>控制更新时间：</li><li>触发更新：OSPF（开放最短路径优先）协议解决路由回路问题。</li></ol><h2 id="_02-四次挥手最后等待为什么2msl" tabindex="-1">02 四次挥手最后等待为什么2MSL <a class="header-anchor" href="#_02-四次挥手最后等待为什么2msl" aria-hidden="true">#</a></h2><p>两个原因：</p><ol><li>确保最后一个确认报文到达，如果server没有收到client发送来的确认报文，那么就会重新发送连接释放请求报文。客户机等待一段时间就是为了处理这种情况发生。</li><li>等待一段时间是为了让本连接内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ol><h2 id="_03-https怎么保证安全" tabindex="-1">03 https怎么保证安全 <a class="header-anchor" href="#_03-https怎么保证安全" aria-hidden="true">#</a></h2><p>http的安全问题：</p><ol><li>使用明文通信，内容可能被窃听。</li><li>不验证通信方身份，通信方身份可能存在伪装。</li><li>无法验证报文的完整性，报文有可能遭到篡改。https通过使用SSL具有了加密（混合加密） 认证（数字证书，用于存放公钥，保证其不被篡改以及可信性） 完整性保护（摘要算法）等功能。</li></ol><h2 id="_04-ssl-tls连接怎么建立" tabindex="-1">04 SSL/TLS连接怎么建立 <a class="header-anchor" href="#_04-ssl-tls连接怎么建立" aria-hidden="true">#</a></h2><p>SSL：<strong>安全套接字层</strong>，位于传输层与应用层之间的一种协议层。通过相互认证 使用数字签名确保完整性。使用加密保证私密性。 以实现客户机服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</p><ol><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ol><h2 id="_05-为什么是四次挥手-为什么time-wait等待2msl时间" tabindex="-1">05 为什么是四次挥手 为什么time-wait等待2MSL时间 <a class="header-anchor" href="#_05-为什么是四次挥手-为什么time-wait等待2msl时间" aria-hidden="true">#</a></h2><ul><li>如果是两次挥手，客户机请求关闭服务端直接关闭了，有可能服务端的数据并没有传输完成，造成数据丢失。</li><li>如果是三次挥手，服务端数据传输完成立即关闭连接。可能会导致本次tcp连接产生的报文残留在网络中。所以需要四次挥手。</li></ul><h2 id="_06-tcp与udp" tabindex="-1">06 TCP与UDP <a class="header-anchor" href="#_06-tcp与udp" aria-hidden="true">#</a></h2><ul><li><p>TCP是传输控制协议，提供面向连接的可靠的字节流服务。通过三次握手建立连接。之后才能进行数据传输。TCP提供超时重传 流量控制 拥塞控制等功能。</p></li><li><p>UDP是用户数据报协议，是一个简单的面向无连接的协议。UDP不提供可靠服务，由于传输数据之前不需要建立连接，所以传输速度很快。其主要使用场景有流媒体传输。</p></li></ul><h2 id="_07-tcp的流量控制" tabindex="-1">07 TCP的流量控制 <a class="header-anchor" href="#_07-tcp的流量控制" aria-hidden="true">#</a></h2><p>利用滑动窗口实现流量控制，如果发送方把数据发送得过快，接收方可能会来不及接收， 这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><h2 id="_08-tcp三次握手过程中客户机与服务端的状态变化" tabindex="-1">08 TCP三次握手过程中客户机与服务端的状态变化 <a class="header-anchor" href="#_08-tcp三次握手过程中客户机与服务端的状态变化" aria-hidden="true">#</a></h2><ol><li>客户机经历了：close -&gt; SYN-sent -&gt; estab-listen</li><li>服务端经历了：close -&gt; listen -&gt; SYN-RCVD -&gt;estab-listen</li><li>TCP的拥塞控制 <ul><li>拥塞窗口概念。初始化cwnd = 1</li><li>慢开始 拥塞避免 快重传 快恢复。</li></ul></li></ol><h2 id="_09-arp工作原理" tabindex="-1">09 ARP工作原理 <a class="header-anchor" href="#_09-arp工作原理" aria-hidden="true">#</a></h2><ul><li>ARP：地址解析协议。</li><li>每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li><li>源主机向当前网段的所有主机发送ARP数据包，包含了源主机IP MAC地址，以及目标主机IP地址。</li><li>本地网络的主机收到数据包后检查其中的目标IP是否为自己的。</li><li>如果不是则忽略，如果是的话就将自己的MAC地址写入数据包，并将数据包中源主机的IP MAC地址写入自己的ARP缓冲区中。</li></ul><h2 id="_10-icmp协议" tabindex="-1">10 ICMP协议 <a class="header-anchor" href="#_10-icmp协议" aria-hidden="true">#</a></h2><ul><li>ICMP是Internet Control Message Protocol，因特网控制报文协议。</li><li>它是TCP/IP协议族的一个子协议，用于在IP主机 路由器之间传递控制消息。</li><li>控制消息是指网络通不通 主机是否可达 路由器是否可用等网络本身的消息。</li><li>这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</li><li>ICMP报文有两种：差错报告报文和询问报文。</li></ul><h2 id="_11-数据链路层的作用" tabindex="-1">11 数据链路层的作用 <a class="header-anchor" href="#_11-数据链路层的作用" aria-hidden="true">#</a></h2><p>封装成帧 透明传输 差错检测（循环冗余检测保证传输过程中的数据准确性）。</p><h2 id="_12-传输层协议与网络层协议的区别" tabindex="-1">12 传输层协议与网络层协议的区别 <a class="header-anchor" href="#_12-传输层协议与网络层协议的区别" aria-hidden="true">#</a></h2><p>网络层协议负责的是提供主机间的逻辑通信，运输层协议负责的是提供进程间的逻辑通信。</p><h2 id="_13-静态路由和动态路由的区别" tabindex="-1">13 静态路由和动态路由的区别 <a class="header-anchor" href="#_13-静态路由和动态路由的区别" aria-hidden="true">#</a></h2><ul><li>静态路由是由管理员手工配置的，适合比较简单的网络或需要做路由特殊控制。</li><li>而动态路由则是由动态路由协议自动维护的，不需人工干预，适合比较复杂大型的网络。</li></ul><h2 id="_14-io-同步-异步区别-阻塞-非阻塞区别" tabindex="-1">14 IO 同步 异步区别 阻塞 非阻塞区别 <a class="header-anchor" href="#_14-io-同步-异步区别-阻塞-非阻塞区别" aria-hidden="true">#</a></h2><ul><li><p>客户端发出一个请求，在服务器做出响应之前客户端发过来的请求线程会被挂起，这就是阻塞。此时线程只能等完成这次的请求之后才可以去处理其他的事件，这就叫做同步。</p></li><li><p>客户端发出了一个请求，然后不等服务器处理就直接返回给客户端了。此时请求线程没有被挂起，这就是非阻塞。线程可以去处理其他事件，这就是异步。服务器通过回调函数来处理这个请求。</p></li></ul><div class="tip custom-block"><p class="custom-block-title">BIO、NIO、AIO</p><ul><li><strong>BIO</strong>：Block IO 同步阻塞式 IO，特点是模式简单使用方便，并发处理能力低。</li><li><strong>NIO</strong>：Non IO 同步非阻塞 IO，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li><strong>AIO</strong>：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul></div><h2 id="_15-数据链路层的协议" tabindex="-1">15 数据链路层的协议 <a class="header-anchor" href="#_15-数据链路层的协议" aria-hidden="true">#</a></h2><ul><li><p><strong>点到点信道的数据链路层协议：</strong> PPP（point-to-point protocal）协议：互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p></li><li><p><strong>使用广播信道的数据链路层协议：</strong></p></li></ul><div class="tip custom-block"><p class="custom-block-title"><strong>载波监听 多点接入 冲突检测协议：</strong></p><ul><li>多点接入：许多计算机以多点接入的方式连在一根总线上。</li><li>载波监听：监听线路上其他设备是否在线，不在线的话可以进行通信</li><li>冲突检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。</li></ul></div><h2 id="_16-dns寻址过程" tabindex="-1">16 DNS寻址过程 <a class="header-anchor" href="#_16-dns寻址过程" aria-hidden="true">#</a></h2><ol><li>本地host文件</li><li>本地DNS解析器缓存</li><li>本地DNS服务器</li><li>根域名DNS服务器</li><li>递归的去找到包含目标IP的DNS服务器</li></ol><h2 id="_17-输入网址的过程" tabindex="-1">17 输入网址的过程 <a class="header-anchor" href="#_17-输入网址的过程" aria-hidden="true">#</a></h2><ol><li>浏览器向DNS服务器请求解析该url中携带域名的IP地址，并返回给浏览器</li><li>浏览器与上述ip地址服务器通过三次握手建立TCP连接</li><li>浏览器发出HTTP请求，随后服务器将浏览器请求的资源发送给浏览器</li><li>数据传输完成，浏览器请求关闭TCP连接（四次挥手）</li><li>浏览器渲染资源，进行页面展示</li></ol><h2 id="_18-http1-0-和-http1-1-和-http2的区别" tabindex="-1">18 HTTP1.0 和 HTTP1.1 和 HTTP2的区别 <a class="header-anchor" href="#_18-http1-0-和-http1-1-和-http2的区别" aria-hidden="true">#</a></h2><ol><li>HTTP1.1相较于HTTP1.0 增加了长连接功能，该功能不会主动的去断开一个TCP连接，这样的话就不用每次发送HTTP请求时都重新建立TCP连接。因为重复的建立 断开TCP连接费时又费资源。</li><li>HTTP2.0主要有以下几个新特性：头部压缩 多路复用 二进制帧层</li></ol><h2 id="_19-http协议的标准请求头有哪些" tabindex="-1">19 Http协议的标准请求头有哪些 <a class="header-anchor" href="#_19-http协议的标准请求头有哪些" aria-hidden="true">#</a></h2><ul><li>Accept：可以接收的响应内容格式</li><li>Connection：客户端想要优先使用的连接类型，keep-alive upgrade</li><li>Host：客户端告诉服务端它请求的资源所在的主机与端口号</li><li>Cookie：客户端请求时携带的数据</li></ul><div class="tip custom-block"><p class="custom-block-title">HTTP vs HTTPS</p><ol><li>HTTP明文传输，数据都是未加密的，安全性较差，HTTPS（SSL + HTTP）数据传输过程是加密的，安全性较好。</li><li>使用HTTPS协议需要到CA申请证书，一般免费的证书较少，因而需要一定费用。</li><li>HTTP页面响应速度比HTTPS快，主要因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包，而HTTPS除了TCP的3个包，还要加SSL握手需要的9个包，所以一共是12个包。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li></ol></div><div class="warning custom-block"><p class="custom-block-title">TCP/IP协议</p><ol><li>是一个协议簇，是一个开放的协议标准，所有人都可以免费使用，并且是独立于硬件和操作系统的。</li><li>是不区分网络硬件的，它在局域网和互联网中都被广泛使用</li><li>使用统一的网络地址分配的方案，网络中的每台电脑都具有唯一的IP地址</li><li>是一个标准的高层协议，拥有极高的可靠性，为用户提供可靠的服务</li></ol></div><h2 id="_20-如何预防tcp三次握手期间的syn攻击" tabindex="-1">20 如何预防TCP三次握手期间的SYN攻击 <a class="header-anchor" href="#_20-如何预防tcp三次握手期间的syn攻击" aria-hidden="true">#</a></h2><ol><li>首先，TCP协议建立连接前需要双方确认信息，用于防止伪造连接以及精准控制整个数据传输过程中数据完整有效。</li><li>这样就会造成TCP连接的资源消耗，其中包括：数据包信息 条件状态 序列号等等。</li><li>SYN攻击就是故意不完成建立连接所需要的三次握手过程，造成连接一方的资源耗尽。</li></ol><div class="danger custom-block"><p class="custom-block-title">SYN攻击</p><ul><li>如何检测：Linux中使用 netstat -n -p TCP | grep SYN_RECV 命令检测是否被SYN攻击。</li><li>如何防范 ：主要有两大类，一类是通过防火墙 路由器等过滤网关防护，另一类是通过加固TCP/IP协议栈防范。</li></ul></div><h2 id="_21-tcp与udp的区别" tabindex="-1">21 TCP与UDP的区别 <a class="header-anchor" href="#_21-tcp与udp的区别" aria-hidden="true">#</a></h2><ol><li>TCP是面向连接的协议，在收发数据前需要与对方建立可靠的连接。一个TCP连接必须通过三次握手才能建立起可靠的连接。而UDP是一个非连接协议。由于传输数据不建立连接，因此一台服务器可以向多客户机传输相同的信息。</li><li>TCP的滑动窗口可以进行流量控制，而UDP的吞吐量除了受网络带宽等限制外不受其他限制。</li><li>TCP提供基于超时重传的可靠交付，而UDP提供尽最大努力交付，即不保证可靠交付。</li><li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。TCP面向数据流。</li></ol><h2 id="_22-http协议为什么设计为无状态的" tabindex="-1">22 HTTP协议为什么设计为无状态的 <a class="header-anchor" href="#_22-http协议为什么设计为无状态的" aria-hidden="true">#</a></h2><p>HTTP设计为无状态的话服务端就可以根据需求将请求分发到服务集群的任意节点上。有利于做负载均衡。</p><h2 id="_23-tcp如何保证可靠传输" tabindex="-1">23 TCP如何保证可靠传输 <a class="header-anchor" href="#_23-tcp如何保证可靠传输" aria-hidden="true">#</a></h2><p>依靠超时重传实现可靠传输。TCP每发送一个数据报后会开启一个计时器，等待目标服务器确认收到了这个报文段。如果计时器时间内没有收到确认，则会重发这个报文段。</p><h2 id="_24-http常用状态码" tabindex="-1">24 http常用状态码 <a class="header-anchor" href="#_24-http常用状态码" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">状态码</p><ul><li><p>1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</p></li><li><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p></li><li><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 -「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 -「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p></li><li><p>4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li><li><p>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p></li></ul></div><h2 id="_25-tcp的三次握手为什么不是两次" tabindex="-1">25 TCP的三次握手为什么不是两次 <a class="header-anchor" href="#_25-tcp的三次握手为什么不是两次" aria-hidden="true">#</a></h2><ul><li>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</li><li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li><li>顺带也解决了已失效的连接请求又传送到服务器端的问题。</li></ul><h2 id="_26-session-vs-cookie" tabindex="-1">26 session vs cookie <a class="header-anchor" href="#_26-session-vs-cookie" aria-hidden="true">#</a></h2><ul><li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li><li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li><li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</li><li>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li></ul><h2 id="_27-session-工作原理" tabindex="-1">27 session 工作原理 <a class="header-anchor" href="#_27-session-工作原理" aria-hidden="true">#</a></h2><ul><li>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，</li><li>会把 session 的 id 发送给客户端，客户端再存储到浏览器中。</li><li>这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，</li><li>在内存找到与之对应的 session 这样就可以正常工作了。</li></ul><h2 id="_28-如果客户端禁止-cookie-能实现-session-还能用吗？" tabindex="-1">28 如果客户端禁止 cookie 能实现 session 还能用吗？ <a class="header-anchor" href="#_28-如果客户端禁止-cookie-能实现-session-还能用吗？" aria-hidden="true">#</a></h2><ul><li>可以用，session 只是依赖 cookie 存储 sessionid，</li><li>如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</li></ul><h2 id="_29-csrf-攻击" tabindex="-1">29 CSRF 攻击 <a class="header-anchor" href="#_29-csrf-攻击" aria-hidden="true">#</a></h2><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造）， 可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求， 比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p><div class="tip custom-block"><p class="custom-block-title">防御手段：</p><ul><li>验证请求来源地址；</li><li>关键操作添加验证码；</li><li>在请求地址添加token 并验证。</li></ul></div><h2 id="_30-tcp-vs-udp" tabindex="-1">30 tcp vs udp <a class="header-anchor" href="#_30-tcp-vs-udp" aria-hidden="true">#</a></h2><blockquote><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。 tcp 提供可靠的通信传输 udp 则常被用于让广播和细节控制交给应用的通信传输。</p></blockquote><div class="tip custom-block"><p class="custom-block-title">两者的区别大致如下：</p><ul><li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li><li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li><li>tcp 面向字节流，udp 面向报文；</li><li>tcp 数据传输慢，udp 数据传输快；</li></ul></div><h2 id="_31-tcp-为什么要三次握手，两次不行吗？为什么？" tabindex="-1">31 tcp 为什么要三次握手，两次不行吗？为什么？ <a class="header-anchor" href="#_31-tcp-为什么要三次握手，两次不行吗？为什么？" aria-hidden="true">#</a></h2><ol><li><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接， 但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端， 这样服务器端就白白浪费了一定的资源。</p></li><li><p>若采用三次握手，服务器端没有收到来自客户端的再此确认， 则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p></li></ol><h2 id="_32-tcp-粘包" tabindex="-1">32 tcp 粘包 <a class="header-anchor" href="#_32-tcp-粘包" aria-hidden="true">#</a></h2><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><ul><li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li><li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li></ul><h2 id="_33-get-vs-post" tabindex="-1">33 get vs post <a class="header-anchor" href="#_33-get-vs-post" aria-hidden="true">#</a></h2><ul><li>get 请求会被浏览器主动缓存，而 post 不会。</li><li>get 传递参数有大小限制，而 post 没有。</li><li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li></ul><h2 id="_34-rpc的实现原理" tabindex="-1">34 RPC的实现原理 <a class="header-anchor" href="#_34-rpc的实现原理" aria-hidden="true">#</a></h2><ol><li>首先需要有处理网络连接通讯的模块，负责连接建立、管理和消息的传输。</li><li>其次需要有编解码的模块，因为网络通讯都是传输的字节码，需要将我们使用的对象序列化和反序列化。</li><li>剩下的就是客户端和服务器端的部分，服务器端暴露要开放的服务接口，客户调用服务接口的一个代理实现，这个代理实现负责收集数据、编码并传输给服务器然后等待结果返回。</li></ol><h2 id="_35-dubbo实现原理" tabindex="-1">35 <code>Dubbo</code>实现原理 <a class="header-anchor" href="#_35-dubbo实现原理" aria-hidden="true">#</a></h2><ol><li>本地有对远程方法的描述，包括方法名、参数、返回值，在<code>dubbo</code>中远程和本地使用同样的接口</li><li>要对网络通信的封装，要对调用方来说通信细节是完全不可见的，网络通信要做的就是将调用方法的属性通过一定的协议传递到服务端</li><li>服务端按照协议解析出调用的信息，执行相应的方法，</li><li>在将方法的返回值通过协议传递给客户端</li><li>客户端再解析，在调用方式上又可以分为同步调用和异步调用。</li></ol><h2 id="_36-servlet生命周期" tabindex="-1">36 Servlet生命周期 <a class="header-anchor" href="#_36-servlet生命周期" aria-hidden="true">#</a></h2><ol><li>对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。</li><li>然后Servlet对象通过为每一个请求单独调用service()方法来处理</li><li>调用Servlet的destroy()方法把Servlet删除掉。</li></ol><h2 id="_37-servlet链" tabindex="-1">37 Servlet链 <a class="header-anchor" href="#_37-servlet链" aria-hidden="true">#</a></h2><ol><li>Servlet链是把一个Servlet的输出发送给另一个Servlet的方法</li><li>第二个Servlet的输出可以发送给第三个Servlet</li><li>链条上最后一个Servlet负责把响应发送给客户端。</li></ol><blockquote><p>ServletRequest类可以找出客户端机器的IP地址或者主机名 getRemoteAddr(）方法获取客户端主机的IP地址 getRemoteHost() 获取主机名</p></blockquote><h2 id="_38-cookie-vs-session" tabindex="-1">38 cookie vs session <a class="header-anchor" href="#_38-cookie-vs-session" aria-hidden="true">#</a></h2><ol><li>cookie是web服务器发送给浏览器的一块信息，浏览器会在本地文件中给每一个web服务器存储cookie</li><li>以后浏览器在给特定的web服务器发请求的时候，同时会发送所有为该服务器存储的cookie</li><li>无论客户端浏览器做怎么样设置，session都应该能正常工作，客户端可以选择禁用cookie，但session仍可以工作，因为客户端无法禁用服务器端的session</li><li>在存储的数据量方面session和cookie不同，session能够存储任意的java对象，cookie只能存储String类型的对象</li></ol><div class="tip custom-block"><p class="custom-block-title">cookie</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p></div><div class="tip custom-block"><p class="custom-block-title">session</p><p>Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p></div><div class="tip custom-block"><p class="custom-block-title">session进行身份验证</p><p>很多时候我们都是通过 SessionID 来实现特定的用户，SessionID 一般会选择存放在 Redis 中。举个例子：用户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。</p></div><blockquote><p>用户向服务器发送用户名和密码用于登陆系统。 服务器验证通过后，服务器为用户创建一个 Session， 并将 Session信息存储 起来。 服务器向用户返回一个 SessionID，写入用户的 Cookie。 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份， 返回给用户客户端响应信息的时候会附带用户当前的状态。</p></blockquote><p><strong>使用 Session 的时候需要注意下面几个点：</strong></p><ul><li>依赖Session的关键业务一定要确保客户端开启了Cookie。</li><li>注意Session的过期时间</li></ul><h2 id="_39-认证-authentication-vs-授权-authorization" tabindex="-1">39 认证 (Authentication) vs 授权 (Authorization) <a class="header-anchor" href="#_39-认证-authentication-vs-授权-authorization" aria-hidden="true">#</a></h2><ul><li><p>Authentication（认证） 是验证您的身份的凭据（例如用户名/用户ID和密码），通过这个凭据，系统得以知道你就是你， 也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。</p></li><li><p>Authorization（授权） 发生在 Authentication（认证） 之后。授权，它主要掌管我们访问系统的权限。 比如有些特定资源只能具有特定权限的人才能访问比如admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。 这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。</p></li></ul><h2 id="_40-token-vs-jwt" tabindex="-1">40 Token vs JWT <a class="header-anchor" href="#_40-token-vs-jwt" aria-hidden="true">#</a></h2><ol><li>JWT （JSON Web Token） 这种方式服务器端不保存 Session 数据，只用客户端保存服务端返回给客户的 Token 即可。</li><li>JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。</li></ol><h2 id="_41-分布式架构下，session-共享有什么方案" tabindex="-1">41 分布式架构下，Session 共享有什么方案 <a class="header-anchor" href="#_41-分布式架构下，session-共享有什么方案" aria-hidden="true">#</a></h2><ol><li>不要有session：但是确实在某些场景下，是可以没有session的，其实在很多接口类系统当中，都提倡【API无状态服务】；</li><li>也就是每一次的接口访问，都不依赖于session、不依赖于前一次的接口访问；</li><li>存入cookie中：将session存储到cookie中，但是缺点也很明显，例如每次请求都得带着session，数据存储在客户端本地，是有风险的；</li></ol><div class="tip custom-block"><p class="custom-block-title">session同步：</p><ul><li>对个服务器之间同步session，这样可以保证每个服务器上都有全部的session信息，不过当服务器数量比较多的时候，同步是会有延迟甚至同步失败；</li><li>使用Nginx（或其他复杂均衡软硬件）中的ip绑定策略，同一个ip只能在指定的同一个机器访问，但是这样做风险也比较大，而且也是去了负载均衡的意义；</li><li>我们现在的系统会把session放到Redis中存储，虽然架构上变得复杂，并且需要多访问一次Redis，</li></ul></div><div class="tip custom-block"><p class="custom-block-title">但是这种方案带来的好处也是很大的：</p><ul><li>实现session共享，可以水平扩展（增加Redis服务器），</li><li>服务器重启session不丢失（不过也要注意session在Redis中的刷新/失效机制）</li><li>不仅可以跨服务器session共享，甚至可以跨平台（例如网页端和APP端）。</li></ul></div><h2 id="_42-cookies、sessionstorage、localstorage" tabindex="-1">42 cookies、sessionStorage、localStorage <a class="header-anchor" href="#_42-cookies、sessionstorage、localstorage" aria-hidden="true">#</a></h2><ol><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据，通常是经过加密的</li><li>cookie数据始终在同源的http请求中携带，即使不需要，也会在浏览器和服务器间来回传递</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</li><li>cookie数据大小不能超过4k</li><li>sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可达到5M或更大</li><li>localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li>sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie设置cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ol><h2 id="_43-http协议" tabindex="-1">43 HTTP协议 <a class="header-anchor" href="#_43-http协议" aria-hidden="true">#</a></h2><ol><li>http无连接：限制每次连接只处理一个请求，服务端完成客户端的请求后，即断开连接。</li><li>http无状态：对于事务处理没有记忆能力，每次请求都是独立的，不记录客户端任何行为。</li><li>客户端/服务端模型：客户端支持web浏览器或其他任何客户端。</li><li>简单快速</li><li>灵活：可以传输任何类型的数据。</li></ol><h2 id="_44-cookies-vs-session" tabindex="-1">44 cookies vs session <a class="header-anchor" href="#_44-cookies-vs-session" aria-hidden="true">#</a></h2><ol><li>cookie数据保存在客户端，session数据保存在服务端</li><li>cookies减轻服务器压力，但不安全，容易进行cookies欺骗</li><li>session安全一点，但是占用服务器资源</li></ol><h2 id="_45-get-vs-post" tabindex="-1">45 get vs post <a class="header-anchor" href="#_45-get-vs-post" aria-hidden="true">#</a></h2><ol><li>get产生一个tcp数据包，post产生两个tcp数据包</li><li>get方式请求，浏览器会把http header和data一并发出去，服务器响应200（返回数据）。</li><li>post请求，浏览器发送header，服务器响应100continue，浏览器再发送data，服务器响应200。</li></ol><h2 id="_46-http优化方案" tabindex="-1">46 HTTP优化方案 <a class="header-anchor" href="#_46-http优化方案" aria-hidden="true">#</a></h2><ol><li>TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理，前者是负载均衡设备的独特功能，而后者是HTTP1.1协议所支持的新功能，被大多数浏览器所支持。</li><li>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可直接在内存中获取相应的数据了。</li><li>压缩：将文本数据进行压缩，减少带宽</li><li>SSL加速：使用SSL协议对HTTP协议进行加密，在通道内加密并加速</li><li>TCP缓冲：通过采用TCP缓冲技术，可提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。</li></ol><h2 id="_47-doctype作用" tabindex="-1">47 DOCTYPE作用 <a class="header-anchor" href="#_47-doctype作用" aria-hidden="true">#</a></h2><ol><li>DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</li><li>标准模式的渲染方式和JS引擎的解析方式都以该浏览器支持的最高标准运行。</li><li>在兼容模式中，页面以宽松向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li></ol><h2 id="_48-dtd" tabindex="-1">48 DTD <a class="header-anchor" href="#_48-dtd" aria-hidden="true">#</a></h2><ol><li>DTD（Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义xml或html的特定版本中所有允许元素及它们的属性和层次关系定义。</li><li>在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。</li><li>DTD对HTML文档的声明，还会影响浏览器的渲染模式（工作模式）</li></ol><h2 id="_49-var、let、const之间的区别" tabindex="-1">49 var、let、const之间的区别 <a class="header-anchor" href="#_49-var、let、const之间的区别" aria-hidden="true">#</a></h2><ol><li>var声明变量可重复声明，而let不可以重复声明</li><li>var是不受限于块级的，let是受限于块级</li><li>var会与window相映射，而let不与window相映射</li><li>var可声明上面访问变量，let有暂存死区，在声明的上面访问变量会报错</li><li>const声明之后必须赋值，否则会报错</li><li>const定义不可变的量，改变了就会报错</li><li>const和let一样不会与window相映射、支持块级作用域，在声明的上面访问变量会报错</li></ol><h2 id="_50-ajax" tabindex="-1">50 ajax <a class="header-anchor" href="#_50-ajax" aria-hidden="true">#</a></h2><ol><li>优点 <ul><li>a. 无刷新更新数据</li><li>b. 异步与服务器通信</li><li>c. 前端和后端负载均衡</li><li>d. 界面和应用相分离</li></ul></li><li>缺点 <ul><li>a. ajax不支持浏览器back按钮</li><li>b. 安全问题，ajax暴漏了与服务器交互的细节</li><li>c. 对搜索引擎的支持比较弱</li><li>d. 破坏了back与history后退按钮的正常行为等浏览器机制</li></ul></li></ol><h2 id="_51-get-vs-post" tabindex="-1">51 get vs post <a class="header-anchor" href="#_51-get-vs-post" aria-hidden="true">#</a></h2><ol><li>get和post在http中代表着请求数据，其中get请求相对来说更简单快速，效率高些</li><li>get相对post安全性低</li><li>get有缓存，post没有</li><li>get体积小，post可无限大</li><li>get的url参数可见，post不可见</li><li>get只接受ascii字符的参数数据类型，post没有限制</li><li>get请求参数会保留历史记录，post中参数不会保留</li><li>get会被浏览器主动catch，post不会，需要手动设置</li><li>get在浏览器回退时无害，post会再次提交请求</li><li>post一般用于修改服务器上的资源，对所发送的信息没有限制</li></ol><ul><li>a. 无法使用缓存文件，更新服务器上的文件或数据库</li><li>b. 向服务器发送大量数据</li><li>c. 发送包含未知字符的用户输入时，post比get更稳定也可靠</li></ul><h2 id="_52-javascript-规范" tabindex="-1">52 JavaScript 规范 <a class="header-anchor" href="#_52-javascript-规范" aria-hidden="true">#</a></h2><ol><li>不要在同一行声明多个变量</li><li>请使用=== / !=== 来比较true/false或者数值</li><li>使用对象字面量替代new Array这种形式</li><li>不要使用全局变量</li><li>switch语句必须带有default分支</li><li>函数不应该有时候有返回值，有时候没有返回值</li><li>for循环必须使用大括号</li><li>if语句必须使用大括号</li><li>for-in循环中的变量应该使用var关键字明确限定作用域</li></ol></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-17T09:06:03.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>