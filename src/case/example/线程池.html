<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>线程池</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_case_example_线程池.md.e4225766.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#_01-线程池参数" data-v-2d325df8>01 线程池参数</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-线程池的运行原理运行原理" data-v-2d325df8>02 线程池的运行原理运行原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-线程池中线程实现复用的原理" data-v-2d325df8>03 线程池中线程实现复用的原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-线程是如何获取任务以及如何实现超时的" data-v-2d325df8>04 线程是如何获取任务以及如何实现超时的</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_05-线程池的5种状态" data-v-2d325df8>05 线程池的5种状态</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-线程池的关闭" data-v-2d325df8>06 线程池的关闭</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-线程池的监控" data-v-2d325df8>07 线程池的监控</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-executors构建线程池以及问题分析" data-v-2d325df8>08 Executors构建线程池以及问题分析</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-线程池的使用场景" data-v-2d325df8>09 线程池的使用场景</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-实际项目中如何合理的自定义线程池" data-v-2d325df8>10 实际项目中如何合理的自定义线程池</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-线程池定义" data-v-2d325df8>11 线程池定义</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-线程池作用" data-v-2d325df8>12 线程池作用</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-创建线程池" data-v-2d325df8>13 创建线程池</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-选用哪种线程池" data-v-2d325df8>14 选用哪种线程池</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-如何定义线程池大小" data-v-2d325df8>15 如何定义线程池大小</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-线程池应用场景" data-v-2d325df8>16 线程池应用场景</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#参考" data-v-2d325df8>参考</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_case_example_%E7%BA%BF%E7%A8%8B%E6%B1%A0" data-v-3886f8ec><div><h1 id="线程池" tabindex="-1">线程池 <a class="header-anchor" href="#线程池" aria-hidden="true">#</a></h1><h2 id="_01-线程池参数" tabindex="-1">01 线程池参数 <a class="header-anchor" href="#_01-线程池参数" aria-hidden="true">#</a></h2><div class="language-java"><span class="copy"></span><pre><code><span class="line"></span>
<span class="line"><span style="color:#8B949E;">// corePoolSize：线程池中用来工作的核心的线程数量。</span></span>
<span class="line"><span style="color:#8B949E;">// maximumPoolSize：最大线程数，线程池允许创建的最大线程数。</span></span>
<span class="line"><span style="color:#8B949E;">// keepAliveTime：超出corePoolSize后创建的线程存活时间或者是所有线程最大存活时间，取决于配置。</span></span>
<span class="line"><span style="color:#8B949E;">// unit：keepAliveTime的时间单位。</span></span>
<span class="line"><span style="color:#8B949E;">// workQueue：任务队列，是一个阻塞队列，当线程数已达到核心线程数，会将任务存储在阻塞队列中。</span></span>
<span class="line"><span style="color:#8B949E;">// threadFactory：线程池内部创建线程所用的工厂。</span></span>
<span class="line"><span style="color:#8B949E;">// handler：拒绝策略，当队列已满并且线程数量达到最大线程数量时，会调用该方法处理该任务。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">class</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">TestThreadPool</span><span style="color:#C9D1D9;"> {</span></span>
<span class="line"><span style="color:#C9D1D9;">	</span><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">static</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">void</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">main</span><span style="color:#C9D1D9;">(</span><span style="color:#FF7B72;">String</span><span style="color:#C9D1D9;">[] </span><span style="color:#FFA657;">args</span><span style="color:#C9D1D9;">) </span><span style="color:#FF7B72;">throws</span><span style="color:#C9D1D9;"> ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#C9D1D9;">		CopyOnWriteArrayList</span><span style="color:#FFA657;">&lt;</span><span style="color:#FF7B72;">Future</span><span style="color:#FFA657;">&gt; </span><span style="color:#C9D1D9;">retList</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">new</span><span style="color:#C9D1D9;"> CopyOnWriteArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#C9D1D9;">		List</span><span style="color:#FFA657;">&lt;</span><span style="color:#FF7B72;">Task</span><span style="color:#FFA657;">&gt; </span><span style="color:#C9D1D9;">taskList</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">new</span><span style="color:#C9D1D9;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#C9D1D9;">		</span><span style="color:#FF7B72;">for</span><span style="color:#C9D1D9;"> (</span><span style="color:#FF7B72;">int</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">i</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">0</span><span style="color:#C9D1D9;">; i </span><span style="color:#FF7B72;">&lt;</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">100000</span><span style="color:#C9D1D9;">; i</span><span style="color:#FF7B72;">++</span><span style="color:#C9D1D9;">) {</span></span>
<span class="line"><span style="color:#C9D1D9;">			taskList.</span><span style="color:#D2A8FF;">add</span><span style="color:#C9D1D9;">(</span><span style="color:#FF7B72;">new</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">Task</span><span style="color:#C9D1D9;">(i));</span></span>
<span class="line"><span style="color:#C9D1D9;">		}</span></span>
<span class="line"><span style="color:#C9D1D9;">		ExecutorService</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">threadPool</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">new</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">ThreadPoolExecutor</span><span style="color:#C9D1D9;">(</span></span>
<span class="line"><span style="color:#C9D1D9;">            	</span><span style="color:#79C0FF;">1</span><span style="color:#C9D1D9;">,</span><span style="color:#8B949E;">//核心的线程数量</span></span>
<span class="line"><span style="color:#C9D1D9;">				</span><span style="color:#79C0FF;">3</span><span style="color:#C9D1D9;">,</span><span style="color:#8B949E;">//最大的线程数量</span></span>
<span class="line"><span style="color:#C9D1D9;">				</span><span style="color:#79C0FF;">10</span><span style="color:#C9D1D9;">,</span><span style="color:#8B949E;">//等待一定事件后关闭最大线程</span></span>
<span class="line"><span style="color:#C9D1D9;">				TimeUnit.MILLISECONDS,</span><span style="color:#8B949E;">//等待时间的单位</span></span>
<span class="line"><span style="color:#C9D1D9;">				</span><span style="color:#FF7B72;">new</span><span style="color:#C9D1D9;"> LinkedBlockingQueue&lt;&gt;(</span><span style="color:#79C0FF;">10</span><span style="color:#C9D1D9;">),</span><span style="color:#8B949E;">//创建一个队列</span></span>
<span class="line"><span style="color:#C9D1D9;">				Executors.</span><span style="color:#D2A8FF;">defaultThreadFactory</span><span style="color:#C9D1D9;">(),</span><span style="color:#8B949E;">//创建线程的线程工厂</span></span>
<span class="line"><span style="color:#C9D1D9;">				</span><span style="color:#FF7B72;">new</span><span style="color:#C9D1D9;"> ThreadPoolExecutor.</span><span style="color:#D2A8FF;">CallerRunsPolicy</span><span style="color:#C9D1D9;">());</span><span style="color:#8B949E;">// 拒绝策略</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">		</span><span style="color:#FF7B72;">for</span><span style="color:#C9D1D9;"> (</span><span style="color:#FF7B72;">int</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">i</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">0</span><span style="color:#C9D1D9;">; i </span><span style="color:#FF7B72;">&lt;</span><span style="color:#C9D1D9;"> taskList.</span><span style="color:#D2A8FF;">size</span><span style="color:#C9D1D9;">(); i</span><span style="color:#FF7B72;">++</span><span style="color:#C9D1D9;">) {</span></span>
<span class="line"><span style="color:#C9D1D9;">			threadPool.</span><span style="color:#D2A8FF;">submit</span><span style="color:#C9D1D9;">(taskList.</span><span style="color:#D2A8FF;">get</span><span style="color:#C9D1D9;">(i));</span></span>
<span class="line"><span style="color:#C9D1D9;">		}</span></span>
<span class="line"><span style="color:#C9D1D9;">	}</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF7B72;">class</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">Task</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">implements</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">Callable</span><span style="color:#C9D1D9;">&lt;</span><span style="color:#FF7B72;">Integer</span><span style="color:#C9D1D9;">&gt; {</span></span>
<span class="line"><span style="color:#C9D1D9;">	</span><span style="color:#FF7B72;">private</span><span style="color:#C9D1D9;"> Integer</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">num;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">	</span><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">Task</span><span style="color:#C9D1D9;">(Integer </span><span style="color:#FFA657;">num</span><span style="color:#C9D1D9;">) {</span></span>
<span class="line"><span style="color:#C9D1D9;">		</span><span style="color:#79C0FF;">this</span><span style="color:#C9D1D9;">.num </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> num;</span></span>
<span class="line"><span style="color:#C9D1D9;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">	@</span><span style="color:#FF7B72;">Override</span></span>
<span class="line"><span style="color:#C9D1D9;">	</span><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> Integer </span><span style="color:#D2A8FF;">call</span><span style="color:#C9D1D9;">() </span><span style="color:#FF7B72;">throws</span><span style="color:#C9D1D9;"> Exception {</span></span>
<span class="line"><span style="color:#C9D1D9;">		System.out.</span><span style="color:#D2A8FF;">println</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;---uuu--&quot;</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">+</span><span style="color:#C9D1D9;"> num);</span></span>
<span class="line"><span style="color:#C9D1D9;">		</span><span style="color:#FF7B72;">return</span><span style="color:#C9D1D9;"> num;</span></span>
<span class="line"><span style="color:#C9D1D9;">	}</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="_02-线程池的运行原理运行原理" tabindex="-1">02 线程池的运行原理运行原理 <a class="header-anchor" href="#_02-线程池的运行原理运行原理" aria-hidden="true">#</a></h2><ol><li>刚创建出来的线程池中只有一个构造时传入的阻塞队列，此时里面并没有任何线程，</li><li>但是如果你想要在执行之前已经创建好核心线程数，可调用prestartAllCoreThreads方法来实现，默认是没有线程的。</li><li>提交任务的时候，其实会去进行任务的处理</li><li>首先会去判断当前线程池的线程数是否小于核心线程数，也就是线程池构造时传入的参数corePoolSize。</li></ol><ul><li>如果小于，那么就直接通过ThreadFactory创建一个线程来执行这个任务。</li><li>当任务执行完之后，线程不会退出，而是会去阻塞队列中获取任务。</li><li>接下来，如果又提交了一个任务，也会按照上述的步骤，去判断是否小于核心线程数，</li><li>如果小于，还是会创建线程来执行任务，执行完之后也会从阻塞队列中获取任务。</li><li>这里有个细节，就是提交任务的时候，就算有线程池里的线程从阻塞队列中获取不到任务，</li><li>如果线程池里的线程数还是小于核心线程数，那么依然会继续创建线程，而不是复用已有的线程。</li></ul><div class="tip custom-block"><p class="custom-block-title">如果线程池里的线程数不再小于核心线程数？</p><ol><li>那么此时就会尝试将任务放入阻塞队列中，入队成功之后，这样在阻塞的线程就是可以获取到任务了。</li><li>但是，<strong>随着任务越来越多，队列已经满了，任务放入失败了，那怎么办？</strong></li></ol><ul><li>如果小于最大线程数，那么也会创建非核心线程来执行提交的任务。</li><li>所以，就算队列中有任务，新创建的线程还是优先处理这个提交的任务，而不是从队列中获取已有的任务执行，</li><li>从这里可以看出，先提交的任务不一定先执行。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">线程数已经达到了最大线程数量，那么此时会怎么办？</p><ol><li>此时就会执行拒绝策略，也就是构造线程池的时候，传入的RejectedExecutionHandler对象，来处理这个任务。</li><li>RejectedExecutionHandler的实现JDK自带的默认有4种</li></ol><ul><li>AbortPolicy：丢弃任务，抛出运行时异常。</li><li>CallerRunsPolicy：由提交任务的线程来执行任务。</li><li>DiscardPolicy：丢弃这个任务，但是不抛出异常。</li><li>DiscardOldestPolicy：从队列中剔除最先进入队列的任务，然后再次提交任务。</li></ul><ol start="3"><li>线程池创建的时候，如果不指定拒绝策略就默认是AbortPolicy策略，</li><li>当然，你也可以自己实现RejectedExecutionHandler接口，比如将任务存在数据库或者缓存中，</li><li>这样数据库或缓存中获取到被拒绝掉的任务了。</li><li>keepAliveTime和unit（unit是keepAliveTime的时间单位）</li></ol></div><h2 id="_03-线程池中线程实现复用的原理" tabindex="-1">03 线程池中线程实现复用的原理 <a class="header-anchor" href="#_03-线程池中线程实现复用的原理" aria-hidden="true">#</a></h2><ul><li>线程在线程池内部其实被封装成了一个Worker对象。</li><li>Worker继承了AQS，也就是有一定锁的特性。</li><li>创建线程来执行任务的方法上面提到是通过addWorker方法创建的，</li><li>在创建Worker对象的时候，会把线程和任务一起封装到Worker内部，</li><li>然后调用runWorker方法来让线程执行任务，接下来我们就来看一下runWorker方法</li><li>runWorker内部使用了while死循环，当第一个任务执行完之后，会不断地通过getTask方法获取任务，</li><li>只要能获取到任务，就会调用run方法，继续执行任务，这就是线程能够复用的主要原因。</li><li>但是如果从getTask获取不到方法的时候，</li><li>最后就会调用finally中的processWorkerExit方法，来将线程退出。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>因为Worker继承了AQS，每次在执行任务之前都会调用Worker的lock方法，执行完成任务之后， 会调用unlock方法，这样做的目的就可以通过Worker的加锁状态判断出当前线程是否正在运行任务，</p><ul><li>如果想知道线程是否正在运行任务，只需要调用Worker的tryLock方法，根据是否加锁成功就能判断， 加锁成功说明当前线程没有加锁，</li><li>也就没有执行任务了，在调用shutdown方法关闭线程池的时候， 就用这种方式来判断线程有没有在执行任务，</li><li>如果没有的话，来尝试打断没有执行任务的线程。</li></ul></div><h2 id="_04-线程是如何获取任务以及如何实现超时的" tabindex="-1">04 线程是如何获取任务以及如何实现超时的 <a class="header-anchor" href="#_04-线程是如何获取任务以及如何实现超时的" aria-hidden="true">#</a></h2><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#8B949E;">// getTask方法，前面就是线程池的一些状态的判断</span></span>
<span class="line"><span style="color:#FF7B72;">boolean</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">timed</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> allowCoreThreadTimeOut </span><span style="color:#FF7B72;">||</span><span style="color:#C9D1D9;"> wc </span><span style="color:#FF7B72;">&gt;</span><span style="color:#C9D1D9;"> corePoolSize;</span></span>
<span class="line"></span></code></pre></div><blockquote><p>这行代码是判断，当前过来获取任务的线程是否可以超时退出， 如果allowCoreThreadTimeOut设置为true或者线程池当前的线程数大于核心线程数， 也就是corePoolSize，那么该获取任务的线程就可以超时退出。</p></blockquote><div class="tip custom-block"><p class="custom-block-title">那是怎么做到超时退出的，就是这行核心代码</p><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#C9D1D9;">Runnable</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">r</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> timed </span><span style="color:#FF7B72;">?</span></span>
<span class="line"><span style="color:#C9D1D9;">    workQueue.</span><span style="color:#D2A8FF;">poll</span><span style="color:#C9D1D9;">(keepAliveTime, TimeUnit.NANOSECONDS) </span><span style="color:#FF7B72;">:</span></span>
<span class="line"><span style="color:#C9D1D9;">    workQueue.</span><span style="color:#D2A8FF;">take</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"></span></code></pre></div><p>根据是否允许超时来选择调用阻塞队列workQueue的poll方法或者take方法。 如果允许超时，则会调用poll方法，传入keepAliveTime，也就是构造线程池传入的空闲时间， 这个方法的意思就是从队列中阻塞keepAliveTime，也就是构造线程池时传入的空闲时间， 这个方法的意思就是从队列中阻塞keepAliveTime时间来获取任务，获取不到就会返回null； 如果不允许超时，就会调用take方法，这个方法会一直阻塞获取任务，直到从队列中获取到任务位置。</p></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>这里有一个细节，就是判断当前获取任务的线程 ”是否可以超时退出“ 的时候， 将allowCoreThreadTimeOut设置为true，那么所有线程走到这个timed都是true， 那么所有的线程，包括核心线程都可以做到超时退出。 如果你的线程池需要将核心线程超时退出， 那么可以通过allowCoreThreadTimeOut方法将allowCoreThreadTimOut变量设置为true。</p></div><h2 id="_05-线程池的5种状态" tabindex="-1">05 线程池的5种状态 <a class="header-anchor" href="#_05-线程池的5种状态" aria-hidden="true">#</a></h2><ul><li>RUNNING 线程池创建时就是这个状态，能够接收新任务，以及对已添加的任务进行处理。</li><li>SHUTDOWN 调用shutdown方法线程池就会转换成SHUTDOWN状态，此时线程池不再接收新任务，但能继续处理已添加的任务到队列中任务。</li><li>STOP 调用shutdownNow方法线程池就会转换成STOP状态，不接收新任务，也不能继续处理已添加的任务到队列中，并且会尝试中断正在处理的任务的线程。</li><li>TIDYING <ul><li>SHUTDOWN状态下，任务数为0，其他所有任务已终止，线程池会变为TIDYING状态。</li><li>线程池在SHUTDOWN状态，任务队列为空且执行中任务为空，线程池会变为TIDYING状态。</li><li>线程池在STOP状态，线程池中执行任务为空时，线程池会变为TIDYING状态。</li></ul></li><li>TERMINATED 线程池彻底终止，线程池在TIDYING状态执行完terminated()方法就会转变为TERMINATED状态。</li></ul><blockquote><p>在线程池运行过程中，绝大多数操作执行前都得判断当前线程池处于哪种状态，再来决定是否继续执行该操作。</p></blockquote><h2 id="_06-线程池的关闭" tabindex="-1">06 线程池的关闭 <a class="header-anchor" href="#_06-线程池的关闭" aria-hidden="true">#</a></h2><ol><li>线程池提供了shutdown和shutdownNow两个方法来关闭线程池。</li><li>将线程池的状态修改为SHUTDOWN，然后尝试打断空闲的线程，也就是在阻塞等待任务的线程。</li><li>将线程池的状态修改为STOP，然后尝试打断所有的线程，从阻塞队列中移除剩余的任务，</li><li>这也是为什么shutdownNow不能执行剩余任务的原因。</li></ol><div class="warning custom-block"><p class="custom-block-title">区别</p><p>shutdown之后还能处理队列中的任务，shutdownNow直接就将任务从队列中移除，线程池里的线程就不再处理了。</p></div><h2 id="_07-线程池的监控" tabindex="-1">07 线程池的监控 <a class="header-anchor" href="#_07-线程池的监控" aria-hidden="true">#</a></h2><p>在项目中使用线程池的时候，一般需要对线程池进行监控，方便出问题的时候进行查看，线程池本身提供了一些方法来获取线程池的运行状态。</p><ul><li>getCompletedTaskCount：已经执行完成的任务数量</li><li>getLargestPoolSize：线程池里曾经创建过的最大的线程数量，这个主要是用来判断线程是否满过。</li><li>getActiveCount：获取正在执行任务的线程数据</li><li>getPoolSize：获取当前线程池中线程数量的大小</li></ul><h2 id="_08-executors构建线程池以及问题分析" tabindex="-1">08 Executors构建线程池以及问题分析 <a class="header-anchor" href="#_08-executors构建线程池以及问题分析" aria-hidden="true">#</a></h2><ul><li>JDK内部提供了Executors这个工具类，来快速的创建线程池。</li><li>不建议使用，如newFixedThreadPool线程池，使用了LinkedBlockingQueue，队列的容量默认是无限大，实际使用中出现任务过多时会导致内存溢出。</li><li>newCachedThreadPool线程池由于核心线程数无限大，当任务过多的时候，会创建大量的线程，可能机器负载过高，可能会导致服务宕机。</li></ul><h2 id="_09-线程池的使用场景" tabindex="-1">09 线程池的使用场景 <a class="header-anchor" href="#_09-线程池的使用场景" aria-hidden="true">#</a></h2><p>适合需要异步或多线程处理任务的场景。</p><h2 id="_10-实际项目中如何合理的自定义线程池" tabindex="-1">10 实际项目中如何合理的自定义线程池 <a class="header-anchor" href="#_10-实际项目中如何合理的自定义线程池" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">线程数</p><p>线程数的设置主要取决于业务是IO密集型还是CPU密集型 CPU密集型指的是任务主要使用来进行大量的计算，没有什么导致线程阻塞，一般这种场景的线程数设置为CPU核心数+1。</p><ul><li>IO密集型：当执行任务需要大量的io，比如磁盘io，网络io，可能会存在大量的阻塞，</li><li>所以在IO密集型任务中使用多线程可大大地加速任务的处理，一般线程数设置为2*CPU核心数</li></ul><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#8B949E;">// java中用来获取CPU核心数的方法是</span></span>
<span class="line"><span style="color:#C9D1D9;">Runtime.</span><span style="color:#D2A8FF;">getRuntime</span><span style="color:#C9D1D9;">().</span><span style="color:#D2A8FF;">availableProcessors</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"></span></code></pre></div></div><div class="tip custom-block"><p class="custom-block-title">线程工厂</p><p>一般建议自定义线程工厂，构建线程的时候设置线程的名称，这样就在查日志的时候方便知道是哪个线程执行的代码。</p></div><div class="tip custom-block"><p class="custom-block-title">有界队列</p><p>一般需要设置有界队列的大小，比如LinkedBlockingQueue在构造的时候就可以传入参数，来限制队列中任务数据大小，这样就不会因为无限往队列中仍任务导致系统的oom。</p></div><h2 id="_11-线程池定义" tabindex="-1">11 线程池定义 <a class="header-anchor" href="#_11-线程池定义" aria-hidden="true">#</a></h2><p>线程池意味着可以存储线程，并让池内的线程得以复用，如果池内的某一个线程执行完了，并不会直接销毁，它有生命周期，可以存活一些时间，待到下一个任务来时，它会复用这个在等待中的线程，避免了再去创建线程增加的额外系统开销。</p><h2 id="_12-线程池作用" tabindex="-1">12 线程池作用 <a class="header-anchor" href="#_12-线程池作用" aria-hidden="true">#</a></h2><ol><li>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长，这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源时间，可能导致系统资源不足。</li><li>线程池作用就是限制系统中执行线程的数量。</li></ol><ul><li>提高效率，创建号一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比创建一个线程对象要快的多。</li><li>方便管理，可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时就有该程序创建100个线程，每当有请求的时候，就分配一个线程去动作，如果刚好并发有101个请求，那么多出的这个一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</li></ul><h2 id="_13-创建线程池" tabindex="-1">13 创建线程池 <a class="header-anchor" href="#_13-创建线程池" aria-hidden="true">#</a></h2><ol><li>通过Executors工具类提供的不同静态方法创建线程池</li></ol><div class="language-text"><span class="copy"></span><pre><code><span class="line"><span style="color:#c9d1d9;">Executors.newSingleThreadExecutor()</span></span>
<span class="line"><span style="color:#c9d1d9;">创建一个单线程的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO、LIFO、优先级）执行。</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span>
<span class="line"><span style="color:#c9d1d9;">Executors.newFixedThreadPool()</span></span>
<span class="line"><span style="color:#c9d1d9;">创建一个固定大小的线程池，可控制线程最大并发数，超过的任务会在队列（无界队列）中等待。</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span>
<span class="line"><span style="color:#c9d1d9;">Executors.newCachedThreadPool()</span></span>
<span class="line"><span style="color:#c9d1d9;">创建一个可缓存的线程池，如果线程长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。使用时一定要控制任务的数量，否则，由于大量线程同时运行，很有可能会造成系统瘫痪。</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span>
<span class="line"><span style="color:#c9d1d9;">Executors.newScheduledThreadPool()</span></span>
<span class="line"><span style="color:#c9d1d9;">创建一个可以执行延迟任务的线程池。</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span>
<span class="line"><span style="color:#c9d1d9;">Executors.newWorkStealingPool()</span></span>
<span class="line"><span style="color:#c9d1d9;">创建一个抢占式执行的线程池（任务执行顺序不确定），这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">通过ThreadPoolExecutor创建线程池</p><p>最原始的创建线程池的方式，它包含了7个参数可供设置，如下所示：</p><div class="language-text"><span class="copy"></span><pre><code><span class="line"><span style="color:#c9d1d9;">new ThreadPoolExecutor(</span></span>
<span class="line"><span style="color:#c9d1d9;">   int corePoolSize, </span></span>
<span class="line"><span style="color:#c9d1d9;">   int maximumPoolSize, </span></span>
<span class="line"><span style="color:#c9d1d9;">   long keepAliveTime,</span></span>
<span class="line"><span style="color:#c9d1d9;">   TimeUnit unit,</span></span>
<span class="line"><span style="color:#c9d1d9;">   BlockingQueue&lt;Runnable&gt; workQueue, </span></span>
<span class="line"><span style="color:#c9d1d9;">   ThreadFactory threadFactory,</span></span>
<span class="line"><span style="color:#c9d1d9;">   RejectedExecutionHandler handler)</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span></code></pre></div><ul><li>corePoolSize：线程池中的核心线程数量，这几个核心线程，在没有用的时候，也不会被回收。</li><li>maximumPoolSize：线程池中可以容纳的最大线程的数量</li><li>keepAliveTime：线程池中非核心线程最长可以存活的时间，在线程池中，核心线程即使在无任务的情况下也不能被清除，其余的线程都是由存活时间的。</li><li>unit：存活的时间单位</li><li>workQueue：等待队列，任务可以存储在任务队列中等待被执行，执行的是FIFO原则（先进先出）</li><li>threadFactory：创建线程的线程工厂，JDK提供默认的Executors.defaultThreadFactory()。</li><li>handler：是一种拒绝策略，我们可以在任务满之后，拒绝执行某些任务。</li></ul></div><ul><li>拒绝策略 <ul><li>AbortPolicy：该策略是线程池的默认策略，拒绝并抛出异常，使用该策略时，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。</li><li>CallerRunsPolicy：使用此策略，如果添加到线程池失败，那么主线程会自己去执行该任务，不会等待线程池中的其它线程去执行。</li><li>DiscardPolicy：使用这个策略时，如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常。</li><li>DiscardOldestPolicy：这个策略从字面上很好理解，丢弃最老的，也就是说如果队列满了，会将最早进入队列的任务删除掉腾出空间，再尝试加入队列，因为队列是队尾进，队头出，所以队头元素是最老的，因此每次都是移除队头元素后再尝试入队。</li><li>自定义拒绝策略：如果以上策略都不符合业务场景，那么可以自定义一个拒绝策略，只要实现RejectedExecutionHandler接口，并且实现rejectedExecution方法就可以了，具体的逻辑就在rejectedExecution方法里去定义就OK了。</li></ul></li></ul><h2 id="_14-选用哪种线程池" tabindex="-1">14 选用哪种线程池 <a class="header-anchor" href="#_14-选用哪种线程池" aria-hidden="true">#</a></h2><div class="language-text"><span class="copy"></span><pre><code><span class="line"><span style="color:#c9d1d9;">阿里巴巴《Java开发手册》</span></span>
<span class="line"><span style="color:#c9d1d9;">【强制】线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险。</span></span>
<span class="line"><span style="color:#c9d1d9;">说明：Executors 返回的线程池对象的弊端如下：</span></span>
<span class="line"><span style="color:#c9d1d9;">1. FixedThreadPool 和 SingleThreadPool ：允许的请求队列长度为：Integer.MAX_VALUE，可能会增加大量的请求，我们知道每个线程默认情况下占1M的内存空间，如果线程非常多，内存资源将会被耗尽，导致OOM。</span></span>
<span class="line"><span style="color:#c9d1d9;">2. CachedThreadPool：允许创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，我们知道每个线程默认情况下占1M的内存空间，如果线程非常多，内存资源将会被耗尽，导致OOM.</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span></code></pre></div><h2 id="_15-如何定义线程池大小" tabindex="-1">15 如何定义线程池大小 <a class="header-anchor" href="#_15-如何定义线程池大小" aria-hidden="true">#</a></h2><p>获取CPU核数N = Runtime.getRuntime().availableProcessors();</p><div class="tip custom-block"><p class="custom-block-title">经验值</p><ul><li>IO密集型 <ul><li>大部分时间在进行IO操作，CPU占用率不高，例如：mysql数据库，文件的读写，网络通信等，这类操作不会消耗太多CPU资源</li><li>建议：线程池大小 = 2N + 1</li></ul></li><li>CPU密集型 计算密集型 线程池大小 = N + 1</li></ul></div><ol><li>最佳计算公式 最佳线程数 = （（线程等待时间 + 线程CPU时间）/ 线程CPU时间 ）* CPU数目</li><li>线程等待时间所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越小线程。</li><li>一般用经验值就差不多，再配合系统压测，基本可以确定最适合的线程数。</li></ol><h2 id="_16-线程池应用场景" tabindex="-1">16 线程池应用场景 <a class="header-anchor" href="#_16-线程池应用场景" aria-hidden="true">#</a></h2><ol><li>异步处理（高并发下不合适，采用mq代替）</li><li>并行处理（建议使用CompletetableFuture）</li></ol><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-hidden="true">#</a></h2><p><a href="https://mp.weixin.qq.com/s/ndBdf7InQPZq40uoqBUTSw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/ndBdf7InQPZq40uoqBUTSw</a></p></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-17T06:29:02.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>