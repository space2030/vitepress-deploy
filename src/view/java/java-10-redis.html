<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>redis</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_view_java_java-10-redis.md.07f078ba.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#_01-定义" data-v-2d325df8>01 定义</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-持久化机制" data-v-2d325df8>02 持久化机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-性能问题" data-v-2d325df8>03 性能问题</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-删除策略" data-v-2d325df8>04 删除策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_05-淘汰策略" data-v-2d325df8>05 淘汰策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-同步机制" data-v-2d325df8>06 同步机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-redis-vs-memcache" data-v-2d325df8>07 Redis VS Memcache</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-缓存问题" data-v-2d325df8>08 缓存问题</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-数据类型" data-v-2d325df8>09 数据类型</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-事务" data-v-2d325df8>10 事务</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-内存优化" data-v-2d325df8>11 内存优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-哨兵机制和集群模式" data-v-2d325df8>12 哨兵机制和集群模式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-redis-模式" data-v-2d325df8>13 Redis 模式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-性能优化" data-v-2d325df8>14 性能优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-为什么要用缓存" data-v-2d325df8>15 为什么要用缓存</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-使用-redis-单线程模型效率也能那么高" data-v-2d325df8>16 使用 Redis 单线程模型效率也能那么高</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_17-redis-线程模型" data-v-2d325df8>17 Redis 线程模型</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_18-为什么-redis-需要把所有数据放到内存中" data-v-2d325df8>18 为什么 Redis 需要把所有数据放到内存中</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_19-redis-同步机制" data-v-2d325df8>19 Redis 同步机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_20-pipeline" data-v-2d325df8>20 pipeline</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_21-redis-优点和缺点" data-v-2d325df8>21 Redis 优点和缺点</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_23-redis-缓存刷新策略" data-v-2d325df8>23 Redis 缓存刷新策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_24-redis-持久化" data-v-2d325df8>24 Redis 持久化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_25-持久化机制怎么选择" data-v-2d325df8>25 持久化机制怎么选择</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_26-redis-实现消息队列" data-v-2d325df8>26 Redis 实现消息队列</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_27-redis-事务" data-v-2d325df8>27 Redis 事务</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_28-redis-事务注意点" data-v-2d325df8>28 Redis 事务注意点</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_29-redis-事务为什么不支持回滚" data-v-2d325df8>29 Redis 事务为什么不支持回滚</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_30-redis-为什么设计成单线程" data-v-2d325df8>30 Redis 为什么设计成单线程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_31-bigkey" data-v-2d325df8>31 bigkey</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_32-redis-集群模式" data-v-2d325df8>32 Redis 集群模式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_33-redis-cluster-集群" data-v-2d325df8>33 Redis Cluster 集群</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_34-redis-常见的性能问题和解决方案" data-v-2d325df8>34 Redis 常见的性能问题和解决方案</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_35-keys-vs-scan" data-v-2d325df8>35 keys vs scan</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_36-大量的-key-同一时间过期" data-v-2d325df8>36 大量的 key 同一时间过期</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_37-redis-阻塞" data-v-2d325df8>37 Redis 阻塞</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_38-redis-分布式锁" data-v-2d325df8>38 Redis 分布式锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_39-redis-memcache" data-v-2d325df8>39 redis memcache</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_40-redis-持久化" data-v-2d325df8>40 redis 持久化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_41-redis-性能问题" data-v-2d325df8>41 redis 性能问题</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_42-redis-删除策略" data-v-2d325df8>42 redis 删除策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_43-redis-淘汰策略" data-v-2d325df8>43 redis 淘汰策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_44-redis-同步机制" data-v-2d325df8>44 redis 同步机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_45-redis-哈希槽" data-v-2d325df8>45 redis 哈希槽</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_46-redis-事务相关命令" data-v-2d325df8>46 redis 事务相关命令</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_47-redis-内存优化" data-v-2d325df8>47 redis 内存优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_48-redis-热点数据" data-v-2d325df8>48 redis 热点数据</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_49-redis-keys-指令" data-v-2d325df8>49 redis keys 指令</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_50-redis-实现异步队列" data-v-2d325df8>50 redis 实现异步队列</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_51-redis-持久化机制" data-v-2d325df8>51 redis 持久化机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_52-redis-性能问题" data-v-2d325df8>52 redis 性能问题</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_53-redis-过期键的删除策略" data-v-2d325df8>53 redis 过期键的删除策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_54-redis-淘汰策略" data-v-2d325df8>54 redis 淘汰策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_55-redis-同步机制" data-v-2d325df8>55 redis 同步机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_56-redis-定义" data-v-2d325df8>56 redis 定义</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_57-redis-缺点" data-v-2d325df8>57 redis 缺点</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_58-redis-单线程高并发" data-v-2d325df8>58 redis 单线程高并发</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_59-为什么要用redis而不是map或者guava做缓存" data-v-2d325df8>59 为什么要用redis而不是map或者guava做缓存</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_60-redis-数据结构-string-与-hash-的区别" data-v-2d325df8>60 redis 数据结构 string 与 hash 的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_61-跳跃表" data-v-2d325df8>61 跳跃表</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_62-redis-持久化机制" data-v-2d325df8>62 redis 持久化机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_63-如何选择合适的持久化方式" data-v-2d325df8>63 如何选择合适的持久化方式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_64-过期键的删除策略" data-v-2d325df8>64 过期键的删除策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_65-redis设置键的过期时间以及永不过期命令是什么" data-v-2d325df8>65 redis设置键的过期时间以及永不过期命令是什么</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_66-redis的内存淘汰策略有哪些" data-v-2d325df8>66 redis的内存淘汰策略有哪些</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_67-redis-线程模型" data-v-2d325df8>67 redis 线程模型</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_68-redis-主从复制" data-v-2d325df8>68 redis 主从复制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_69-redis-哨兵机制" data-v-2d325df8>69 redis 哨兵机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_70-redis-的-key-是如何寻址的及一致性-hash-算法吗" data-v-2d325df8>70 redis 的 key 是如何寻址的及一致性 hash 算法吗</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_71-一致性hash" data-v-2d325df8>71 一致性hash</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_72-redlock" data-v-2d325df8>72 RedLock</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_73-jedis与redisson对比有什么优缺点" data-v-2d325df8>73 Jedis与redisson对比有什么优缺点</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_74-redis事务" data-v-2d325df8>74 redis事务</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_75-redis与memcached的区别" data-v-2d325df8>75 redis与memcached的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_76-redis常见的性能问题与对应的解决方案" data-v-2d325df8>76 redis常见的性能问题与对应的解决方案</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_77-假如redis有一亿个key，其中10万个key以某个固定的已知前缀开头，如何把他们都找出来" data-v-2d325df8>77 假如redis有一亿个key，其中10万个key以某个固定的已知前缀开头，如何把他们都找出来</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_78-布隆过滤器" data-v-2d325df8>78 布隆过滤器</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_79-redis-分布式锁实现原理" data-v-2d325df8>79 redis 分布式锁实现原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_80-redis-针对数据结构做了哪些优化" data-v-2d325df8>80 redis 针对数据结构做了哪些优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_81-redis-原子性" data-v-2d325df8>81 redis 原子性</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_82-什么命令会触发写rdb文件" data-v-2d325df8>82 什么命令会触发写RDB文件</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_83-大key问题" data-v-2d325df8>83 大Key问题</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_84-redis4-0之前的大key的发现与删除方法" data-v-2d325df8>84 redis4.0之前的大key的发现与删除方法</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_85-redis-优势" data-v-2d325df8>85 redis 优势</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_86-redis-集群方案" data-v-2d325df8>86 redis 集群方案</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_87-redis-分区" data-v-2d325df8>87 redis 分区</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_88-redis的内存占用情况" data-v-2d325df8>88 redis的内存占用情况</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_89-memcached服务特点及工作原理" data-v-2d325df8>89 Memcached服务特点及工作原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_90-session共享存储" data-v-2d325df8>90 session共享存储</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_91-memcached与redis区别" data-v-2d325df8>91 memcached与redis区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_92-redis-优缺点" data-v-2d325df8>92 redis 优缺点</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_93-redis相比memcached优势" data-v-2d325df8>93 redis相比Memcached优势</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_94-redis-淘汰策略" data-v-2d325df8>94 redis 淘汰策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_95-一个字符串类型的值能存储最大容量" data-v-2d325df8>95 一个字符串类型的值能存储最大容量</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_96-为什么redis需要把所有数据放到内存中" data-v-2d325df8>96 为什么redis需要把所有数据放到内存中</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_97-redis集群方案怎么做" data-v-2d325df8>97 redis集群方案怎么做</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_98-redis集群方案什么情况下导致整个集群不可用" data-v-2d325df8>98 redis集群方案什么情况下导致整个集群不可用</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_99-如何保证redis中的数据都是热数据" data-v-2d325df8>99 如何保证redis中的数据都是热数据</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_100-redis适用场景" data-v-2d325df8>100 redis适用场景</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_101-redisson-vs-jedis" data-v-2d325df8>101 redisson   VS   Jedis</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_102-redis设置密码及验证密码" data-v-2d325df8>102 redis设置密码及验证密码</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_103-redis哈希槽" data-v-2d325df8>103 redis哈希槽</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_104-redis集群的主从复制模型是怎样的" data-v-2d325df8>104 redis集群的主从复制模型是怎样的</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_105-redis集群会有写操作丢失吗" data-v-2d325df8>105 redis集群会有写操作丢失吗</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_106-redis集群最大节点个数" data-v-2d325df8>106 redis集群最大节点个数</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_107-redis集群如何选择数据库" data-v-2d325df8>107 redis集群如何选择数据库</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_108-redis中管道" data-v-2d325df8>108 redis中管道</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_109-redis如何内存优化" data-v-2d325df8>109 redis如何内存优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_110-redis回收进程如何工作" data-v-2d325df8>110 redis回收进程如何工作</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_111-memcached" data-v-2d325df8>111 memcached</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_112-memcached-工作原理" data-v-2d325df8>112 memcached 工作原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_113-memcached如何处理容错" data-v-2d325df8>113 memcached如何处理容错</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_114-redis-同步机制" data-v-2d325df8>114 Redis 同步机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_115-redis-cluster-原理" data-v-2d325df8>115 redis cluster 原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_116-redis实现分布式锁" data-v-2d325df8>116 redis实现分布式锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_117-缓存穿透、击穿、雪崩" data-v-2d325df8>117 缓存穿透、击穿、雪崩</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_118-redis-数据量较大的查找" data-v-2d325df8>118 redis 数据量较大的查找</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_view_java_java-10-redis" data-v-3886f8ec><div><h1 id="redis" tabindex="-1">redis <a class="header-anchor" href="#redis" aria-hidden="true">#</a></h1><h2 id="_01-定义" tabindex="-1">01 定义 <a class="header-anchor" href="#_01-定义" aria-hidden="true">#</a></h2><p>一个高性能的<code>key-value</code>数据库。</p><h2 id="_02-持久化机制" tabindex="-1">02 持久化机制 <a class="header-anchor" href="#_02-持久化机制" aria-hidden="true">#</a></h2><p>Redis提供两种持久化机制RDB和AOF机制。</p><div class="tip custom-block"><p class="custom-block-title">RDB</p><p>RDB(Redis DataBase)持久化：是指用数据集快照的方式半持久化模式记录Redis数据库的所有键值对，在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p><blockquote><p><strong>RDB持久化优点：</strong></p><ul><li>只有一个文件dump.rdb，方便持久化。</li><li>容灾性好，一个文件保存到安全的磁盘。</li><li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化，使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证Redis的高性能</li><li>相对数据集大时，比AOF的启动效率更高。</li></ul></blockquote><blockquote><p><strong>RDB持久化缺点：</strong></p><ul><li>数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。</li></ul></blockquote></div><div class="tip custom-block"><p class="custom-block-title">AOF</p><p>AOF(Append-only file)持久化方式：是指所有的命令行记录以Redis命令请求协议的格式完全持久化存储，保存为aof文件。</p><blockquote><p><strong>AOF持久化优点：</strong></p><ul><li>数据安全，aof持久化可配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。</li><li>通过append模式写文件，即使中途服务宕机，可通过redis-check-aof工具解决数据一致性问题。</li><li>AOF机制的rewrite模式。AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如：误操作的flushall）</li></ul></blockquote><blockquote><p><strong>AOF持久化缺点：</strong></p><ul><li>AOF文件比RDB文件大，且恢复速度慢。</li><li>数据集大的时候，比RDB启动效率低。</li></ul></blockquote></div><h2 id="_03-性能问题" tabindex="-1">03 性能问题 <a class="header-anchor" href="#_03-性能问题" aria-hidden="true">#</a></h2><ol><li>Master最好不要写内存快照，如果Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务。</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步。</li><li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网。</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;-- Slave1 &lt;-- Slave2 &lt;-- Slave3 ... 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可立即启用Slave1做Master，其他不变。</li></ol><h2 id="_04-删除策略" tabindex="-1">04 删除策略 <a class="header-anchor" href="#_04-删除策略" aria-hidden="true">#</a></h2><ol><li>定时删除：在设置键的过期时间的同时，创建一个定时器timer，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li><li>定期删除：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ol><h2 id="_05-淘汰策略" tabindex="-1">05 淘汰策略 <a class="header-anchor" href="#_05-淘汰策略" aria-hidden="true">#</a></h2><ol><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。</li><li>allkeys-random：从数据集中任意选择数据淘汰。</li><li>no-enviction：禁止驱逐数据。</li></ol><blockquote><p>使用策略规则</p><ul><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</li><li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</li></ul></blockquote><h2 id="_06-同步机制" tabindex="-1">06 同步机制 <a class="header-anchor" href="#_06-同步机制" aria-hidden="true">#</a></h2><ol><li>Redis可使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。</li><li>加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ol><h2 id="_07-redis-vs-memcache" tabindex="-1">07 Redis VS Memcache <a class="header-anchor" href="#_07-redis-vs-memcache" aria-hidden="true">#</a></h2><ol><li><p><strong>存储方式</strong> 。Memcache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部分存在硬盘上，保证数据的持久性。</p></li><li><p><strong>数据支持类型</strong>。Memcache对数据类型支持相对简单，Redis有复杂的数据类型。</p></li><li><p><strong>底层模型不同</strong>。底层实现方式及与客户端之间通信的应用协议不一样。Redis直接自己构建VM机制，因为一般调用系统函数的话，会浪费一定的时间去移动和请求。</p></li></ol><h2 id="_08-缓存问题" tabindex="-1">08 缓存问题 <a class="header-anchor" href="#_08-缓存问题" aria-hidden="true">#</a></h2><blockquote><p>**缓存雪崩：**由于原有缓存失效，新缓存未到期，如：设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重会导致数据库宕机。</p></blockquote><p>解决办法：</p><ul><li>大多数系统设计者考虑加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写。</li></ul><blockquote><p>**缓存穿透：**用户查询数据，在数据库没有，自然缓存中也会有，这样就导致用户查询的时候，在缓存中找不到，每次都要再去数据库查询一遍，然后返回空，相当于进行了两次无用的查询。</p></blockquote><p>解决办法：</p><ul><li><p>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免对底层存储系统的查询压力。</p></li><li><p>布隆过滤器：引入了k个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p></li><li><p>布隆过滤器算法的核心思想就是利用多个不同的Hash函数来解决冲突。 Hash存在一个冲突的问题，用同一个Hash得到的两个URL的值有可能相同，为了减少冲突，可多引入几个Hash，如果通过其中的一个Hash值我们得到某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。</p></li><li><p>另一个方式：如果一个查询返回的数据为空，不管数据不存在还是系统故障，仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟，通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库。</p></li></ul><blockquote><p>**缓存预热：**系统上线后，将相关的缓存数据直接加载到缓存系统，可避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p></blockquote><p>解决办法：</p><ul><li><p>直接写个缓存刷新页面，上线时手动操作。</p></li><li><p>数据量不大，可项目启动时自动加载。</p></li><li><p>定时刷新缓存。</p></li></ul><blockquote><p>**缓存更新：**定时去清理过期的缓存，当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p></blockquote><p>定期清理维护大量缓存的key是比较麻烦的，每次用户请求都要判断缓存是否失效，逻辑相对比较复杂。</p><blockquote><p>**缓存降级：**当访问量剧增，服务出问题或非核心服务影响到和核心流程的性能时，仍然要保证服务是可用的，即使有损服务，系统可根据一些关键数据进行自动降级，可配置开关实现人工降级。</p></blockquote><p>以参考日志级别设置预案</p><ul><li><p>一般：有些服务偶尔因为网络抖动或者服务正在上线而超时，可自动降级。</p></li><li><p>警告：有些服务一段时间内成功率有波动，可自动降级或人工降级，并发送告警。</p></li><li><p>错误：可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阈值，此时可根据情况自动降级或人工降级。</p></li><li><p>严重错误：特殊原因数据错误了，此时需要紧急人工降级，防止Redis服务故障，导致数据库跟着一起发生雪崩问题，对于不重要的数据缓存数据，可采用服务降级策略，常见做法就是Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p></li></ul><h2 id="_09-数据类型" tabindex="-1">09 数据类型 <a class="header-anchor" href="#_09-数据类型" aria-hidden="true">#</a></h2><ul><li><p>String</p><ul><li>value可是String也可是数字，一般做一些复杂的计数功能的缓存。</li></ul></li><li><p>hash</p><ul><li>value存放是结构化的对象，比较方便的就是操作其中的某个字段，如单点登录，用这种数据结构存储用户信息，以cookieId作为key，设置30分钟过期时间。</li></ul></li><li><p>list</p><ul><li>简单的消息队列。利用lrange命令，基于redis分页功能</li></ul></li><li><p>set</p><ul><li>放一堆不重复的集合，可做全局去重功能。</li></ul></li><li><p>sorted set</p><ul><li>多一个权重参数score，集合中的元素能够按score进行排列，可做排行榜。</li></ul></li></ul><h2 id="_10-事务" tabindex="-1">10 事务 <a class="header-anchor" href="#_10-事务" aria-hidden="true">#</a></h2><blockquote><p>Redis事务通过MULTI、EXEC、DISCARD、WATCH四个原语实现</p></blockquote><ol><li>redis不支持回滚，redis在事务失败时不进行回滚，而是继续执行余下的命令。</li><li>如果一个事务中的命令出现错误，那么所有的命令都不会执行。</li><li>如果一个事务中出现运行错误，那么正确的命令会被执行。</li></ol><div class="tip custom-block"><p class="custom-block-title">原语</p><ul><li><p>MULTI命令，用于开启一个事务，它总是返回OK，MULTI执行之后，客户端可继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p></li><li><p>EXEC命令，执行所有事务块内的命令，返回事务块内所有命令的返回值，按命令执行的先后顺序排列，当操作被打断时，返回空值nil。</p></li><li><p>通过调用DISCARD，客户端可清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。</p></li><li><p>WATCh命令，Redis事务提供check-and-set（CAS）行为，可监控一个或多个键，一旦其中有一个键被修改或者删除，之后的事务就不会执行，监控一直持续到EXEC命令。</p></li></ul></div><h2 id="_11-内存优化" tabindex="-1">11 内存优化 <a class="header-anchor" href="#_11-内存优化" aria-hidden="true">#</a></h2><p>尽可能使用散列表，散列表里面的存储数较少，可尽可能的将数据模型抽象到一个散列表里面，如你的web系统中有一个用户对象，不要为这个用户的名称、姓氏、邮箱、密码设置单独的key，而应该把该用户的所有信息存储到一张散列表里面。</p><h2 id="_12-哨兵机制和集群模式" tabindex="-1">12 哨兵机制和集群模式 <a class="header-anchor" href="#_12-哨兵机制和集群模式" aria-hidden="true">#</a></h2><p><strong>redis 集群有两种：redis 哨兵集群、redis cluster。</strong></p><ol><li>redis 的哨兵集群是基于主从复制来实现的，它可以实现读写分离分担 redis 读操作的压力，而 redis cluster 里面的 slave 节点，只是实现冷被的一个机制，它只有在 master 宕机之后才会工作。</li><li>redis 哨兵机制无法在线扩容，所以它的并发压力受限于单个服务器的资源配置，redis cluster 提供了一个基于 slot 槽的一个数据分片的一个机制，它可以实现在线扩容去提升读写的性能。</li><li>从集群架构的层面来看，redis 哨兵集群是一主多从，而 redis cluster 是一个多主多从的一个机制。</li></ol><div class="tip custom-block"><p class="custom-block-title">另一种回答方式：</p><ul><li>哨兵机制是单节点的高可用方案，它主要是通过监控 Redis 主节点的状态，并在主节点出现故障时自动将从节点升级为主节点，实现服务高可用。哨兵机制具有简单、灵活、易于部署等特点，但是无法实现水平扩展。</li><li>而 Redis 集群则是分布式高可用方案，它将数据分散到不同的节点上存储，通过集群内部的协调机制实现数据的负载均衡和故障转移，Redis 集群具有水平扩展、高性能、高可用等特点，但是相对于哨兵机制，集群部署和维护较为复杂，需要考虑数据分片、节点间通信、数据迁移等问题。</li><li>因此，哨兵机制适用于单节点的高可用需求，而 Redis 集群适用于大规模、高并发的分布式应用场景。</li></ul></div><h2 id="_13-redis-模式" tabindex="-1">13 Redis 模式 <a class="header-anchor" href="#_13-redis-模式" aria-hidden="true">#</a></h2><h3 id="单机模式" tabindex="-1">单机模式 <a class="header-anchor" href="#单机模式" aria-hidden="true">#</a></h3><p>单机模式是最简单的部署模式，Redis 将数据存储在单个节点上，这个节点包括一个 Redis 进程和一个持久化存储，单机模式非常适合小型应用程序或者开发和测试环境，因为它提供了一个简单的方法来存储和检索数据，同时具有低延迟和高性能。</p><h3 id="主从模式" tabindex="-1">主从模式 <a class="header-anchor" href="#主从模式" aria-hidden="true">#</a></h3><p>主从模式是单机模式的基础上添加了数据备份的功能，在主从模式中，Redis 节点被分为主节点和从节点。主节点负责处理所有的写操作，而从节点则复制主节点的数据，并负责处理读操作。主从模式的主要优点是提高了可靠性和可扩展性。如果主节点发生故障，可以使用从节点来恢复数据。</p><h3 id="哨兵模式" tabindex="-1">哨兵模式 <a class="header-anchor" href="#哨兵模式" aria-hidden="true">#</a></h3><p>哨兵模式是主从模式的基础上添加了故障检测和自动故障转移的功能，在哨兵模式中，一个或多个哨兵进程监视 Redis 节点的运行状况。如果主节点发生故障，哨兵会检测到这一情况并自动将其中一个从节点提升为新的主节点。这个过程是自动的，所以不需要人为干预。哨兵模式提高了 Redis 集群的可靠性，确保即使主节点发生故障，Redis 服务也能够继续运行。</p><h3 id="集群模式" tabindex="-1">集群模式 <a class="header-anchor" href="#集群模式" aria-hidden="true">#</a></h3><p>集群模式是在多个 Redis 节点之间分配数据，提供更高的可扩展性和容错能力，在集群模式中，数据被分配到多个 Redis 节点上，每个节点处理自己的数据。当一个节点失效时，集群会自动将这个节点的数据迁移到其他节点上。集群模式在 Redis 大规模部署中非常有用，因为它可以轻松扩展和缩小 Redis集群，而不会影响整个系统的性能和可靠性。</p><h2 id="_14-性能优化" tabindex="-1">14 性能优化 <a class="header-anchor" href="#_14-性能优化" aria-hidden="true">#</a></h2><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/118532234" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/118532234</a></p></blockquote><ol><li>缩短键值对的存储长度；</li><li>使用 lazy free（延迟删除）特性；</li><li>设置键值的过期时间；</li><li>禁用长耗时的查询命令；</li><li>使用 slowlog 优化耗时命令；</li><li>使用 Pipeline 批量操作数据；</li><li>避免大量数据同时失效；</li><li>客户端使用优化；</li><li>限制 Redis 内存大小；</li><li>使用物理机而非虚拟机安装 Redis 服务；</li><li>检查数据持久化策略；</li><li>禁用 THP 特性；</li><li>使用分布式架构来增加读写速度。</li></ol><h2 id="_15-为什么要用缓存" tabindex="-1">15 为什么要用缓存 <a class="header-anchor" href="#_15-为什么要用缓存" aria-hidden="true">#</a></h2><ol><li>使用缓存的目的就是提升读写性能，而实际业务场景下，更多的是为了提升读性能，带来更好的性能，带来更高的并发量。</li><li>redis 的读写性能比 mysql 好的多</li><li>mysql 中的热点数据缓存到 redis 中，提升读取性能，同时也减轻了 mysql 读取压力</li></ol><h2 id="_16-使用-redis-单线程模型效率也能那么高" tabindex="-1">16 使用 Redis 单线程模型效率也能那么高 <a class="header-anchor" href="#_16-使用-redis-单线程模型效率也能那么高" aria-hidden="true">#</a></h2><ol><li>c 语言实现</li><li>纯内存操作</li><li>基于非阻塞的 IO 复用模型机制</li><li>单线程可以避免多线程的频繁上下文切换</li><li>丰富的数据结构（采取 hash 结构，读取读取非常快，对数据存储进行了一些优化，比如跳表）</li></ol><h2 id="_17-redis-线程模型" tabindex="-1">17 Redis 线程模型 <a class="header-anchor" href="#_17-redis-线程模型" aria-hidden="true">#</a></h2><ol><li>Redis 内部使用文件事件处理器，这个文件事件处理器是单线程的，Redis 才叫做单线程的模型。</li><li>它采用 IO 多路复用机制同时监听多个 socket ，根据 socket 上的事件选择对应的事件处理器进行处理。</li><li>文件事件处理器的结构包含 4 个部分 <ol><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ol></li><li>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket ，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</li></ol><h2 id="_18-为什么-redis-需要把所有数据放到内存中" tabindex="-1">18 为什么 Redis 需要把所有数据放到内存中 <a class="header-anchor" href="#_18-为什么-redis-需要把所有数据放到内存中" aria-hidden="true">#</a></h2><ol><li>Redis 将数据放在内存中有一个好处，那就是可以实现最快的对数据读取，如果数据存储在硬盘中，磁盘 IO 会严重影响 Redis 的性能。</li><li>而且 Redis 还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响，其次现在硬件越来越便宜的情况下，Redis 的使用也被应用得越来越多。</li></ol><h2 id="_19-redis-同步机制" tabindex="-1">19 Redis 同步机制 <a class="header-anchor" href="#_19-redis-同步机制" aria-hidden="true">#</a></h2><ol><li>Redis 支持主从同步、从从同步。</li><li>如果是第一次进行主从同步，主节点需要使用 bgsave 命令，再将后续修改操作记录到内存的缓存区，等 RDB 文件全部同步到复制节点，复制节点接受完成后将 RDB 镜像记载到内存中，等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。</li></ol><h2 id="_20-pipeline" tabindex="-1">20 pipeline <a class="header-anchor" href="#_20-pipeline" aria-hidden="true">#</a></h2><ol><li>使用管道的好处在于将多次 IO 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系。</li><li>用管道的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令。只需要最后一步从服务端读取回复即可。</li></ol><h2 id="_21-redis-优点和缺点" tabindex="-1">21 Redis 优点和缺点 <a class="header-anchor" href="#_21-redis-优点和缺点" aria-hidden="true">#</a></h2><p>优点</p><ol><li>速度快：因为数据存在内存中，类似于 HashMap、HashMap的优势就是查找和操作的时间复杂度都是 O (1)</li><li>支持丰富的数据结构：支持 String 、List、Set、Sorted Set、Hash 五种基础的数据结构。</li><li>持久化存储：Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</li><li>高可用：内置 Redis Sentinel ，提供高可用方案，实现主从故障自动转移。内置 Redis Cluster，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。</li><li>丰富的特性：Key 过期、计数、分布式锁、消息队列。</li></ol><p>缺点</p><ol><li>由于 Redis 是内存数据库，所以单台机器，存储的数据量取决于机器本身的内存大小，虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</li><li>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU，并会消耗网络带宽。</li><li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久，在这个过程中，Redis 不能提供服务。</li></ol><h2 id="_23-redis-缓存刷新策略" tabindex="-1">23 Redis 缓存刷新策略 <a class="header-anchor" href="#_23-redis-缓存刷新策略" aria-hidden="true">#</a></h2><ol><li>LRU、LFU、FIFO 算法删除：内存达到最大值的时候，首先关注的是过期数据，通过删除策略来达到保护内存的效果，只需要关注缓存的策略配置</li><li>超时删除：设置过期时间</li><li>主动更新：开发控制生命周期</li></ol><h2 id="_24-redis-持久化" tabindex="-1">24 Redis 持久化 <a class="header-anchor" href="#_24-redis-持久化" aria-hidden="true">#</a></h2><ol><li>RDB 持久化方式是指数据集快照的半持久化模式，记录 Redis 数据库的所有键值对，在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复</li></ol><blockquote><p>优点：</p><ol><li>只有一个文件 dump.rdb，方便持久化</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能。</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ol><p>缺点：</p><ol><li>数据安全性低。</li><li>RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。</li><li>所以这种方式更适合数据要求不严谨的时候。</li></ol></blockquote><ol start="2"><li>AOF （Append-only file）持久化方式：指所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储，保存为 AOF 文件。</li></ol><blockquote><p>优点：</p><ol><li>数据安全，AOF 持久化可以配置 appendfsync 属性，有 always ，每进行一次命令操作就记录到 AOF 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>aof 机制的 rewrite 模式。aof 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如：误操作的 flushall）</li></ol><p>缺点：</p><ol><li>aof 文件比 rdb 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li></ol></blockquote><h2 id="_25-持久化机制怎么选择" tabindex="-1">25 持久化机制怎么选择 <a class="header-anchor" href="#_25-持久化机制怎么选择" aria-hidden="true">#</a></h2><ol><li>不要仅仅使用 RDB ，因为那样会导致你丢失很多数据。</li><li>也不要仅仅使用 AOF ，因为那样有两个问题，第一，你通过 AOF 做冷备没有 RDB 做冷备的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免AOF 这种复杂和恢复机制的 BUG。</li><li>Redis 支持同时开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择；用 RDB 来做不同程度的冷备，在 AOF 文件都是丢失或者损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li><li>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。</li></ol><h2 id="_26-redis-实现消息队列" tabindex="-1">26 Redis 实现消息队列 <a class="header-anchor" href="#_26-redis-实现消息队列" aria-hidden="true">#</a></h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息，当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p><div class="language-shell"><span class="copy"></span><pre><code><span class="line"><span style="color:#C9D1D9;">1. 可不可以不用 sleep </span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">list 还有个指令叫 blpop ，在没有消息时候，它会阻塞住直到消息到来。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">2. 能不能生产一次消费多次</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">3. pub/sub 有什么缺点</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列，如 rabbitmq</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">4. redis 如何实现延时队列</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">使用 sortedset 拿时间戳作为 score ，消息内容作为key 调用 zadd 来生产消息，消费者用 zrangbyscore 指令获取 N 秒之前的数据轮询进行处理。</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><h2 id="_27-redis-事务" tabindex="-1">27 Redis 事务 <a class="header-anchor" href="#_27-redis-事务" aria-hidden="true">#</a></h2><ol><li>Redis 中的事务是一组命令的集合，是 Redis 的最小执行单位。</li><li>它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务的过程中，不会被其它客户端发送来的命令请求打断。</li><li>它的原理是先将属于一个事务的命令发送给 Redis，然后依次执行这些命令。</li></ol><h2 id="_28-redis-事务注意点" tabindex="-1">28 Redis 事务注意点 <a class="header-anchor" href="#_28-redis-事务注意点" aria-hidden="true">#</a></h2><ol><li>Redis 事务不支持回滚，不像 MySQL 的事务一样，要么都执行要么都不执行</li><li>Redis 服务端在执行事务的过程中，不会被其它客户端发送来的命令请求打断，直到事务命令全部执行完毕才会执行其它客户端的命令。</li></ol><h2 id="_29-redis-事务为什么不支持回滚" tabindex="-1">29 Redis 事务为什么不支持回滚 <a class="header-anchor" href="#_29-redis-事务为什么不支持回滚" aria-hidden="true">#</a></h2><ol><li>Redis 的事务不支持回滚，但是执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层面捕获并解决。</li><li>但是如果出现其它问题，则依然会继续执行余下的命令。这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。</li></ol><h2 id="_30-redis-为什么设计成单线程" tabindex="-1">30 Redis 为什么设计成单线程 <a class="header-anchor" href="#_30-redis-为什么设计成单线程" aria-hidden="true">#</a></h2><ol><li>多线程处理会涉及到锁，并且多线程处理会涉及到线程切换而消耗 CPU</li><li>采用单线程，避免了不必要的上下文切换和竞争条件。</li><li>其次 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。</li></ol><h2 id="_31-bigkey" tabindex="-1">31 bigkey <a class="header-anchor" href="#_31-bigkey" aria-hidden="true">#</a></h2><ol><li>bigKey 是键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。</li><li>bigKey 的主要影响有： <ol><li>网络阻塞：获取 bigKey 时，传输的数据量比较大，会增加带宽的压力</li><li>超时阻塞：因为 bigKey 占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。</li><li>导致内存空间不平衡：一个 bigKey 存储数据量比较大，同一个 key 在同一个节点或服务器中存储，会造成一定影响。</li></ol></li></ol><h2 id="_32-redis-集群模式" tabindex="-1">32 Redis 集群模式 <a class="header-anchor" href="#_32-redis-集群模式" aria-hidden="true">#</a></h2><ol><li>Redis Sentinel：体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</li><li>Redis Cluster：官方提供的集群化方案，体量较大时，选择 Redis Cluster 通过分片，使用更多内存。</li><li>客户端分片：在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据，这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控等等。</li></ol><h2 id="_33-redis-cluster-集群" tabindex="-1">33 Redis Cluster 集群 <a class="header-anchor" href="#_33-redis-cluster-集群" aria-hidden="true">#</a></h2><p>原理</p><ol><li>所有的节点相互连接</li><li>集群消息通信通过集群总线通信，集群总线端口大小为客户端服务端口 + 10000 （固定值）</li><li>节点与节点之间通过二进制协议进行通信。</li><li>客户端和集群节点之间通信和通常一样，通过文本协议进行</li><li>集群节点不会代理查询</li><li>数据按照 Slot 存储分布在多个 Redis 实例上</li><li>集群节点挂掉会自动故障转移</li><li>可以相对滑扩/缩容节点</li></ol><div class="tip custom-block"><p class="custom-block-title">哈希槽</p><p>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc 16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0至 16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。</p></div><div class="danger custom-block"><p class="custom-block-title">Redis Cluster 集群方案什么情况下会导致整个集群不可用</p><p>Redis 没有使用哈希一致性算法，而是使用的哈希槽一共 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取模 16384 。</p><p>假设集群中有 A\B\C 三个集群节点，不存在复制模式下，每个集群的节点包含的哈希槽如下：</p><ol><li>节点 A 包含从 0 到 5500 的哈希槽</li><li>节点 B 包含从 5501 到 11000 的哈希槽</li><li>节点 C 包含从 11001 到 16383 的哈希槽</li><li>这时，如果节点 B 出现故障，整个集群就会出现缺少 5501 到 11000 的哈希槽范围而不可用</li></ol></div><h2 id="_34-redis-常见的性能问题和解决方案" tabindex="-1">34 Redis 常见的性能问题和解决方案 <a class="header-anchor" href="#_34-redis-常见的性能问题和解决方案" aria-hidden="true">#</a></h2><ol><li>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</li><li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次。</li><li>为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一局域网内</li><li>尽量避免在压力很大的主库上增加从库</li><li>主从复制不要用网状结构，用单向链表结构更为稳定，即：Master ~ Slave1 ~ Slave2 ~ ... ，这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master ，其它不变。</li></ol><h2 id="_35-keys-vs-scan" tabindex="-1">35 keys vs scan <a class="header-anchor" href="#_35-keys-vs-scan" aria-hidden="true">#</a></h2><p>可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好</p><ol><li>使用 keys 命令</li></ol><p>直接使用 keys 命令查询，但是如果是在 生产环境下使用会出现一个问题，keys 命令是遍历查询的，查询的时间复杂度为 O(n)，数量越大查询时间越长，而且 Redis 是单线程，Keys 指令会导致线程阻塞一段时间，会导致线上 Redis 停顿一段时间，直到 keys 执行完毕才能恢复，这在生产环境是不允许的。除此之外，需要注意的是，这个命令没有分页功能，会一次性查询出所有符合条件的 key 值，会发现查询结果非常大，输出的信息非常多，所以不推荐使用这个命令。</p><ol start="2"><li>使用 scan 命令</li></ol><p>scan 命令可以实现和 keys 一样的匹配功能，但是 scan 命令在执行过程不会阻塞线程，并且查找的数据可能存在重复，需要客户端操作去重。因为 scan 是通过游标方式查询的，所以不会导致 Redis 出现假死的问题。</p><p>Redis 查询过程中会把游标返回给客户端，单次返回空值且游标不为 0 ，则说明遍历还没结束，客户端继续遍历查询。</p><p>scan 在检索的过程中，被删除的元素是不会查询出来的，但是如果在迭代过程中有元素被修改，scan 不能保证查询出对应元素，相对来说，scan 指令查找花费的时间比 keys 指令长。</p><h2 id="_36-大量的-key-同一时间过期" tabindex="-1">36 大量的 key 同一时间过期 <a class="header-anchor" href="#_36-大量的-key-同一时间过期" aria-hidden="true">#</a></h2><ol><li>如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致数据库崩溃，系统出现 502 问题</li><li>也有可能同时失效，那一刻不用都访问数据库，压力不够大的话，那么 Redis 出现暂时短暂的卡顿问题。</li><li>所以为了预防这种问题的发生，最好给数据的过期时间加一个随机值，让过期时间更加分散。</li></ol><h2 id="_37-redis-阻塞" tabindex="-1">37 Redis 阻塞 <a class="header-anchor" href="#_37-redis-阻塞" aria-hidden="true">#</a></h2><p>内部原因</p><ol><li>如果 Redis 主机的 CPU 负载过高，也会导致系统崩溃</li><li>数据持久化占用资源过多</li><li>对 Redis 的 API 或指令使用不合理，导致 Redis 出现问题。</li></ol><p>外部原因</p><ol><li>外部原因主要是服务器的原因，例如服务器的 CPU 线程在切换过程中竞争过大，内存出现问题，网络问题。</li></ol><h2 id="_38-redis-分布式锁" tabindex="-1">38 Redis 分布式锁 <a class="header-anchor" href="#_38-redis-分布式锁" aria-hidden="true">#</a></h2><h3 id="锁为被释放" tabindex="-1">锁为被释放 <a class="header-anchor" href="#锁为被释放" aria-hidden="true">#</a></h3><p>由于当前线程获取到锁，处理完业务后未及时释放锁，导致其它线程会一直尝试获取锁阻塞。</p><p>导致 Redis 没有空闲线程来处理客户端命令。</p><blockquote><p>解决方法</p><ul><li>拿到锁的线程处理完业务及时释放锁；</li><li>如果是重入锁未拿到锁后，线程可以释放当前连接并且 sleep 一段时间</li></ul></blockquote><h3 id="b-的锁被-a-给释放了" tabindex="-1">B 的锁被 A 给释放了 <a class="header-anchor" href="#b-的锁被-a-给释放了" aria-hidden="true">#</a></h3><p>SETNX 命令：当 Key 不存在时将 Key 的值设为 value ，返回值为 1；存在，则 SETNX 不做任何动作，返回值为 0；</p><blockquote><p>解决方法</p><ul><li>每个线程加锁时要带上自己独有的 value 值来标识，只释放指定的 value 的 key，否则就会出现释放锁混乱的场景。</li></ul></blockquote><h3 id="数据库事务超时" tabindex="-1">数据库事务超时 <a class="header-anchor" href="#数据库事务超时" aria-hidden="true">#</a></h3><p>给方法添加一个 @Transaction 注解开启事务，如代码中抛出异常进行回滚，要知道数据库事务可是有超时时间限制的，并不会无条件的一直等一个耗时的数据库操作。</p><p>比如：我们解析一个大文件，再将数据存入到数据库，如果执行时间太长，就会导致事务超时自动回滚。一旦你的 Key 长时间获取不到锁，获取<code>锁等待时间</code>远超过<code>数据库事务的超时时间</code>，程序就会报异常。</p><blockquote><p>解决方法</p><ul><li>将数据库事务改为手动提交、回滚事务。</li></ul></blockquote><h3 id="锁过期了，业务还没执行完" tabindex="-1">锁过期了，业务还没执行完 <a class="header-anchor" href="#锁过期了，业务还没执行完" aria-hidden="true">#</a></h3><p>使用 <code>Redisson</code> 自动续期，加锁成功后，会注册一个定时任务监听这个锁，每隔 10 秒就去查看这个锁，如果还持有锁，就对过期时间进行续期</p><blockquote><p>默认过期时间 30 秒</p></blockquote><h3 id="主从复制" tabindex="-1">主从复制 <a class="header-anchor" href="#主从复制" aria-hidden="true">#</a></h3><p>假如现在 A 客户端想要加锁，它会根据路由规则选择一台 master 节点写入 key ，在加锁成功后，master 节点会把 key 异步复制给对应的 slave 节点。</p><p>如果此时 master 节点宕机，为保证集群可用性，会进行主备切换，slave 变成了 master ，B 客户端在新的 master 节点上加锁成功，而 A 客户端也以为自己还是成功加了锁的。</p><p>此时就会导致同一时间内多个客户端对一个分布式完成了加锁，导致各种脏数据的产生</p><blockquote><p>红锁</p><p>用多个 master 实例，来获取锁，只有大多数实例获取到了锁，才算获取成功</p><ol><li>获取当前的时间（单位毫秒）</li><li>使用相同的 key 和 随机值在 N 个节点上请求锁，这里获取锁的尝试时间要远远小于锁的超时时间，防止某个 master 宕机了，我们还在不断的获取锁，而被阻塞过长的时间</li><li>只有大多数节点上获取到了锁，而且总的获取时间小于锁的超时时间的情况下，认为锁获取成功了。</li><li>如果锁获取成功了，锁的超时时间就是最初的锁超时时间进去获取锁的总耗时时间。</li><li>如果锁获取失败了，不管是因为获取成功的节点的数目没有过半，还是因为获取锁的耗时超过了锁的释放时间，都会将已经设置了 key 的 master 上的 key 删除。</li></ol></blockquote><p>参考</p><ul><li><p>Redis 分布式锁：<a href="https://www.cnblogs.com/youngdeng/p/12883790.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/youngdeng/p/12883790.html</a></p></li><li><p>红锁：<a href="https://blog.csdn.net/jiangxiulilinux/article/details/107015292" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/jiangxiulilinux/article/details/107015292</a></p></li><li><p>项目参考：<a href="https://gitee.com/kekingcn/spring-boot-klock-starter.git" target="_blank" rel="noopener noreferrer">https://gitee.com/kekingcn/spring-boot-klock-starter.git</a></p></li></ul><h2 id="_39-redis-memcache" tabindex="-1">39 redis memcache <a class="header-anchor" href="#_39-redis-memcache" aria-hidden="true">#</a></h2><ol><li>存储方式：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。</li></ol><blockquote><p>redis 有部分数据存在硬盘上，这样能保证数据的持久性。</p></blockquote><ol start="2"><li>数据支持类型 memcache 对数据类型支持相对简单。redis 有复杂的数据类型。</li><li>使用底层模型不同，它们之间底层实现方式，以及与客户端之间通信的应用协议不一样。</li></ol><blockquote><p>redis 直接自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p></blockquote><h2 id="_40-redis-持久化" tabindex="-1">40 redis 持久化 <a class="header-anchor" href="#_40-redis-持久化" aria-hidden="true">#</a></h2><p><strong>RDB、AOF 机制</strong></p><ol><li>RDB：是指用数据集快照的方式半持久化模式，记录 redis 数据库的所有键值对。</li></ol><blockquote><p>在某个时间点将数据写一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p></blockquote><div class="tip custom-block"><p class="custom-block-title">RDB 优点</p><ol><li>只有一个文件 dump.rdb，方便持久化。</li><li>容灾性号，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令。所以是 IO 最大化。</li><li>使用单独的子进程进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能。</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ol></div><div class="danger custom-block"><p class="custom-block-title">RDB 缺点</p><p>数据安全性低，RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失， 所以这种方式更合适数据要求不严谨的时候</p></div><ol start="2"><li>AOF：是指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储，保存为 aof 文件。</li></ol><div class="tip custom-block"><p class="custom-block-title">AOF 优点</p><ol><li>数据安全，aof 持久化可以配置 appendfsync 属性，有 always ，每进行一次命令操作就记录到 aof 文件中一次。</li><li>通过 append 模式写文件，即使中途服务宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>aof 机制的 rewrite 模式，aof 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令</li></ol><blockquote><p>比如误操作的 flushall</p></blockquote></div><div class="danger custom-block"><p class="custom-block-title">AOF 缺点</p><ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 RDB 启动效率低。</li></ol></div><h2 id="_41-redis-性能问题" tabindex="-1">41 redis 性能问题 <a class="header-anchor" href="#_41-redis-性能问题" aria-hidden="true">#</a></h2><ol><li>master 最好不要写内存快照，如果 master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作。</li></ol><blockquote><p>当快照比较大时对性能影响是非常大的，会间断性暂停服务。</p></blockquote><ol start="2"><li>如果数据比较重要，某个 slave 开启 aof 备份数据，策略设置为每秒同步一次。</li><li>为了主从复制的速度和连接的稳定性，master 和 slave 最好在同一局域网。</li><li>主从复制不要用图状结构，用单向链表结构更为稳定</li></ol><blockquote><p>master &lt;-- slave1 &lt;-- slave2 &lt;-- slave3 ... 这样的结构方便解决单点故障问题，实现 slave 对 master 的替换，如果 master 挂了，可以立刻启用 slave1 做 master ,其他不变。</p></blockquote><div class="tip custom-block"><p class="custom-block-title">Redis常见的性能问题和解决方案</p><ol><li>master最好不要做持久化工作，如RDB内存快照和AOF日志文件</li><li>如果数据比较重要，某个slave开启AOF备份，策略设置成每秒同步一次</li><li>为了主从复制的速度和连接的稳定性，master和slave最好在一个局域网内</li><li>尽量避免在压力大的主库增加从库</li><li>主从复制不要采用网状结构，尽量是线性结构</li></ol></div><h2 id="_42-redis-删除策略" tabindex="-1">42 redis 删除策略 <a class="header-anchor" href="#_42-redis-删除策略" aria-hidden="true">#</a></h2><ol><li>定时删除：在设置键的过期时间的同时，创建一个定时器 timer。</li></ol><blockquote><p>让定时器在键的过期时间来临时，立即执行对键的删除操作。</p></blockquote><ol start="2"><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期。</li></ol><blockquote><p>如果过期就删除，没有过期就返回该键。</p></blockquote><ol start="3"><li>定期删除：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。</li></ol><blockquote><p>至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p></blockquote><h2 id="_43-redis-淘汰策略" tabindex="-1">43 redis 淘汰策略 <a class="header-anchor" href="#_43-redis-淘汰策略" aria-hidden="true">#</a></h2><ol><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。</li><li>allkeys-random：从数据集中任意选择数据淘汰。</li><li>no-enviction(驱逐)：禁止驱逐数据。</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据。 后面的lru、ttl以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。</p></div><p>使用策略规则</p><ol><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru。</li><li>如果数据呈现平等分布，也就是所有数据访问频率都相同，则使用 allkeys-random</li></ol><h2 id="_44-redis-同步机制" tabindex="-1">44 redis 同步机制 <a class="header-anchor" href="#_44-redis-同步机制" aria-hidden="true">#</a></h2><ol><li>redis 可以使用主从同步。从从同步。</li><li>第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，</li><li>复制节点接受完成后将 rdb 镜像加载到内存。</li><li>加载完成后，再通知主节点将期间修改的操作记录，同步到复制节点进行重放，就完成了同步过程。</li></ol><h2 id="_45-redis-哈希槽" tabindex="-1">45 redis 哈希槽 <a class="header-anchor" href="#_45-redis-哈希槽" aria-hidden="true">#</a></h2><ol><li>redis 集群没有使用一致性 hash，而是引入了哈希槽的概念。</li><li>redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。</li><li>集群的每个节点负责一部分 hash 槽。</li></ol><h2 id="_46-redis-事务相关命令" tabindex="-1">46 redis 事务相关命令 <a class="header-anchor" href="#_46-redis-事务相关命令" aria-hidden="true">#</a></h2><ol><li>MULTI</li><li>EXEC</li><li>DISCARD</li><li>WATCH</li></ol><h2 id="_47-redis-内存优化" tabindex="-1">47 redis 内存优化 <a class="header-anchor" href="#_47-redis-内存优化" aria-hidden="true">#</a></h2><ol><li>尽可能使用散列表</li><li>散列表使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</li></ol><blockquote><p>比如：你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key， 而是应该把这个用户的所有信息存储到一张散列表里面。</p></blockquote><h2 id="_48-redis-热点数据" tabindex="-1">48 redis 热点数据 <a class="header-anchor" href="#_48-redis-热点数据" aria-hidden="true">#</a></h2><p>redis 内存数据集大小上升到一定大小的时候，就会实施数据淘汰策略。</p><h2 id="_49-redis-keys-指令" tabindex="-1">49 redis keys 指令 <a class="header-anchor" href="#_49-redis-keys-指令" aria-hidden="true">#</a></h2><p><strong>keys 指令存在的问题</strong></p><blockquote><p>keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p></blockquote><p><strong>解决方式</strong></p><blockquote><p>这个时候可以使用 scan 指令，scan 指令可以无阻塞的取出指定模式的 key 列表，但是会有一定的重复概率， 在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p></blockquote><h2 id="_50-redis-实现异步队列" tabindex="-1">50 redis 实现异步队列 <a class="header-anchor" href="#_50-redis-实现异步队列" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">Redis 异步队列</p><ol><li>使用list类型保持数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop，在没有信息的时候，会一直阻塞，直到信息的到来</li><li>redis可通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产消息会丢失。</li></ol></div><ol><li>使用 list 结构作为队列，rpush 生产消息，lpop 消费消息，当 lpop 没有消息的时候，要适当 sleep 一会再重试。</li></ol><p><strong>追问：不用 sleep 重试是否可以？</strong></p><blockquote><p>也可以不用 sleep，list 还有指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</p></blockquote><p><strong>追问：能不能生产一次消费多次？</strong></p><blockquote><p>使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。</p></blockquote><p><strong>追问：pub/sub 缺点？</strong></p><blockquote><p>在消费者下线的时候，生产的消息会丢失，可以使用MQ解决等等。</p></blockquote><p><strong>追问：redis 实现延时队列？</strong></p><blockquote><ol><li>使用 sortedset ，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，</li><li>消费者用 zrangebyscore 指令，获取 N 秒之前的数据轮询进行处理</li></ol></blockquote><h2 id="_51-redis-持久化机制" tabindex="-1">51 redis 持久化机制 <a class="header-anchor" href="#_51-redis-持久化机制" aria-hidden="true">#</a></h2><p>redis提供两种持久化机制RDB和AOF机制。</p><p>RDB(redis DataBase)持久化：是指用数据集快照的方式半持久化模式记录redis数据库的所有键值对，在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p><blockquote><p>RDB持久化优点：</p><ul><li>只有一个文件dump.rdb，方便持久化。</li><li>容灾性好，一个文件保存到安全的磁盘。</li><li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化，使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证redis的高性能</li><li>相对数据集大时，比AOF的启动效率更高。</li></ul></blockquote><blockquote><p>RDB持久化缺点：</p><ul><li>数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。</li></ul></blockquote><p>AOF(Append-only file)持久化方式：是指所有的命令行记录以redis命令请求协议的格式完全持久化存储，保存为aof文件。</p><blockquote><p>AOF持久化优点：</p><ul><li>数据安全，aof持久化可配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。</li><li>通过append模式写文件，即使中途服务宕机，可通过redis-check-aof工具解决数据一致性问题。</li><li>AOF机制的rewrite模式。AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如：误操作的flushall）</li></ul></blockquote><blockquote><p>AOF持久化缺点：</p><ul><li>AOF文件比RDB文件大，且恢复速度慢。</li><li>数据集大的时候，比RDB启动效率低。</li></ul></blockquote><h2 id="_52-redis-性能问题" tabindex="-1">52 redis 性能问题 <a class="header-anchor" href="#_52-redis-性能问题" aria-hidden="true">#</a></h2><ol><li>Master最好不要写内存快照，如果Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务。</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步。</li><li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网。</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;-- Slave1 &lt;-- Slave2 &lt;-- Slave3 ... 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可立即启用Slave1做Master，其他不变。</li></ol><h2 id="_53-redis-过期键的删除策略" tabindex="-1">53 redis 过期键的删除策略 <a class="header-anchor" href="#_53-redis-过期键的删除策略" aria-hidden="true">#</a></h2><ol><li>定时删除：在设置键的过期时间的同时，创建一个定时器timer，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li><li>定期删除：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ol><h2 id="_54-redis-淘汰策略" tabindex="-1">54 redis 淘汰策略 <a class="header-anchor" href="#_54-redis-淘汰策略" aria-hidden="true">#</a></h2><ol><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。</li><li>allkeys-random：从数据集中任意选择数据淘汰。</li><li>no-enviction：禁止驱逐数据。</li></ol><blockquote><p>使用策略规则</p><ul><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</li><li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</li></ul></blockquote><h2 id="_55-redis-同步机制" tabindex="-1">55 redis 同步机制 <a class="header-anchor" href="#_55-redis-同步机制" aria-hidden="true">#</a></h2><ol><li>redis可使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。</li><li>加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ol><h2 id="_56-redis-定义" tabindex="-1">56 redis 定义 <a class="header-anchor" href="#_56-redis-定义" aria-hidden="true">#</a></h2><ol><li>redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的高性能非关系型（NoSQL）的键值对数据库。</li><li>redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串 列表 集合 散列表 有序集合。</li><li>redis 每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</li><li>另外 redis 也常用来做分布式锁。</li></ol><h2 id="_57-redis-缺点" tabindex="-1">57 redis 缺点 <a class="header-anchor" href="#_57-redis-缺点" aria-hidden="true">#</a></h2><ul><li>由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。</li><li>虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。</li><li>如果内存增长过快，需要定期删除数据。</li><li>如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。</li><li>不过redis2.8版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。</li><li>比如，新上线的备机。修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。</li><li>在这个过程中，redis不能提供服务。</li></ul><h2 id="_58-redis-单线程高并发" tabindex="-1">58 redis 单线程高并发 <a class="header-anchor" href="#_58-redis-单线程高并发" aria-hidden="true">#</a></h2><ol><li>redis是基于内存的操作，CPU不是redis的瓶颈，redis的瓶颈最有可能是机器内存的大小或者网络带宽。</li><li>既然单线程容易实现而且省去了很多上下文切换线程的时间，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li><li>redis使用epoll多路I/O复用技术，单个线程可以处理大量的并发连接。epoll是一种高效的多路复用技术。</li></ol><h2 id="_59-为什么要用redis而不是map或者guava做缓存" tabindex="-1">59 为什么要用redis而不是map或者guava做缓存 <a class="header-anchor" href="#_59-为什么要用redis而不是map或者guava做缓存" aria-hidden="true">#</a></h2><p>缓存分为本地缓存和分布式缓存。</p><ul><li><p>以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，</p></li><li><p>并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p></li><li><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。</p></li><li><p>缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p></li></ul><h2 id="_60-redis-数据结构-string-与-hash-的区别" tabindex="-1">60 redis 数据结构 string 与 hash 的区别 <a class="header-anchor" href="#_60-redis-数据结构-string-与-hash-的区别" aria-hidden="true">#</a></h2><ul><li><p>string list hash set zset</p></li><li><p>String多应用于简单的键值对缓存；</p></li><li><p>hash储存结构化数据，比如一个对象。</p></li></ul><h2 id="_61-跳跃表" tabindex="-1">61 跳跃表 <a class="header-anchor" href="#_61-跳跃表" aria-hidden="true">#</a></h2><ol><li>SkipList是在有序链表的基础上进行了扩展，解决了有序链表结构查找特定值困难的问题，查找特定值的时间复杂度为O(logn)，</li><li>是一种可以代替平衡树的数据结构。</li><li>它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，就能轻松实现一个 SkipList。</li></ol><h2 id="_62-redis-持久化机制" tabindex="-1">62 redis 持久化机制 <a class="header-anchor" href="#_62-redis-持久化机制" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">RDB</p><p>开启一个新的线程来完成往rdb文件中的写操作。主线程继续处理命令。使用单独的子线程来进行持久化。主线程不进行任何的IO操作。 保证redis的高性能。缺点是可能会丢失一些数据。</p></div><div class="tip custom-block"><p class="custom-block-title">AOF</p><ol><li>AOF持久化(即Append Only File持久化)，则是将 redis 执行的每次写命令记录到单独的日志文件中，</li><li>当重启redis会重新将持久化的日志中文件恢复数据。AOF有一个重写模式，当日志文件过大时可以对其进行压缩。</li><li>AOF往往效率低于RDB一些。</li><li>AOF的追写策略：建议使用每秒同步一次（everysec）策略。</li><li>rewrite机制：rewrite会记录上次重写时AOF文件的大小，当AOF文件是上一次大小的二倍且大于64M时触发。</li></ol></div><h2 id="_63-如何选择合适的持久化方式" tabindex="-1">63 如何选择合适的持久化方式 <a class="header-anchor" href="#_63-如何选择合适的持久化方式" aria-hidden="true">#</a></h2><ol><li><p>一般来说两者配合使用效果最佳，当 redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p></li><li><p>如果可以容忍数分钟内的数据丢失，可以只选用RDB方式，还比较快。</p></li><li><p>不推荐只使用AOF方式。</p></li></ol><h2 id="_64-过期键的删除策略" tabindex="-1">64 过期键的删除策略 <a class="header-anchor" href="#_64-过期键的删除策略" aria-hidden="true">#</a></h2><ul><li><p>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p></li><li><p>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p></li></ul><h2 id="_65-redis设置键的过期时间以及永不过期命令是什么" tabindex="-1">65 redis设置键的过期时间以及永不过期命令是什么 <a class="header-anchor" href="#_65-redis设置键的过期时间以及永不过期命令是什么" aria-hidden="true">#</a></h2><ul><li><p>expire设置过期时间</p></li><li><p>persist设置键永不过期，多用于热点数据。</p></li></ul><h2 id="_66-redis的内存淘汰策略有哪些" tabindex="-1">66 redis的内存淘汰策略有哪些 <a class="header-anchor" href="#_66-redis的内存淘汰策略有哪些" aria-hidden="true">#</a></h2><ul><li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</li></ul><h2 id="_67-redis-线程模型" tabindex="-1">67 redis 线程模型 <a class="header-anchor" href="#_67-redis-线程模型" aria-hidden="true">#</a></h2><p>redis以单线程模式运行，但是通过使用 I/O 多路复用来监听多个套接字（socket）， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 redis 内部单线程设计的简单性。</p><h2 id="_68-redis-主从复制" tabindex="-1">68 redis 主从复制 <a class="header-anchor" href="#_68-redis-主从复制" aria-hidden="true">#</a></h2><p>主从连接过程：</p><ol><li>从服务器连接主服务器，发送SYNC命令。主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令。</li><li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li><li>一旦主机挂了，从机会原地待命，但是使用 salveof no one 命令会使从机反仆为主。</li><li>作用：数据冗余 故障恢复 负载均衡 高可用的基石。使用slave of 命令将某一台redis变为从机。</li></ol><h2 id="_69-redis-哨兵机制" tabindex="-1">69 redis 哨兵机制 <a class="header-anchor" href="#_69-redis-哨兵机制" aria-hidden="true">#</a></h2><ol><li>Sentinel(哨兵) 进程是用于监控 redis 集群中 Master 主服务器工作的状态</li><li>在 Master 主服务器发生故障的时候，可以实现 Master 和 Slave 服务器的切换，保证系统的高可用（High Availability）</li><li>为了防止脑裂发生，节点个数一般配置为 2n+1。</li></ol><h2 id="_70-redis-的-key-是如何寻址的及一致性-hash-算法吗" tabindex="-1">70 redis 的 key 是如何寻址的及一致性 hash 算法吗 <a class="header-anchor" href="#_70-redis-的-key-是如何寻址的及一致性-hash-算法吗" aria-hidden="true">#</a></h2><ul><li><strong>为什么有了哨兵模式还需要集群？</strong></li></ul><ol><li>redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，</li><li>所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。</li></ol><div class="tip custom-block"><p class="custom-block-title">数据分配策略</p><ol><li><p>采用一种叫做哈希槽 (hash slot)的方式来分配数据，redis cluster 默认分配了 16384 个slot。将key的 hashCode % 16384得出数据的槽位。</p></li><li><p>分布式寻址算法</p></li><li><p>hash 算法（大量缓存重建）</p><ul><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>redis cluster（集群） 的 hash slot （槽）算法</li></ul></li></ol></div><h2 id="_71-一致性hash" tabindex="-1">71 一致性hash <a class="header-anchor" href="#_71-一致性hash" aria-hidden="true">#</a></h2><p>首先面对海量数据，一台redis肯定是不够用的，一致性hash算法主要是用来将数据按照一定的算法规律存储到指定的redis服务器中。</p><div class="danger custom-block"><p class="custom-block-title">常规的hash算法会导致一个问题：</p><ul><li>当redis的实例个数变了那么所有的hash值都需要重新计算，这是非常耗时的。一致性hash的出现解决了这种问题。</li><li>hash(IP) % 2^32 -1 求出redis主机在圆环中的位置，</li><li>使用hash(key) % 2^32-1求出数据在环上的位置，从该位置顺时针查找到的第一个主机即该数据存储的位置。</li><li>这样一来及有一个标准化的计算过程了。</li></ul></div><h2 id="_72-redlock" tabindex="-1">72 RedLock <a class="header-anchor" href="#_72-redlock" aria-hidden="true">#</a></h2><p>redis 官方站提出了一种权威的基于 redis 实现分布式锁的方式名叫 Redlock</p><div class="tip custom-block"><p class="custom-block-title">此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p><ul><li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li><li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li><li>容错性：只要大部分 redis 节点存活就可以正常提供服务</li></ul></div><h2 id="_73-jedis与redisson对比有什么优缺点" tabindex="-1">73 Jedis与redisson对比有什么优缺点 <a class="header-anchor" href="#_73-jedis与redisson对比有什么优缺点" aria-hidden="true">#</a></h2><ol><li>Jedis是redis的Java实现的客户端，其API提供了比较全面的redis命令的支持；</li><li>redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，</li><li>redisson不支持字符串操作，不支持排序 事务 管道 分区等redis特性。</li><li>redisson的宗旨是促进使用者对redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li><li>redisson解决了锁的自动续期问题，只要业务还在执行，redisson就会为锁自动续期。</li></ol><h2 id="_74-redis事务" tabindex="-1">74 redis事务 <a class="header-anchor" href="#_74-redis事务" aria-hidden="true">#</a></h2><ol><li>redis 事务的本质是通过MULTI EXEC WATCH discard 等一组命令的集合。</li><li>事务支持一次执行多个命令，一个事务中所有命令都会被序列化。</li><li>在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 <ul><li>multi : 标记一个事务块的开始（ queued ）</li><li>exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）</li><li>discard : 取消事务，放弃事务块中的所有命令</li><li>unwatch : 取消watch对所有key的监控</li></ul></li><li>如果一个事务中的命令出现错误，那么所有命令都不会执行。</li><li>redis事务不保证多条指令的原子性。</li><li>基于Lua脚本可以保证脚本中的指令一次性按顺序执行。</li></ol><h2 id="_75-redis与memcached的区别" tabindex="-1">75 redis与memcached的区别 <a class="header-anchor" href="#_75-redis与memcached的区别" aria-hidden="true">#</a></h2><ol><li>支持存储的数据类型：redis支持五种类型。memcached支持文本类型与二进制类型。</li><li>网络IO模型：redis是单线程的多路IO复用模型，memcached是多线程的非阻塞IO模式。</li><li>redis支持数据持久化，memcached不支持</li><li>使用场景：redis适用于复杂的数据结构环境，有持久化需求。memcached适用于纯&lt;k,v&gt;且数据量矩大的环境下。</li></ol><h2 id="_76-redis常见的性能问题与对应的解决方案" tabindex="-1">76 redis常见的性能问题与对应的解决方案 <a class="header-anchor" href="#_76-redis常见的性能问题与对应的解决方案" aria-hidden="true">#</a></h2><ol><li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li><li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li><li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li><li>尽量避免在压力较大的主库上增加从库</li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li><li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li></ol><h2 id="_77-假如redis有一亿个key，其中10万个key以某个固定的已知前缀开头，如何把他们都找出来" tabindex="-1">77 假如redis有一亿个key，其中10万个key以某个固定的已知前缀开头，如何把他们都找出来 <a class="header-anchor" href="#_77-假如redis有一亿个key，其中10万个key以某个固定的已知前缀开头，如何把他们都找出来" aria-hidden="true">#</a></h2><ol><li>keys指令可以扫描得出指定模式的key列表，</li><li>但是问题是由于redis是单线程的，keys指令会导致线程阻塞一段时间，</li><li>此时的线上服务会有短暂停顿直到keys指令执行完毕。</li><li>使用scan指令可以做到无阻塞的提取出指定模式的key列表。</li><li>但有一定的重复几率。再做一遍去重即可。</li></ol><h2 id="_78-布隆过滤器" tabindex="-1">78 布隆过滤器 <a class="header-anchor" href="#_78-布隆过滤器" aria-hidden="true">#</a></h2><ol><li>解决缓存穿透的问题。</li><li>是redis中的一种数据结构，它将MySQL数据库中所有可能存在的数据都缓存到布隆过滤器中。</li><li>当攻击者访问不存在的数据时迅速返回避免请求打到数据库上导致数据库宕机问题。</li></ol><div class="tip custom-block"><p class="custom-block-title">布隆过滤器原理</p><ul><li>Bloom Filter 是一种空间效率很高的随机数据结构</li><li>Bloom filter 可以看做是对 bit-map 的扩展。当一个元素被加入集合时，</li><li>通过 K 个 Hash 函数将这个元素映射成一个位阵列（Bit array）中的 K 个点，把它们置为 1。</li><li>检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它。</li><li>值得注意的是：如果这些点有任何一个 0，则被检索元素一定不在。如果都是 1，则被检索元素很可能在。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">布隆过滤器的优点</p><ul><li>空间效率和查询效率都远远超过一般的算法，布隆过滤器存储空间和插入 / 查询时间都是常数O(k)。</li><li>另外, 散列函数相互之间没有关系，方便由硬件并行实现。</li><li>布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</li></ul></div><div class="danger custom-block"><p class="custom-block-title">布隆过滤器的缺点</p><ul><li>布隆过滤器的缺点和优点一样明显</li><li>误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表就可以。</li><li>另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位数组变成整数数组， <ul><li>每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。</li><li>然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。</li><li>这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</li></ul></li></ul></div><h2 id="_79-redis-分布式锁实现原理" tabindex="-1">79 redis 分布式锁实现原理 <a class="header-anchor" href="#_79-redis-分布式锁实现原理" aria-hidden="true">#</a></h2><ol><li>一个线程尝试去获取锁lock，通过setnx(lock，uuid，过期时间)。如果lock不存在就会设置成功，返回true，否则返回false。</li><li>获取分布式锁成功之后，需要使用expire命令设置锁有效期，防止死锁。</li><li>执行相关业务逻辑</li><li>释放锁，首先获取到lock对应的value，将此value与uuid对比，如果相同的话执行delete指令删除锁。注意！上述两个步骤需要保证原子性。需要使用lua脚本。</li></ol><h2 id="_80-redis-针对数据结构做了哪些优化" tabindex="-1">80 redis 针对数据结构做了哪些优化 <a class="header-anchor" href="#_80-redis-针对数据结构做了哪些优化" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">redis数据模型</p><p>在redis中，会给每一个key-value键值对分配一个字典实体，就是dicEntry。dicEntry包含三部分： key的指针 val的指针 next指针，next指针指向下一个dicteEntry形成链表， 这个next指针可以将多个哈希值相同的键值对链接在一起，通过链地址法来解决哈希冲突的问题</p><ul><li>sds ：Simple Dynamic String，简单动态字符串，存储字符串数据。</li><li>redisObject：redis的5种常用类型都是以redisObject来存储的，redisObject中的type字段指明了值的数据类型（也就是5种基本类型)。ptr字段指向对象所在的地址。</li></ul></div><ul><li>String： sds实现，自定义类型加入了长度，每次获取字符串长度的时间复杂度就是O(1)，而利用len和free属性对追加字符串进行优化，也可以降低重新分配内存的次数。</li><li>Hash： zip-list 或者 hash-table（数组+链表）扩容机制采用渐进式扩容。</li><li>Set： int-Set</li><li>Zset： skip-list</li><li>List： zip-list -&gt; linked-list -&gt; quick-list （前两者合并之后创建了快速链表）</li></ul><h2 id="_81-redis-原子性" tabindex="-1">81 redis 原子性 <a class="header-anchor" href="#_81-redis-原子性" aria-hidden="true">#</a></h2><p>redis是单线程的。在单线程程序中，任务一个一个地做，必须做完一个任务后，才会去做另一个任务。</p><h2 id="_82-什么命令会触发写rdb文件" tabindex="-1">82 什么命令会触发写RDB文件 <a class="header-anchor" href="#_82-什么命令会触发写rdb文件" aria-hidden="true">#</a></h2><ul><li>BGSAVE：后台处理，不会阻塞工作线程。</li><li>SAVE：会导致工作线程的阻塞。</li></ul><h2 id="_83-大key问题" tabindex="-1">83 大Key问题 <a class="header-anchor" href="#_83-大key问题" aria-hidden="true">#</a></h2><p>由于redis主线程为单线程模型，大key也会带来一些问题，</p><ul><li>如：集群模式在slot分片均匀情况下，会出现数据和查询倾斜情况，部分有大key的redis节点占用内存多，QPS高。</li><li>大key相关的删除或者自动过期时，会出现qps突降或者突升的情况，极端情况下，会造成主从复制异常，redis服务阻塞无法响应请求。</li></ul><h2 id="_84-redis4-0之前的大key的发现与删除方法" tabindex="-1">84 redis4.0之前的大key的发现与删除方法 <a class="header-anchor" href="#_84-redis4-0之前的大key的发现与删除方法" aria-hidden="true">#</a></h2><ol><li>redis-rdb-tools工具。redis实例上执行bgsave，然后对生成的rdb文件进行分析，找到其中的大KEY。</li><li>redis-cli --bigkeys命令。可以找到某个实例5种数据类型(String hash list set zset)的最大key。</li><li>由于在redis4.0前，没有lazy free机制； <ul><li>针对扫描出来的大key，DBA只能通过hscan sscan zscan方式渐进删除若干个元素，但面对过期键删除的场景，</li><li>这种取巧的删除就无能为力。我们只能祈祷自动清理过期key刚好在系统低峰时，降低对业务的影响。</li></ul></li><li>redis 4.0之后的大key的发现与删除方法</li><li>redis 4.0引入了memory usage命令和lazy free机制，不管是对大key的发现，还是解决大key删除或者过期造成的阻塞问题都有明显的提升。</li></ol><h2 id="_85-redis-优势" tabindex="-1">85 redis 优势 <a class="header-anchor" href="#_85-redis-优势" aria-hidden="true">#</a></h2><ol><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型。</li><li>redis的速度比memcached快很多</li><li>redis可持久化其数据</li></ol><h2 id="_86-redis-集群方案" tabindex="-1">86 redis 集群方案 <a class="header-anchor" href="#_86-redis-集群方案" aria-hidden="true">#</a></h2><ol><li><p>twemproxy，它类似一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，</p><ul><li>使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，</li><li>将请求转接到具体的redis，将结果再返回twemproxy。使用方式简便，对旧项目扩展的首选。</li></ul></li><li><p>twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p></li></ol><h2 id="_87-redis-分区" tabindex="-1">87 redis 分区 <a class="header-anchor" href="#_87-redis-分区" aria-hidden="true">#</a></h2><ol><li>分区可让redis管理更大的内存，redis将使用所有机器的内存</li><li>如果没有分区，你最多只能使用一台机器的内存</li><li>分区使redis的计算能力通过简单地增加计算机得到成倍提升</li><li>redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</li></ol><h2 id="_88-redis的内存占用情况" tabindex="-1">88 redis的内存占用情况 <a class="header-anchor" href="#_88-redis的内存占用情况" aria-hidden="true">#</a></h2><ul><li>100万个键值对。键是0~999，999值是字符串“hello world”在32位mac本上用了100MB</li><li>同样的数据放到一个key里只需要16MB</li><li>这是因为键值有一个很大的开销</li><li>在Memcached上执行也类似，但是相对redis的开销要小一点点，因为redis会记录类型信息引用计数等等。</li></ul><h2 id="_89-memcached服务特点及工作原理" tabindex="-1">89 Memcached服务特点及工作原理 <a class="header-anchor" href="#_89-memcached服务特点及工作原理" aria-hidden="true">#</a></h2><ol><li>完全基于内存缓存的</li><li>节点之间相互独立</li><li>C/S模式架构，C语言编写，共2000行代码</li><li>异步I/O模型，使用libvent作为事件通知机制</li><li>被缓存的数据以key/value键值对形式存在的</li><li>全部数据存放于内存中，无持久性存储的设计，重启服务器，内存里的数据会丢失。</li><li>当内存中缓存的数据容量达到启动时设定的内存值时，就自动使用LRU算法删除过期的缓存数据</li><li>可对存储的数据设置过期时间，这样过期后的数据自动被清除，服务本身不会监控过期，而是在访问的时候查看key的时间戳，判断是否过期</li><li>memcached会对设定的内存进行分块，再把块分组，然后再提供服务。</li></ol><h2 id="_90-session共享存储" tabindex="-1">90 session共享存储 <a class="header-anchor" href="#_90-session共享存储" aria-hidden="true">#</a></h2><ol><li>Session是运行在一台服务器上的，所有的访问都会达到我们的唯一服务器上，这样我们可以根据客户端传来的sessionID，来获取session，或在对应session不存在的情况下，创建一个新的session。</li><li>但是，如果我们在集群环境下，假设我们有两台服务器A、B，用户的请求会由Nginx服务器进行转发，</li><li>用户登录时，Nginx将请求转发至服务器A上，A创建了新的session，并将sessionID返回给客户端</li><li>用户在浏览器其它页面时，客户端验证登录状态，Nginx将请求转发至服务器B</li><li>由于B上并没有对应客户端发来sessionID的session，所以会重新创建一个新的session，</li><li>并且再将这个新的sessionID返回给客户端，这样，我们可以想象，用户每一次操作都有1/2的概率 进行再次登录</li><li>这样不仅对用户体验特别差，还会让服务器上的session激增，加大服务器的运行压力。</li></ol><div class="tip custom-block"><p class="custom-block-title">解决方案</p><ol><li>粘性session。粘性session是指Nginx每次都将同一用户的所有请求转发至同一台服务器上，即将用户与服务器绑定。</li><li>服务器session复制。每次session发生变化时，创建或修改，就广播给所有集群中的服务器，使所有的服务器上session相同</li><li>session共享。缓存session，使用redis，memcached</li><li>session持久化。将session存储至数据库中，像操作数据一样操作session</li></ol></div><h2 id="_91-memcached与redis区别" tabindex="-1">91 memcached与redis区别 <a class="header-anchor" href="#_91-memcached与redis区别" aria-hidden="true">#</a></h2><ol><li>redis不仅支持简单的k/v类型的数据，同时提供list、set、zset、hash等数据结构的存储，而memcached只支持简单数据类型，需要客户端自己处理复杂对象</li><li>redis支持数据持久化，可将内存中数据保持在磁盘中，重启的时候可以再次加载进行使用（持久化在rdb、aof）</li><li>由于Memcache没有持久化机制，因此宕机所有缓存数据失效，redis配置为持久化，宕机重启后，将自动加载宕机时刻的数据到缓存系统中，具有更好的灾备机制。</li><li>Memcached可以是使用Magent在客户端进行一致性hash做分布式，redis支持在服务器端做分布式（twemproxy、codis、redis-cluster多种分布式实现方式）</li><li>Memcached的简单限制就是键key和value的限制，最大键长为250个字符，可以接受的存储数据不能超过1MB（可修改配置文件变大），因为这是典型slab的最大值，不适合虚拟机使用，而redis的Key长度支持到512k</li><li>redis使用的单线程模型，保证了数据按顺序提交，Memcache需要使用cas保证数据一致性，CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴，原理简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作。</li><li>cpu利用，由于redis只使用单核，而Memcached可使用多核，所以平均每一个核上redis在存储小数据时比Memcached性能更高，而100k以上的数据中，Memcached性能要高于redis。</li><li>Memcache内存管理：使用Slab Allocation，原理简单，预先分配一系列大小固定的组，然后根据数据大小选择最合适的块存储，避免了内存碎片，缺点不呢变长，浪费一定空间，memcached默认情况下一个slab的最大值为前一个1.25倍</li><li>redis内存管理：redis通过定义一个数组来记录所有的内存分配情况，redis采用的包装malloc/free，相较于Memcached的内存管理方法来说，要简单很多，由于malloc首先以链表的方式搜索已管理的内存中可用的空间分配，导致内存碎片比较多。</li></ol><h2 id="_92-redis-优缺点" tabindex="-1">92 redis 优缺点 <a class="header-anchor" href="#_92-redis-优缺点" aria-hidden="true">#</a></h2><ol><li>redis本质上是一个Key-Value的类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</li><li>因为纯内存操作，redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。</li><li>redis支持保存多种数据结构，此外单个value的最大限制是1GB，不像memcached只保存1MB的数据。 a. redis中List用来做FIFO双向链表，实现一个轻量级的高性能消息队列服务，用它的Set可以做高性能的tag系统</li><li>redis对存入的Key-Value设置expire时间，被当作一个功能加强版的memcached来用。</li><li>redis主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写。</li><li>redis适合场景主要局限在较小数据量的高性能操作和运算上。</li></ol><h2 id="_93-redis相比memcached优势" tabindex="-1">93 redis相比Memcached优势 <a class="header-anchor" href="#_93-redis相比memcached优势" aria-hidden="true">#</a></h2><ul><li>memcached所有的值均是简单的字符串，redis作其替代者，支持更为丰富的数据类型</li><li>redis的速度比memcached快很多。</li><li>redis可以持久化其数据。</li></ul><h2 id="_94-redis-淘汰策略" tabindex="-1">94 redis 淘汰策略 <a class="header-anchor" href="#_94-redis-淘汰策略" aria-hidden="true">#</a></h2><ul><li>noeviction 返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令</li><li>allkeys-lru 尝试回收最少使用的键，使得新添加的数据有空间存放</li><li>volatile-lru 尝试回收最少使用的键，但仅限于在过期集合的键，使得新添加的数据有空间存放。</li><li>allkeys-random 回收随机的键使得新添加的数据有空间存放</li><li>volatile-random 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键</li><li>volatile-ttl 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键，使得新添加的数据有空间存放。</li></ul><h2 id="_95-一个字符串类型的值能存储最大容量" tabindex="-1">95 一个字符串类型的值能存储最大容量 <a class="header-anchor" href="#_95-一个字符串类型的值能存储最大容量" aria-hidden="true">#</a></h2><p>512M</p><h2 id="_96-为什么redis需要把所有数据放到内存中" tabindex="-1">96 为什么redis需要把所有数据放到内存中 <a class="header-anchor" href="#_96-为什么redis需要把所有数据放到内存中" aria-hidden="true">#</a></h2><p>redis为达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。 所以redis具有快速和数据持久化的特征，如果不将数据放在内存中，磁盘I/O速度会严重影响redis的性能</p><h2 id="_97-redis集群方案怎么做" tabindex="-1">97 redis集群方案怎么做 <a class="header-anchor" href="#_97-redis集群方案怎么做" aria-hidden="true">#</a></h2><ol><li>codis。目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在节点数量改变情况下，旧节点数据可恢复到新hash节点。</li><li>redis cluster 3.0自带的集群，特点在于它的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。</li><li>在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key进行hash计算，然后去对应的redis实例操作数据，这种方式对Hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后自动脚本恢复，实例的监控</li></ol><h2 id="_98-redis集群方案什么情况下导致整个集群不可用" tabindex="-1">98 redis集群方案什么情况下导致整个集群不可用 <a class="header-anchor" href="#_98-redis集群方案什么情况下导致整个集群不可用" aria-hidden="true">#</a></h2><ol><li>有A、B、C三个节点的集群，在没有复制模型的情况下，</li><li>如果节点B失败了，那么整个集群就会以为5501-11000这个范围的槽而不可用</li></ol><h2 id="_99-如何保证redis中的数据都是热数据" tabindex="-1">99 如何保证redis中的数据都是热数据 <a class="header-anchor" href="#_99-如何保证redis中的数据都是热数据" aria-hidden="true">#</a></h2><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略</p><h2 id="_100-redis适用场景" tabindex="-1">100 redis适用场景 <a class="header-anchor" href="#_100-redis适用场景" aria-hidden="true">#</a></h2><ul><li>会话缓存（Session Cache）使用redis的情景是会话缓存（session cache）。用redis缓存会话比其他存储的优势在于：redis提供持久化，当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分都会不高兴的，</li><li>全页缓存（FPC）除基本的会话token之外，redis还提供很简便的FPC平台，回到一致性问题，即使重启了redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进。</li><li>队列。redis在内存存储引擎领域的一大优点是提供list和set操作，这使得redis能作为一个很好的消息队列平台来使用，redis作为队列使用的操作，就类似于本地程序语言对list的push/pop操作</li><li>排行榜/计数器。redis在内存中数字进行递增或递减的操作实现的非常好，集合（Set）和有序集合（Sorted Set）</li><li>发布/订阅。redis的发布/订阅功能</li></ul><h2 id="_101-redisson-vs-jedis" tabindex="-1">101 redisson VS Jedis <a class="header-anchor" href="#_101-redisson-vs-jedis" aria-hidden="true">#</a></h2><ul><li>Jedis是redis的Java实现的客户端，其API提供了比较全面的redis命令的支持</li><li>redisson实现了分布式和可用扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操纵。不支持排序、事务、管道、分区等redis特性，</li><li>redisson宗旨是促进使用者对redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li></ul><h2 id="_102-redis设置密码及验证密码" tabindex="-1">102 redis设置密码及验证密码 <a class="header-anchor" href="#_102-redis设置密码及验证密码" aria-hidden="true">#</a></h2><ul><li>设置密码：config set requirepass 123456</li><li>授权密码：auth 123456</li></ul><h2 id="_103-redis哈希槽" tabindex="-1">103 redis哈希槽 <a class="header-anchor" href="#_103-redis哈希槽" aria-hidden="true">#</a></h2><ol><li>redis集群没有使用一致性hash，而是引入了哈希槽的概念，</li><li>redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置那个槽，</li><li>集群的每个节点负责一部分hash槽。</li></ol><h2 id="_104-redis集群的主从复制模型是怎样的" tabindex="-1">104 redis集群的主从复制模型是怎样的 <a class="header-anchor" href="#_104-redis集群的主从复制模型是怎样的" aria-hidden="true">#</a></h2><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型， 每个节点都会有N-1个复制品。</p><h2 id="_105-redis集群会有写操作丢失吗" tabindex="-1">105 redis集群会有写操作丢失吗 <a class="header-anchor" href="#_105-redis集群会有写操作丢失吗" aria-hidden="true">#</a></h2><p>redis并不能保证数据的强一致性，这意味着在实际中集群在特定的条件下可能会丢失写操作。</p><h2 id="_106-redis集群最大节点个数" tabindex="-1">106 redis集群最大节点个数 <a class="header-anchor" href="#_106-redis集群最大节点个数" aria-hidden="true">#</a></h2><p>16384个</p><h2 id="_107-redis集群如何选择数据库" tabindex="-1">107 redis集群如何选择数据库 <a class="header-anchor" href="#_107-redis集群如何选择数据库" aria-hidden="true">#</a></h2><p>redis集群目前无法做数据库选择，默认在0数据库</p><h2 id="_108-redis中管道" tabindex="-1">108 redis中管道 <a class="header-anchor" href="#_108-redis中管道" aria-hidden="true">#</a></h2><ol><li>一次请求/响应服务器能实现处理新的请求，即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，</li><li>而不用等待回复，最后一个步骤中读取该答复。这就是管道（pipelining）是一种几十年来广泛使用的技术，</li><li>许多POP3协议已经实现支持这个功能，加快了从服务器下载新邮件的过程。</li></ol><h2 id="_109-redis如何内存优化" tabindex="-1">109 redis如何内存优化 <a class="header-anchor" href="#_109-redis如何内存优化" aria-hidden="true">#</a></h2><ol><li>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，</li><li>你应该尽可能的将你的数据模型抽象到一个散列表里面 <ul><li>比如你的Web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的Key，</li><li>而是应该把这个用户的所有信息存储到一张散列表里面</li></ul></li></ol><h2 id="_110-redis回收进程如何工作" tabindex="-1">110 redis回收进程如何工作 <a class="header-anchor" href="#_110-redis回收进程如何工作" aria-hidden="true">#</a></h2><ol><li><p>一个客户端运行了新的命令，添加了新的数据 redis 检查内存使用的情况，如果大于 max memory 的限制，则根据设定好的策略进行回收</p></li><li><p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p><ul><li>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），</li><li>不用多久内存限制就会被这个内存使用量超越。</li></ul></li></ol><h2 id="_111-memcached" tabindex="-1">111 memcached <a class="header-anchor" href="#_111-memcached" aria-hidden="true">#</a></h2><p>通过在事先规划好的内存空间中临时缓存数据库中的各类数据， 以达到减少业务对数据库的直接高并发访问，从而达到提升数据库的访问性能，加速网站集群动态应用服务能力</p><h2 id="_112-memcached-工作原理" tabindex="-1">112 memcached 工作原理 <a class="header-anchor" href="#_112-memcached-工作原理" aria-hidden="true">#</a></h2><ol><li>完全基于内存缓存的</li><li>节点之间相互独立</li><li>c/s模式架构，c语言编写，总共2000行代码</li><li>异步i/o模型，使用libevent作为事件通知机制</li><li>被缓存的数据以key/value键值对形式存在</li><li>全部数据存放于内存中，无持久性存储的设计，重启服务器，内存的数据会丢失</li><li>当内存中缓存的数据容量达到启动时设定的内存值时，就自动使用LRU算法删除过期的缓存数据</li><li>可以对存储的数据设置过期事件，过期后数据自动清除，服务本身不会监控过期，而是在访问的时候查看key的时间戳，判断是否过期</li><li>对设定内存进行分块，再把块分组，然后再提供服务</li></ol><h2 id="_113-memcached如何处理容错" tabindex="-1">113 memcached如何处理容错 <a class="header-anchor" href="#_113-memcached如何处理容错" aria-hidden="true">#</a></h2><p>节点失效时，下面列出几种方案：</p><ol><li>忽略它，在失效节点被恢复或替换之前，还有很多其他节点可应对节点失效带来的影响</li><li>把失效的节点列表中移除，做这个操作千万小心。在默认情况下，客户端添加或移除节点，会导致所有的缓存数据不可用，因为哈希参照的节点列表变化了，大部分key会因为哈希值的改变而被映射到（原来）不同的节点上</li><li>启动热备节点，接管失效节点所占用的IP，这样可防止哈希紊乱</li><li>如果希望添加和移除节点，而不影响原先的哈希结果，可使用一致性哈希算法</li><li>两次哈希，当客户端存取数据时，如果发现一个节点down了，就再做一次哈希，重新选择另一个节点。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和坏的节点上都可能存在脏数据</li></ol><h2 id="_114-redis-同步机制" tabindex="-1">114 Redis 同步机制 <a class="header-anchor" href="#_114-redis-同步机制" aria-hidden="true">#</a></h2><ol><li>redis 可使用主从同步、从从同步，第一次同步时，主节点做一次bgsave，同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点。</li><li>复制节点接受完成后将rdb镜像加载到内存</li><li>加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ol><h2 id="_115-redis-cluster-原理" tabindex="-1">115 redis cluster 原理 <a class="header-anchor" href="#_115-redis-cluster-原理" aria-hidden="true">#</a></h2><ol><li><p>cluster中有一个16384长度的槽，编号0~16383，每个master节点都会负责一部分的槽，当有某个key被映射到某个master负责的槽，那么这个master负责这个key提供服务，至于哪个master负责哪个槽可以由用户指定，也可在初始化时候自动生成，只有master才拥有槽的使用权。</p></li><li><p>master节点维护着一个16384/8字节的位序列，master节点用bit来标识对于某个槽自己是否拥有。比如对于编号为1的槽，master只要判断序列的第二位是不是为1即可，这猴子那个结构很容易添加或者删除节点，比如：如果我想添加个节点D，我需要从节点A、B、C中得到部分槽到D上。</p></li></ol><h2 id="_116-redis实现分布式锁" tabindex="-1">116 redis实现分布式锁 <a class="header-anchor" href="#_116-redis实现分布式锁" aria-hidden="true">#</a></h2><ol><li>线程A setnx（上锁的对象，超时的时间戳t1），如果返回true，获得锁</li><li>线程B 用get获取t1，与当前时间戳比较，判断是否超时，没超时false，若超时执行第三步</li><li>计算新的超时时间t2，使用get/set命令返回t3，如果t1 == t3，获得锁，如果t1 != t3，说明锁被其它线程获取了</li><li>获取锁后，处理完业务逻辑，再去判断是否超时，如果没超过删除锁，如果已超时，不用处理（防止删除其它线程的锁）</li></ol><h2 id="_117-缓存穿透、击穿、雪崩" tabindex="-1">117 缓存穿透、击穿、雪崩 <a class="header-anchor" href="#_117-缓存穿透、击穿、雪崩" aria-hidden="true">#</a></h2><ol><li>缓冲穿透，指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都有去DB去查询，可能导致DB挂掉</li></ol><div class="tip custom-block"><p class="custom-block-title">缓存穿透解决方案</p><ul><li>查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短</li><li>布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对DB的查询</li></ul></div><ol start="2"><li>缓存击穿，对于设置了过期的key，缓存在某个时间点过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB压垮</li></ol><div class="tip custom-block"><p class="custom-block-title">缓存击穿解决方案</p><ul><li>使用互斥锁，当缓存失效时，不立即去load db，先使用如Redis的setnx去设置一个互斥锁，当操作成功返回时再进行load db的操作并回设缓存，否则重试get缓存的方法。</li><li>永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新）</li></ul></div><ol start="3"><li>缓存雪崩，设置缓存时采用了相同的过期时间，导致缓存在某一刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩</li></ol><div class="tip custom-block"><p class="custom-block-title">缓存雪崩解决方案</p><p>将缓存失效时间分散开，比如可在原有失效时间基础上增加随机值，比如1~5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的时间。</p></div><h2 id="_118-redis-数据量较大的查找" tabindex="-1">118 redis 数据量较大的查找 <a class="header-anchor" href="#_118-redis-数据量较大的查找" aria-hidden="true">#</a></h2><ol><li>假如 redis 里面有1亿个key，其中10w个key是某个固定的已知的前缀开头的，如何将它们全部找出来？</li></ol><blockquote><p>使用keys指令可以扫出指定模式的key列表</p></blockquote><ol start="2"><li>如果这个 redis 正在给线上的业务提供服务，那使用keys指令会有什么问题</li></ol><blockquote><p>redis的单线程的，keys指令会导致 线程阻塞一段时间，线上服务会停顿， 直到指令执行完毕，服务才能恢复，这个时候可以使用scan指令， scan指令可无阻塞的提取出指定模式的key列表， 但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体花费的时间会比直接使用keys指令长。</p></blockquote></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-16T01:45:19.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>