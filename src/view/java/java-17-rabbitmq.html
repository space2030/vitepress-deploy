<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>rabbitmq</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_view_java_java-17-rabbitmq.md.ed854218.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#_01-rabbitmq" data-v-2d325df8>01 rabbitmq</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-保证消息正确" data-v-2d325df8>02 保证消息正确</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-重复消费" data-v-2d325df8>03 重复消费</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-消息传输" data-v-2d325df8>04 消息传输</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_05-消息分发" data-v-2d325df8>05 消息分发</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-消费路由" data-v-2d325df8>06 消费路由</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-消息丢失" data-v-2d325df8>07 消息丢失</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-定义" data-v-2d325df8>08 定义</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-使用场景" data-v-2d325df8>09 使用场景</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-消息正确性" data-v-2d325df8>10 消息正确性</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-避免重复消费" data-v-2d325df8>11 避免重复消费</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-消息传输、分发、路由" data-v-2d325df8>12 消息传输、分发、路由</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-消息丢失" data-v-2d325df8>13 消息丢失</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-mq消息积压" data-v-2d325df8>14 mq消息积压</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-rabbitmq设置过期时间，部分消息丢失" data-v-2d325df8>15 RabbitMQ设置过期时间，部分消息丢失</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-rabbitmq上一个queue中存放的message是否有数量限制" data-v-2d325df8>16 RabbitMQ上一个queue中存放的message是否有数量限制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_17-如何保证地发送至rabbitmq-消息正确" data-v-2d325df8>17 如何保证地发送至RabbitMQ 消息正确</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_18-如何确保消息接收方消费了消息" data-v-2d325df8>18 如何确保消息接收方消费了消息</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_19-如何避免消息重复投递或重复消费" data-v-2d325df8>19 如何避免消息重复投递或重复消费</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_20-消息基于什么传输" data-v-2d325df8>20 消息基于什么传输</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_21-消息分发" data-v-2d325df8>21 消息分发</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_22-消息路由" data-v-2d325df8>22 消息路由</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_23-如何确保消息不丢失" data-v-2d325df8>23 如何确保消息不丢失</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_24-如何保证消息的顺序性" data-v-2d325df8>24 如何保证消息的顺序性</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_25-amqp" data-v-2d325df8>25 AMQP</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_26-生产者消息运转" data-v-2d325df8>26 生产者消息运转</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_27-消费者接收消息过程" data-v-2d325df8>27 消费者接收消息过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_28-导致死信的几种原因" data-v-2d325df8>28 导致死信的几种原因</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_29-rabbitmq-使用场景" data-v-2d325df8>29 RabbitMQ 使用场景</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_30-rabbitmq-角色" data-v-2d325df8>30 RabbitMQ 角色</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_31-rabbitmq-重要组件" data-v-2d325df8>31 RabbitMQ 重要组件</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_32-rabbitmq-中-vhost-的作用是什么？" data-v-2d325df8>32 RabbitMQ 中 vhost 的作用是什么？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_33-rabbitmq-的消息是怎么发送的？" data-v-2d325df8>33 RabbitMQ 的消息是怎么发送的？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_34-rabbitmq-怎么保证消息的稳定性？" data-v-2d325df8>34 RabbitMQ 怎么保证消息的稳定性？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_35-rabbitmq-避免消息丢失" data-v-2d325df8>35 RabbitMQ 避免消息丢失</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_36-要保证消息持久化成功的条件有哪些？" data-v-2d325df8>36 要保证消息持久化成功的条件有哪些？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_37-rabbitmq-持久化缺点" data-v-2d325df8>37 RabbitMQ 持久化缺点</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_38-rabbitmq-广播类型" data-v-2d325df8>38 RabbitMQ 广播类型</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_39-rabbitmq-怎么实现延迟消息队列？" data-v-2d325df8>39 RabbitMQ 怎么实现延迟消息队列？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_40-rabbitmq-集群" data-v-2d325df8>40 RabbitMQ 集群</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_41-rabbitmq-节点的类型" data-v-2d325df8>41 RabbitMQ 节点的类型</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_42-rabbitmq-集群搭建需要注意哪些问题？" data-v-2d325df8>42 RabbitMQ 集群搭建需要注意哪些问题？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_43-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" data-v-2d325df8>43 RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_44-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？" data-v-2d325df8>44 RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_45-rabbitmq-对集群节点停止顺序有要求吗？" data-v-2d325df8>45 RabbitMQ 对集群节点停止顺序有要求吗？</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_view_java_java-17-rabbitmq" data-v-3886f8ec><div><h1 id="rabbitmq" tabindex="-1">rabbitmq <a class="header-anchor" href="#rabbitmq" aria-hidden="true">#</a></h1><h2 id="_01-rabbitmq" tabindex="-1">01 rabbitmq <a class="header-anchor" href="#_01-rabbitmq" aria-hidden="true">#</a></h2><p>采用 AMQP 高级消息队列协议的一种消息队列技术，最大的特点就是消费并不需要确保提供方存在，实现了服务之间的高度解耦。</p><p>优点</p><ol><li>在分布式系统下具备异步，削峰，负载均衡等一系列高级功能。</li><li>拥有持久化的机制，进程消息，队列中的信息也可以保存下来。</li><li>实现消费者和生产者之间的解耦。</li><li>对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。</li><li>可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。</li></ol><p>缺点</p><ol><li>系统可用性降低。</li><li>系统复杂性提高。</li><li>一致性问题</li></ol><h2 id="_02-保证消息正确" tabindex="-1">02 保证消息正确 <a class="header-anchor" href="#_02-保证消息正确" aria-hidden="true">#</a></h2><p><strong>发送方确认模式</strong></p><ol><li>将信道设置成 confirm 模式（发送方确认模式，则所有在信道上发布的消息都会被指派一个唯一的 ID）。</li><li>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化消息），信道会发送一个确认给生产者（包含消息唯一 ID）。</li><li>如果 RabbitMQ 内部错误导致消息丢失，会发送一条 nack (not acknowledged，未确认）消息。</li><li>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。</li><li>当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</li></ol><p><strong>接收方确认机制</strong></p><ol><li>消息费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。</li><li>只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</li><li>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。</li><li>也就是说，只要连接不中断，RabbitMQ 给 Consumer 足够长的时间来处理消息，保证数据的最终一致性。</li></ol><div class="danger custom-block"><p class="custom-block-title">特殊情况</p><p>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。 （可能存在消息重复消费的隐患，需要去重）</p><p>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。</p></div><h2 id="_03-重复消费" tabindex="-1">03 重复消费 <a class="header-anchor" href="#_03-重复消费" aria-hidden="true">#</a></h2><ol><li>在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 inner-msg-id ，作为去重的依据（消费投递失败并重传），避免重复的消费进入队列。</li><li>在消息消费时，要求消息体中必须有一个 bizId （对于同一业务全局唯一，如支付 ID，订单 ID等）作为去重的依据，避免同一条消息被重复消费。</li></ol><h2 id="_04-消息传输" tabindex="-1">04 消息传输 <a class="header-anchor" href="#_04-消息传输" aria-hidden="true">#</a></h2><ol><li>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。</li><li>RabbitMQ 使用信道的方式来传输数据，信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</li></ol><h2 id="_05-消息分发" tabindex="-1">05 消息分发 <a class="header-anchor" href="#_05-消息分发" aria-hidden="true">#</a></h2><ol><li>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。</li><li>每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。</li><li>通过路由可实现多消费的功能。</li></ol><h2 id="_06-消费路由" tabindex="-1">06 消费路由 <a class="header-anchor" href="#_06-消费路由" aria-hidden="true">#</a></h2><ol><li>消息提供方 --&gt; 路由 --&gt; 一至多个队列</li><li>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。</li><li>通过队列路由键，可以把队列绑定到交换器上。</li><li>消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。</li></ol><div class="tip custom-block"><p class="custom-block-title">常用的交换器</p><p>fanout：如果交换器收到消息，将会广播到所有绑定的队列上</p><p>direct：如果路由键完全匹配，消息就被投递到相应的队列</p><p>topic：可以使来自不同源头的消息能够到达同一队列，使用 topic 交换器时，可以使用通配符。</p></div><h2 id="_07-消息丢失" tabindex="-1">07 消息丢失 <a class="header-anchor" href="#_07-消息丢失" aria-hidden="true">#</a></h2><ol><li>消息持久化，前提是队列必须持久化。</li><li>RabbitMQ 确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件。</li><li>当发布一条持久性消息到持久交换器上时，RabbitMQ 会在消息提交到日志文件后才发送响应。</li><li>一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ 会在持久化日志中把这条消息标记为等待垃圾收集。</li><li>如果持久化消息在被消费之前 RabbitMQ 重启，那么 RabbitMQ 会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件中的消息到合适的队列。</li></ol><h2 id="_08-定义" tabindex="-1">08 定义 <a class="header-anchor" href="#_08-定义" aria-hidden="true">#</a></h2><p>采用AMQP高级消息队列协议的一种消息队列技术，最大特点就是消费并不需要确保提供方存在，实现了服务之间的高度耦合。</p><h2 id="_09-使用场景" tabindex="-1">09 使用场景 <a class="header-anchor" href="#_09-使用场景" aria-hidden="true">#</a></h2><ol><li>服务间异步通信</li><li>顺序消费</li><li>定时任务</li><li>请求削峰</li></ol><h2 id="_10-消息正确性" tabindex="-1">10 消息正确性 <a class="header-anchor" href="#_10-消息正确性" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">发送方确认模式</p><blockquote><p>发送方确认模式</p></blockquote><ul><li><p>将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。</p></li><li><p>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。</p></li><li><p>如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息。</p></li><li><p>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p></li></ul></div><div class="tip custom-block"><p class="custom-block-title">接收方确认机制</p><blockquote><p>接收方确认机制</p></blockquote><ul><li><p>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要发送消息只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息，保证数据的最终一致性。</p></li><li><p><strong>特殊情况：</strong> 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）；如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。</p></li></ul></div><h2 id="_11-避免重复消费" tabindex="-1">11 避免重复消费 <a class="header-anchor" href="#_11-避免重复消费" aria-hidden="true">#</a></h2><ol><li><p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列。</p></li><li><p>在消息消费时，要求消息体中必须要有一个bizID（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重的依据，避免同一条消息被重复消费。</p></li></ol><h2 id="_12-消息传输、分发、路由" tabindex="-1">12 消息传输、分发、路由 <a class="header-anchor" href="#_12-消息传输、分发、路由" aria-hidden="true">#</a></h2><blockquote><p>消息传输</p></blockquote><ul><li><p>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，RabbitMQ使用信道的方式来传输数据。</p></li><li><p>信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p></li></ul><blockquote><p>消息分发</p></blockquote><ul><li>若该队列至少有一个消费者订阅，消息将以循环的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）</li></ul><blockquote><p>消息路由</p></blockquote><ul><li><p>消息提供方 --&gt; 路由 --&gt; 一至多个队列</p></li><li><p>消息发布到交换器时，消息将拥有一个路由键，在消息创建时设定。</p></li><li><p>通过队列路由键，可把队列绑定到交换器上。</p></li><li><p>消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）</p></li></ul><h2 id="_13-消息丢失" tabindex="-1">13 消息丢失 <a class="header-anchor" href="#_13-消息丢失" aria-hidden="true">#</a></h2><p>消息持久化解决</p><ul><li><p>RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit会在消息提交到日志文件后才发送响应。</p></li><li><p>一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前RabbitMQ重启，那么Rabbit会自动重建交换器和队列以及绑定，并重新发布持久化日志文件中消息到合适的队列。</p></li></ul><h2 id="_14-mq消息积压" tabindex="-1">14 mq消息积压 <a class="header-anchor" href="#_14-mq消息积压" aria-hidden="true">#</a></h2><ol><li>先修复consumer的问题，确保其恢复消费速度，将现有consumer都停掉</li><li>新建一个topic，partition是原来的10倍，临时建立好原先10倍或20倍的queue数量</li><li>写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据</li><li>消费之后不做耗时处理，直接均匀轮询写入临时建立好的10倍数量的queue</li><li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据</li><li>这种做法相当于临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据</li><li>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</li></ol><div class="tip custom-block"><p class="custom-block-title">总结</p><ol><li>修复并停掉consumer</li><li>新建一个topic，partition是原来的10倍，建立临时queue，数量是原来的10倍或20倍</li><li>写临时consumer程序，临时征用10倍的机器去消费数据</li><li>消费完成之后，恢复原先consumer</li></ol></div><h2 id="_15-rabbitmq设置过期时间，部分消息丢失" tabindex="-1">15 RabbitMQ设置过期时间，部分消息丢失 <a class="header-anchor" href="#_15-rabbitmq设置过期时间，部分消息丢失" aria-hidden="true">#</a></h2><p>采取批量重导方法：将丢失的那批数据查询导入到mq里面</p><h2 id="_16-rabbitmq上一个queue中存放的message是否有数量限制" tabindex="-1">16 RabbitMQ上一个queue中存放的message是否有数量限制 <a class="header-anchor" href="#_16-rabbitmq上一个queue中存放的message是否有数量限制" aria-hidden="true">#</a></h2><p>可认为是无限制的，限制取决于机器的内存，但是消息过多会导致处理效率下降</p><h2 id="_17-如何保证地发送至rabbitmq-消息正确" tabindex="-1">17 如何保证地发送至RabbitMQ 消息正确 <a class="header-anchor" href="#_17-如何保证地发送至rabbitmq-消息正确" aria-hidden="true">#</a></h2><ol><li>发送方确认模式：将信道设置confirm模式，则所有在信道上发布的消息都会被指派一个唯一的ID，一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）</li><li>如果RabbitMQ发送内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息</li><li>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可继续发送消息，当确认消息达到生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</li></ol><h2 id="_18-如何确保消息接收方消费了消息" tabindex="-1">18 如何确保消息接收方消费了消息 <a class="header-anchor" href="#_18-如何确保消息接收方消费了消息" aria-hidden="true">#</a></h2><ol><li>接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作），只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除</li><li>RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息，也就是说，只要连接不中断，RabbitMQ给Consumer足够长的时间来处理消息</li><li>特殊情况：如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizID去重）；如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ会认为该消费者繁忙，将不会给该消费者分发更多的消息。</li></ol><h2 id="_19-如何避免消息重复投递或重复消费" tabindex="-1">19 如何避免消息重复投递或重复消费 <a class="header-anchor" href="#_19-如何避免消息重复投递或重复消费" aria-hidden="true">#</a></h2><p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消费体中必须有一个bizId作为去重和幂等的依据，避免同一条消息被重复消费。</p><h2 id="_20-消息基于什么传输" tabindex="-1">20 消息基于什么传输 <a class="header-anchor" href="#_20-消息基于什么传输" aria-hidden="true">#</a></h2><ol><li>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，造成资源浪费，RabbitMQ使用信道的方式来传输数据，信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</li><li>RabbitMQ采用类似NIO做法，选择TCP连接复用，不仅可减少性能开销，同时也便于管理</li><li>每一个线程把持一个信道，所以信道复用了Connection的TCP连接，同时RabbitMQ可确保每个线程的私密性，像拥有独立连接一样。</li></ol><h1 id="rabbitmq-原理" tabindex="-1">rabbitmq 原理 <a class="header-anchor" href="#rabbitmq-原理" aria-hidden="true">#</a></h1><h2 id="_21-消息分发" tabindex="-1">21 消息分发 <a class="header-anchor" href="#_21-消息分发" aria-hidden="true">#</a></h2><p>若该队列至少有一个消费者订阅，消息将以循环的方式发送给消费者，每条消息只会分发给一个订阅的消费者</p><h2 id="_22-消息路由" tabindex="-1">22 消息路由 <a class="header-anchor" href="#_22-消息路由" aria-hidden="true">#</a></h2><ol><li>消息路由必须有三部分：交换器、路由、绑定。生产者把消息发布到交换器上，绑定决定了消息如何从交换器路由到特定队列，消息最终达到队列，并被消费者接收。</li><li>消息发布到交换器时，消息将拥有一个路由键，在消息创建时设定。</li><li>通过队列路由键，可把队列绑定到交换器上。</li><li>消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配。</li><li>如果能够匹配到队列，则消息会投递到相应队列中，如果不能匹配到任何队列，消息将进入“黑洞”。</li></ol><h2 id="_23-如何确保消息不丢失" tabindex="-1">23 如何确保消息不丢失 <a class="header-anchor" href="#_23-如何确保消息不丢失" aria-hidden="true">#</a></h2><ol><li>消息持久化的前提是：将交换器/队列的durable属性设置为true，表示交换器/队列是持久交换器/队列，在服务器崩溃或重启之后不需要创建交换器/队列（交换器/队列会自动创建）</li><li>如果消息想要从Rabbit崩溃中恢复，那么消息必须：</li></ol><ul><li>在消息发布前，通过它的“投递模式”选项设置为2（持久）来把消息标记成持久化</li><li>将消息发送到持久交换器</li><li>消息到达持久队列</li></ul><h2 id="_24-如何保证消息的顺序性" tabindex="-1">24 如何保证消息的顺序性 <a class="header-anchor" href="#_24-如何保证消息的顺序性" aria-hidden="true">#</a></h2><ul><li>通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中，然后只能用一个消费者去消费该队列。</li><li>可在消息体内添加全局有序标识来实现</li></ul><h2 id="_25-amqp" tabindex="-1">25 AMQP <a class="header-anchor" href="#_25-amqp" aria-hidden="true">#</a></h2><ol><li>RabbitMQ就是AMQP协议Erlang实现AMQP的模型架构和RabbitMQ的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定。</li><li>AMQP协议3层： <ul><li>a. Module Layer：协议最高层，主要定义了一些客户端调用的命令，客户端可用这些命令实现自己的业务逻辑</li><li>b. Session Layer：中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理</li><li>c. TransportLayer：最底层，主要传输二进制数据流，提供帧的处理，信道服用，错误检测和数据表示。</li></ul></li><li>AMQP模型组件 <ul><li>a. 交换器：消息代理服务器中用于把消息路由队列的组件</li><li>b. 队列：用来存储消息的数据结构，位于硬盘或内存中</li><li>c. 绑定：一套规则，告知交换器消息应该将消息投递给哪个队列</li></ul></li></ol><h2 id="_26-生产者消息运转" tabindex="-1">26 生产者消息运转 <a class="header-anchor" href="#_26-生产者消息运转" aria-hidden="true">#</a></h2><ol><li>Producer先连接到Broker，建立连接Connection开启一个信道Channel</li><li>Producer声明一个交换器并设置好相关属性</li><li>Producer声明一个队列并设置好相关属性</li><li>Producer通过路由键将交换器和队列绑定起来</li><li>Producer发送消息到Broker，其中包含路由键、交换器等信息</li><li>相应的交换器根据接收的路由键查找匹配的队列</li><li>如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者</li><li>关闭信道</li><li>管理连接</li></ol><h2 id="_27-消费者接收消息过程" tabindex="-1">27 消费者接收消息过程 <a class="header-anchor" href="#_27-消费者接收消息过程" aria-hidden="true">#</a></h2><ol><li>Producer先连接到Broker，建立连接Connection开启一个信道</li><li>向Broker请求消费响应的队列中消息，可能会设置响应的回调函数。</li><li>等待Broker回应并投递相应队列中的消息，接收消息</li><li>消费者确认收到的消息ack</li><li>RabbitMQ从队列中删除已经确定的消息</li><li>关闭信道</li><li>关闭连接</li></ol><h2 id="_28-导致死信的几种原因" tabindex="-1">28 导致死信的几种原因 <a class="header-anchor" href="#_28-导致死信的几种原因" aria-hidden="true">#</a></h2><ol><li>消息被拒（Basic.Reject/Basic.Nack）且requeue = false</li><li>消息TTL过期</li><li>队列满了，无法再添加</li></ol><h2 id="_29-rabbitmq-使用场景" tabindex="-1">29 RabbitMQ 使用场景 <a class="header-anchor" href="#_29-rabbitmq-使用场景" aria-hidden="true">#</a></h2><ul><li>抢购活动，削峰填谷，防止系统崩塌。</li><li>延迟信息处理，比如10 分钟之后给下单未付款的用户发送邮件提醒。</li><li>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</li></ul><h2 id="_30-rabbitmq-角色" tabindex="-1">30 RabbitMQ 角色 <a class="header-anchor" href="#_30-rabbitmq-角色" aria-hidden="true">#</a></h2><blockquote><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p></blockquote><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li><li>消费者：消息的接收方，用于处理数据和确认消息；</li><li>代理：就是RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h2 id="_31-rabbitmq-重要组件" tabindex="-1">31 RabbitMQ 重要组件 <a class="header-anchor" href="#_31-rabbitmq-重要组件" aria-hidden="true">#</a></h2><ul><li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li><li>Channel（信道）：消息推送使用的通道。</li><li>Exchange（交换器）：用于接受、分配消息。</li><li>Queue（队列）：用于存储生产者的消息。</li><li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li><li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li></ul><h2 id="_32-rabbitmq-中-vhost-的作用是什么？" tabindex="-1">32 RabbitMQ 中 vhost 的作用是什么？ <a class="header-anchor" href="#_32-rabbitmq-中-vhost-的作用是什么？" aria-hidden="true">#</a></h2><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机， 每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h2 id="_33-rabbitmq-的消息是怎么发送的？" tabindex="-1">33 RabbitMQ 的消息是怎么发送的？ <a class="header-anchor" href="#_33-rabbitmq-的消息是怎么发送的？" aria-hidden="true">#</a></h2><ol><li>首先客户端必须连接到RabbitMQ 服务器才能发布和消费消息， 客户端和 rabbit server 之间会创建一个 tcp 连接，</li><li>一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码）， 你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），</li><li>信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的， 每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</li></ol><h2 id="_34-rabbitmq-怎么保证消息的稳定性？" tabindex="-1">34 RabbitMQ 怎么保证消息的稳定性？ <a class="header-anchor" href="#_34-rabbitmq-怎么保证消息的稳定性？" aria-hidden="true">#</a></h2><ul><li>提供了事务的功能。</li><li>通过将channel 设置为 confirm（确认）模式。</li></ul><h2 id="_35-rabbitmq-避免消息丢失" tabindex="-1">35 RabbitMQ 避免消息丢失 <a class="header-anchor" href="#_35-rabbitmq-避免消息丢失" aria-hidden="true">#</a></h2><ul><li>把消息持久化磁盘，保证服务器重启消息不丢失。</li><li>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</li></ul><h2 id="_36-要保证消息持久化成功的条件有哪些？" tabindex="-1">36 要保证消息持久化成功的条件有哪些？ <a class="header-anchor" href="#_36-要保证消息持久化成功的条件有哪些？" aria-hidden="true">#</a></h2><ul><li>声明队列必须设置持久化durable 设置为 true.</li><li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li><li>消息已经到达持久化交换器。</li><li>消息已经到达持久化队列。</li></ul><blockquote><p>以上四个条件都满足才能保证消息持久化成功。</p></blockquote><h2 id="_37-rabbitmq-持久化缺点" tabindex="-1">37 RabbitMQ 持久化缺点 <a class="header-anchor" href="#_37-rabbitmq-持久化缺点" aria-hidden="true">#</a></h2><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。 可尽量使用ssd 硬盘来缓解吞吐量的问题。</p><h2 id="_38-rabbitmq-广播类型" tabindex="-1">38 RabbitMQ 广播类型 <a class="header-anchor" href="#_38-rabbitmq-广播类型" aria-hidden="true">#</a></h2><ul><li>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</li><li>headers：与 direct 类似，只是性能很差，此类型几乎用不到。</li><li>fanout：分发模式，把消费分发给所有订阅者。</li><li>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</li></ul><h2 id="_39-rabbitmq-怎么实现延迟消息队列？" tabindex="-1">39 RabbitMQ 怎么实现延迟消息队列？ <a class="header-anchor" href="#_39-rabbitmq-怎么实现延迟消息队列？" aria-hidden="true">#</a></h2><p>延迟队列的实现有两种方式：</p><ul><li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li><li>使用RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li></ul><h2 id="_40-rabbitmq-集群" tabindex="-1">40 RabbitMQ 集群 <a class="header-anchor" href="#_40-rabbitmq-集群" aria-hidden="true">#</a></h2><p>集群主要有以下两个用途：</p><ul><li>高可用：某个服务器出现问题，整个RabbitMQ 还可以继续使用；</li><li>高容量：集群可以承载更多的消息量。</li></ul><h2 id="_41-rabbitmq-节点的类型" tabindex="-1">41 RabbitMQ 节点的类型 <a class="header-anchor" href="#_41-rabbitmq-节点的类型" aria-hidden="true">#</a></h2><ul><li>磁盘节点：消息会存储到磁盘。</li><li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li></ul><h2 id="_42-rabbitmq-集群搭建需要注意哪些问题？" tabindex="-1">42 RabbitMQ 集群搭建需要注意哪些问题？ <a class="header-anchor" href="#_42-rabbitmq-集群搭建需要注意哪些问题？" aria-hidden="true">#</a></h2><ul><li>各节点之间使用“--link”连接，此属性不能忽略。</li><li>各节点使用的erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li><li>整个集群中必须包含一个磁盘节点。</li></ul><h2 id="_43-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" tabindex="-1">43 RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？ <a class="header-anchor" href="#_43-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" aria-hidden="true">#</a></h2><p>不是，原因有以下两个：</p><ul><li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li><li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li></ul><h2 id="_44-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？" tabindex="-1">44 RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？ <a class="header-anchor" href="#_44-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？" aria-hidden="true">#</a></h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><blockquote><p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p></blockquote><h2 id="_45-rabbitmq-对集群节点停止顺序有要求吗？" tabindex="-1">45 RabbitMQ 对集群节点停止顺序有要求吗？ <a class="header-anchor" href="#_45-rabbitmq-对集群节点停止顺序有要求吗？" aria-hidden="true">#</a></h2><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。 如果顺序恰好相反的话，可能会造成消息的丢失。</p></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-19T07:32:22.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>