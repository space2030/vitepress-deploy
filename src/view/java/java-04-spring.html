<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Spring</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_view_java_java-04-spring.md.294e3736.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#_01-定义" data-v-2d325df8>01 定义</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-控制反转及依赖注入" data-v-2d325df8>02 控制反转及依赖注入</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-配置方式" data-v-2d325df8>03 配置方式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-生命周期" data-v-2d325df8>04 生命周期</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-启动过程" data-v-2d325df8>06 启动过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-注解" data-v-2d325df8>07 注解</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-http请求过来springmvc是怎么处理的" data-v-2d325df8>08 http请求过来springMVC是怎么处理的</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-视图解析器怎么解析的" data-v-2d325df8>09 视图解析器怎么解析的</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-注解实现的原理" data-v-2d325df8>10 注解实现的原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-spring循环依赖" data-v-2d325df8>11 spring循环依赖</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-spring-bean-生命周期" data-v-2d325df8>12 spring bean 生命周期</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-spring容器启动流程" data-v-2d325df8>13 spring容器启动流程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-beanfactory和applicationcontext有什么区别" data-v-2d325df8>14 BeanFactory和ApplicationContext有什么区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-spring基于xml文件注入bean的方式" data-v-2d325df8>15 spring基于xml文件注入bean的方式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-spring的自动装配" data-v-2d325df8>16 spring的自动装配</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_17-spring-aop" data-v-2d325df8>17 Spring AOP</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_18-springmvc如何将纯文本的http协议的请求转化为java对象的？" data-v-2d325df8>18 SpringMVC如何将纯文本的Http协议的请求转化为Java对象的？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_19-spring中的单例beans是线程安全的么" data-v-2d325df8>19 Spring中的单例Beans是线程安全的么</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_20-transactional-失效场景" data-v-2d325df8>20 @Transactional 失效场景</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_21-实现-ioc-容器" data-v-2d325df8>21 实现 IOC 容器</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_22-aop" data-v-2d325df8>22 AOP</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_23-bean-生命周期" data-v-2d325df8>23 bean 生命周期</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_24-spring框架中使用了哪些设计模式" data-v-2d325df8>24 spring框架中使用了哪些设计模式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_25-spring事务的实现方式原理是什么？" data-v-2d325df8>25 spring事务的实现方式原理是什么？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_26-spring事务的隔离级别有哪些？" data-v-2d325df8>26 spring事务的隔离级别有哪些？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_27-spring的事务传播机制是什么？" data-v-2d325df8>27 spring的事务传播机制是什么？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_28-spring事务什么时候会失效？" data-v-2d325df8>28 spring事务什么时候会失效？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_29-springmvc运行流程" data-v-2d325df8>29 springmvc运行流程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_30-springmvc的九大组件有哪些？" data-v-2d325df8>30 springmvc的九大组件有哪些？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_31-autowired-resource" data-v-2d325df8>31 @Autowired @Resource</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_32-spring-mvc" data-v-2d325df8>32 Spring MVC</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_33-spring-aop" data-v-2d325df8>33 Spring AOP</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_34-spring-ioc" data-v-2d325df8>34 Spring IOC</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_35-applicationcontext-vs-beanfactory" data-v-2d325df8>35 ApplicationContext vs BeanFactory</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_36-循环依赖" data-v-2d325df8>36 循环依赖</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_37-事务" data-v-2d325df8>37 事务</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_view_java_java-04-spring" data-v-3886f8ec><div><h1 id="spring" tabindex="-1">Spring <a class="header-anchor" href="#spring" aria-hidden="true">#</a></h1><p>Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成。</p><h2 id="_01-定义" tabindex="-1">01 定义 <a class="header-anchor" href="#_01-定义" aria-hidden="true">#</a></h2><ol><li><p>一个为了JAVA应用程序的开发提供了综合. 广泛的基础性支持的JAVA平台。</p></li><li><p>主要模块：核心容器. 数据访问/集成. 面向切面编程. 工具. 消息和测试模块。</p></li></ol><h2 id="_02-控制反转及依赖注入" tabindex="-1">02 控制反转及依赖注入 <a class="header-anchor" href="#_02-控制反转及依赖注入" aria-hidden="true">#</a></h2><ul><li><p>控制反转</p><ul><li>Spring框架管理这些Bean的创建工作，即由方式管理Bean转变为框架管理Bean。</li><li>控制反转是一种设计思想。</li></ul></li><li><p>依赖注入</p><ul><li>由容器动态的将某个依赖关系注入到组件之中。</li><li>依赖注入是实现方式。</li><li>三种实现方式：构造器注入. Setter方法注入. 接口注入。</li></ul></li></ul><h2 id="_03-配置方式" tabindex="-1">03 配置方式 <a class="header-anchor" href="#_03-配置方式" aria-hidden="true">#</a></h2><ul><li>应用开发中有三种方式 <ul><li>基于XML配置</li><li>基于注解的配置</li><li>基于JAVA代码的配置</li></ul></li></ul><h2 id="_04-生命周期" tabindex="-1">04 生命周期 <a class="header-anchor" href="#_04-生命周期" aria-hidden="true">#</a></h2><blockquote><p>四个阶段：实例化. 属性赋值. 初始化. 销毁。</p></blockquote><ol><li>实例化<div class="tip custom-block"><p class="custom-block-title">实例化</p></div></li></ol><ul><li>首先Spring通过BeanDefinitionReader会将XML. JAVA类型的配置文件解析为BeanDefinition类型注册到容器中。BeanDefinition实际上是用来存储class信息的对象。它里面包含了一个类的基本信息. 类的父类信息. 是否懒加载. 是否为单例等等</li><li>根据BeanDefinition中指定的class信息，以及构造器信息最终通过反射获取到BeanDefinition的实例对象（注意此时还不是一个bean，经过后续的一些操作才会变成一个完整的Bean）。</li><li>判断对象是否允许循环依赖，是否需要AOP，属性注入</li><li>判断是否需要暴露，需要的话会将一个objectFactory对象存入一个二级缓存中</li><li>Spring Bean的实例化完成，加入到Spring 的单例缓冲池中（一个Map）。 :::</li></ul><ol start="2"><li>属性赋值。调用 set 方法设置属性值</li><li>初始化。调用 init-method 进行 Bean 的初始化，主要用于项目的一些依赖（配置文件或数据库连接等等）。</li><li>销毁Bean。destroy-method 方法进行 Bean 的销毁。</li></ol><h3 id="_05-是否线程安全" tabindex="-1">05 是否线程安全 <a class="header-anchor" href="#_05-是否线程安全" aria-hidden="true">#</a></h3><ul><li><p>不是线程安全的，对于单例Bean，所有线程都共享一个单例实例Bean，存在资源竞争。</p></li><li><p>但是如果单例Bean，是一个无状态Bean，也就是线程中操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean的线程是安全的。</p></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</li><li>实际上大部分时候spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，</li><li>但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，</li><li>最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，</li><li>所以就可以保证线程安全了。</li></ol><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul></div><h2 id="_06-启动过程" tabindex="-1">06 启动过程 <a class="header-anchor" href="#_06-启动过程" aria-hidden="true">#</a></h2><ul><li><p>Spring启动过程是IOC容器的启动过程，本质是创建和初始化BeanFactory，Spring使用BeanFactory来实例化. 配置和管理Bean。</p></li><li><p>对于WEB程序，IOC容器启动过程即是建立上下文的过程，WEB容器会提供一个全局的servletContext上下文环境。</p></li><li><p>容器的启动过程可分两大步：一. 获取. 解析注册配置信息，将配置的文件信息转换Map&lt;name, beanDefinition&gt;；二. 根据Map&lt;name, beanDefinition&gt;去实例化bean，并完成注入。</p></li></ul><h2 id="_07-注解" tabindex="-1">07 注解 <a class="header-anchor" href="#_07-注解" aria-hidden="true">#</a></h2><ul><li>传参注解 @RequestParam</li></ul><ol><li>处理别名 @RequestParam(&quot;pwd&quot;) String password</li><li>@RequestParam(value = &quot;pwd&quot;, required = false) 表示参数可选</li><li>参数是对象时，不建议加注解 @RequestParam ，加注解表示必传，只要变量名一致即可获取。</li><li>参数是数组时，对同一个参数赋多个值，多个值之间用逗号隔开：如 URL?param=value1,value2,value3</li></ol><ul><li>路径参数注解 @PathVariable</li></ul><ol><li>路径传参方式是将参数直接包含在 URL 路径中，比如 URL/paramValue1/paramValue2</li></ol><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#C9D1D9;">@</span><span style="color:#FF7B72;">RequestMapping</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;pathTest/{id}/{name}&quot;</span><span style="color:#C9D1D9;">)</span></span>
<span class="line"><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> String </span><span style="color:#D2A8FF;">pathTest</span><span style="color:#C9D1D9;">(@</span><span style="color:#FF7B72;">PathVariable</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;id&quot;</span><span style="color:#C9D1D9;">) String id , @</span><span style="color:#FF7B72;">PathVariable</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;name&quot;</span><span style="color:#C9D1D9;">) String name) {</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>传入的参数是文件</li></ul><ol><li>postman form-data ==&gt; KEY = file, VALUE = 文件</li></ol><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#C9D1D9;">@</span><span style="color:#FF7B72;">PostMapping</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;upload&quot;</span><span style="color:#C9D1D9;">)</span></span>
<span class="line"><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> String </span><span style="color:#D2A8FF;">uploadFile</span><span style="color:#C9D1D9;">(@</span><span style="color:#FF7B72;">RequestParam</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;file) MultipartFile myFile) {</span></span>
<span class="line"><span style="color:#A5D6FF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li><p>注解 @RequestBody POST请求. JSON格式. 变量名与属性名对应</p></li><li><p>传递集合</p></li></ul><div class="tip custom-block"><p class="custom-block-title">混合使用</p><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> String </span><span style="color:#D2A8FF;">pathAndBody</span><span style="color:#C9D1D9;">(@</span><span style="color:#FF7B72;">PathVariable</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;index&quot;</span><span style="color:#C9D1D9;">) Integer index, @</span><span style="color:#FF7B72;">RequestBody</span><span style="color:#C9D1D9;"> User user) {</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span></code></pre></div></div><h2 id="_08-http请求过来springmvc是怎么处理的" tabindex="-1">08 http请求过来springMVC是怎么处理的 <a class="header-anchor" href="#_08-http请求过来springmvc是怎么处理的" aria-hidden="true">#</a></h2><ol><li>请求被Spring前端控制器DispatcherServlet捕获。</li><li>DispatcherServlet对请求URL进行解析（核心方法doDispatch()），得到请求资源标识符（URI）然后根据该URI，调用HandlerMapping获得该Handler（Controller）配置的所有相关的对象。</li><li>DispacherServlet根据获得的Handler，选择一个合适的HandlerAdapter（执行目标方法的反射工具）</li><li>提取Request中的模型数据，填充Handler入参，开始执行Handler</li><li>Controller -&gt; Service -&gt; Dao查询到数据</li><li>Controller执行完成后，向DispatcherServlet返回一个ModelAndView对象</li><li>根据返回的ModelAndView，选择一个适合的ViewResolver（视图解析器）</li><li>ViewResolver结合Model和View，来渲染视图</li><li>由DispatcherServlet响应给客户端</li></ol><h2 id="_09-视图解析器怎么解析的" tabindex="-1">09 视图解析器怎么解析的 <a class="header-anchor" href="#_09-视图解析器怎么解析的" aria-hidden="true">#</a></h2><ol><li>任何方法的返回值最终都会封装为ModelAndView对象</li><li>viewResolver的唯一作用是根据ModelAndView得到view对象，视图对象才能真正的转发或者重定向到页面（并将模型中的数据暴露到请求域中）</li><li>视图对象是真正进行视图渲染的，调用view的方法：render（ModelAndView，request，response）进行页面渲染</li><li>根据view的种类不同它渲染出来的视图也不相同。一般我们使用的都是InternalResourceView视图</li></ol><h2 id="_10-注解实现的原理" tabindex="-1">10 注解实现的原理 <a class="header-anchor" href="#_10-注解实现的原理" aria-hidden="true">#</a></h2><p>Annotation其实是一种接口。通过java的反射机制相关的API来访问Annotation信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。</p><h2 id="_11-spring循环依赖" tabindex="-1">11 spring循环依赖 <a class="header-anchor" href="#_11-spring循环依赖" aria-hidden="true">#</a></h2><p>多个bean之间的互相引用，导致一个闭环的出现 采用三级缓存模式来解决循环依赖问题 singletonFactories：// 单例对象工厂的cache earlySingletonObjects：// 提前曝光的单例对象的Cache singletonObjects：// 单例对象的cache 构造器注入导致的循环依赖无法解决 假设现在有两个bean X Y互相依赖，且都是单例的，X开始生命周期后直到X通过构造器以及创建对象后，会有一个暴露阶段，此时会将X的一个ObjectFactory对象暴露出去并存入二级缓存中。然后会进行X的属性注入，这是会将Y注入，但是还没有Y，然后进入到Y bean的生命周期。一直到Y暴露出自己的ObjectFactory对象暴露出去并存入二级缓存中后，Y进行依赖注入，需要注入X，然后二级缓存中有X的一个对应的工厂对象。 至此完成了循环依赖，需要注意的是此过程仅适用于由于属性注入引起的循环依赖，对于由于构造器注入引起的循环依赖不能解决，原因是ObjectFactory对象是在根据构造器通过反射创建对象后才产生的。对于构造器注入引起的循环依赖无法起作用。</p><h2 id="_12-spring-bean-生命周期" tabindex="-1">12 spring bean 生命周期 <a class="header-anchor" href="#_12-spring-bean-生命周期" aria-hidden="true">#</a></h2><ul><li>实例化 a. 首先spring通过BeanDefinitionReader会将xml. java类型的配置文件解析为BeanDefinition类型注册到容器中。BeanDefinition实际上是用来存储class信息的对象。它里面包含了一个类的基本信息. 类的父类信息. 是否懒加载. 是否为单例等等。beanDefinition定义了bean的基本信息，根据它来创造bean，然后&lt;BeanDefinition，beanName&gt;分别作为&lt;value，key&gt;存入一个map中，这个map是存在于BeanFactory中的。</li></ul><p>b. BeanDefinition会转化为mergeBeanDefinition，其中包括了BeanDefinition以及parentBeanDefinition的信息。</p><p>c. 配置BeanDefinition的depends-on BeanDefinition d. 根据BeanDefinition中指定的class信息，以及构造器信息最终通过反射获取到BeanDefinition的实例对象（注意此时还不是一个bean，经过后续的一些操作才会变成一个完整的bean） e. 判断对象是否允许循环依赖？是否需要AOP，属性注入。 f. 判断是否需要暴露，需要的话会将一个objectFactory对象存入一个二级缓存中。 g. spring bean的实例化完成，加入到spring的单例缓冲池中（一个map）</p><ul><li><p>初始化 ○ 调用init-method进行bean的初始化，主要用于项目的一些依赖（配置文件或者数据库连接等等）</p></li><li><p>销毁bean ○ destory-method方法进行bean的销毁。</p></li></ul><h2 id="_13-spring容器启动流程" tabindex="-1">13 spring容器启动流程 <a class="header-anchor" href="#_13-spring容器启动流程" aria-hidden="true">#</a></h2><ol><li>将配置文件加载为BeanDefinition并注册到容器中，这一步需要XmlBeanDefinitionReader的配合。</li><li>注册BeanFactoryPostProcesser，包含一个可以传入beanFactory引用的方法，获取到容器之后可以做很多事情。由于BeanFactoryPostProcesser工作在bean实例化之前，所以可以通过beanFactory获取到map，从而手动修改或者移除beanDefinition</li><li>注册BeanPostProcesser，工作于bean实例化或者初始化前后，其包含两个方法。</li></ol><div class="tip custom-block"><p class="custom-block-title">spring作为扩展接口留给开发人员使用的</p><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">interface</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">BeanPostProcessor</span><span style="color:#C9D1D9;"> {</span></span>
<span class="line"><span style="color:#C9D1D9;">   </span><span style="color:#8B949E;">// 在初始化之前调用</span></span>
<span class="line"><span style="color:#C9D1D9;">   Object </span><span style="color:#D2A8FF;">postProcessBeforeInitialization</span><span style="color:#C9D1D9;">(Object </span><span style="color:#FFA657;">bean</span><span style="color:#C9D1D9;">, String </span><span style="color:#FFA657;">beanName</span><span style="color:#C9D1D9;">) </span><span style="color:#FF7B72;">throws</span><span style="color:#C9D1D9;"> BeansException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">   </span><span style="color:#8B949E;">// 在初始化之后调用</span></span>
<span class="line"><span style="color:#C9D1D9;">   Object </span><span style="color:#D2A8FF;">postProcessAfterInitialization</span><span style="color:#C9D1D9;">(Object </span><span style="color:#FFA657;">bean</span><span style="color:#C9D1D9;">, String </span><span style="color:#FFA657;">beanName</span><span style="color:#C9D1D9;">) </span><span style="color:#FF7B72;">throws</span><span style="color:#C9D1D9;"> BeansException;</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span></code></pre></div></div><ol start="4"><li>创建事件传播器对象</li><li>beanDefinition实例化</li></ol><h2 id="_14-beanfactory和applicationcontext有什么区别" tabindex="-1">14 BeanFactory和ApplicationContext有什么区别 <a class="header-anchor" href="#_14-beanfactory和applicationcontext有什么区别" aria-hidden="true">#</a></h2><ol><li>BeanFactory：是Spring里面最底层的接口，提供了最简单的容器的功能，包含了各种Bean的定义，读取bean配置文件，管理bean的加载，实例化，控制bean的生命周期. 维护bean之间的依赖关系等等</li><li>ApplicationContext：继承了BeanFactory接口。是spring中更高一级的容器。提供了比BeanFactory更多的功能。</li></ol><p>区别： BeanFactory采用懒加载形式注入bean，ApplicationContext在容器启动时一次性创建所有bean，这样在容器启动时就可以发现spring中存在的配置错误。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean，确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><h2 id="_15-spring基于xml文件注入bean的方式" tabindex="-1">15 spring基于xml文件注入bean的方式 <a class="header-anchor" href="#_15-spring基于xml文件注入bean的方式" aria-hidden="true">#</a></h2><ol><li><p>bean的作用域默认为单例的，可以通过xml文件中的scope标签来做更改，如原型模式. request. session。</p></li><li><p>构造器注入：无参构造器注入，有参构造器注入</p></li><li><p>set方法注入：要求被注入的属性必须有set方法</p></li></ol><h2 id="_16-spring的自动装配" tabindex="-1">16 spring的自动装配 <a class="header-anchor" href="#_16-spring的自动装配" aria-hidden="true">#</a></h2><p>spring自动将某个bean的引用装配给了指定属性，这一个过程叫做自动装配。</p><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#8B949E;">// 无需自动装配</span></span>
<span class="line"><span style="color:#FF7B72;">int</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">AUTOWIRE_NO</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">0</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#8B949E;">// 按名称自动装配bean属性</span></span>
<span class="line"><span style="color:#FF7B72;">int</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">AUTOWIRE_BY_NAME</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">1</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#8B949E;">// 按类型自动装配bean属性</span></span>
<span class="line"><span style="color:#FF7B72;">int</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">AUTOWIRE_BY_TYPE</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">2</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#8B949E;">// 按构造器自动装配</span></span>
<span class="line"><span style="color:#FF7B72;">int</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">AUTOWIRE_CONSTRUCTOR</span><span style="color:#FFA657;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">3</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#8B949E;">// 过时方法，Spring3.0之后不再支持</span></span>
<span class="line"></span></code></pre></div><p>上面介绍的是基于xml配置文件的自动装配过程。 基于注解的自动装配： @Autowired注解可以实现bean的自动装配。默认是按照类型进行装配的。但是如果匹配到同一个类型的多个实例，再通过byName来确定要装配的bean</p><h2 id="_17-spring-aop" tabindex="-1">17 Spring AOP <a class="header-anchor" href="#_17-spring-aop" aria-hidden="true">#</a></h2><ul><li><p>AOP意为面向切面编程，与OOP一样。是一种编程理念，</p></li><li><p>如果把OOP看作是自上而下的层层抽象，那么AOP就是从左至右的相同功能模块的抽取和封装。</p></li><li><p>开发中使用AOP可以大大减少冗余代码，降低模块之间的耦合度，并且有利于未来的扩展性</p></li><li><p>AspectJ是AOP的一种实现</p><div class="tip custom-block"><p class="custom-block-title">概念</p></div></li><li><p>切入点（Pointcut）在哪些方法上切入</p></li><li><p>通知（Advice）在方法执行的时机做什么</p></li><li><p>切面（Aspect） 切面 = 切入点 + 通知，通俗点就是：在什么时机，什么地方，做什么增强</p><ul><li>织入 把切面加入到对象，并创建出代理对象的过程 举例 @Component(&quot;landlord&quot;) public class Landlord { // 下面方法是连接点 public void service() { // 仅仅只是实现了核心的业务功能 System.out.println(&quot;签合同&quot;); System.out.println(&quot;收房租&quot;); } }</li></ul><p>@Component // 标识为一个Bean @Aspect // 标识为一个切面 class Broker { // 前置通知，表示在连接点方法之前执行 // 定义了 execution的正则表达式，Spring通过这个正则表达式判断具体要拦截的是哪一类的哪一个方法 @Before(&quot;execution(* pojo.Landlord.service())&quot;) public void before() { System.out.println(&quot;带租客看房&quot;); System.out.println(&quot;谈价格&quot;); }</p><pre><code>// 后置通知，表示在切入点方法之后执行
@After(&quot;execution(* pojo.Landlord.service())&quot;)
public void after() {
    System.out.println(&quot;交钥匙&quot;);
}
</code></pre><p>} :::</p></li></ul><h2 id="_18-springmvc如何将纯文本的http协议的请求转化为java对象的？" tabindex="-1">18 SpringMVC如何将纯文本的Http协议的请求转化为Java对象的？ <a class="header-anchor" href="#_18-springmvc如何将纯文本的http协议的请求转化为java对象的？" aria-hidden="true">#</a></h2><ol><li>利用HttpMessageConverter的实现类将http的请求转化为Java对象的。</li><li>同时，响应的时候还可以利用HttpMessageConverter的实现类将Java对象转化为http响应的格式。</li></ol><h2 id="_19-spring中的单例beans是线程安全的么" tabindex="-1">19 Spring中的单例Beans是线程安全的么 <a class="header-anchor" href="#_19-spring中的单例beans是线程安全的么" aria-hidden="true">#</a></h2><ol><li>不是线程安全的，对于单例Bean，所有线程都共享一个单例实例Bean，因此是存在资源的竞争。</li><li>但如果单例Bean，是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean的线程安全的。</li><li>SpringMVC的Controller. Service. Dao等，这些Bean大多是无状态的，只关注于方法本身。</li></ol><h2 id="_20-transactional-失效场景" tabindex="-1">20 @Transactional 失效场景 <a class="header-anchor" href="#_20-transactional-失效场景" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">代理不生效</p><p>spring中注解都是基于代理来实现的</p><ul><li><p><strong>将注解标注在接口方法上</strong> @Transactional是支持标注在方法与类上的，一旦标注在接口上，对应接口实现类的代理方式如果是CGLIB，将通过生成子类的方式生成目标类的代理，将无法解析到@Transcational，从而事务失效。</p></li><li><p><strong>被final. static关键字修饰的类或方法</strong> CGLIB是通过生成目标子类的方式生成代理类的，被final. static修饰后，无法继承父类方法。</p></li><li><p><strong>类方法内部调用</strong> 事务管理是通过代理执行的方式生效的，如果是方法内部调用，将不会走代理逻辑，也就调用不到了。</p></li><li><p><strong>当前类没有被Spring管理</strong> 无法被事务切面代理</p></li></ul></div><div class="tip custom-block"><p class="custom-block-title">框架或底层不支持</p><ol><li>不支持非public修饰的方法进行事务管理。</li><li>多线程调用。事务信息是跟线程绑定的，因此在多线程环境下，事务的信息都是独立的，将会导致Spring在接管事务上出现差异。</li><li>数据库本身不支持事务。MySQL的MyISAM储存引擎是不支持事务的。</li><li>未开启事务。</li></ol></div><div class="tip custom-block"><p class="custom-block-title">错误的使用@Transactional</p><ul><li><p><strong>错误的传播机制</strong> Spring支持7种传播机制</p><ul><li>required（Spring的默认事务传播类型）：如果当前没有事务，则自己新建一个事务，如果当前存在事务则加入这个事务。</li><li>supports：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行。</li><li>mandatory：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</li><li>require_new：创建一个新事务，如果存在当前事务，则挂起该事务。</li><li>not_supported：以非事务方式执行，如果当前存在事务，则挂起当前事务。</li><li>never：如果当前没有事务存在，就以非事务方式执行；如果有，就抛出异常，就是B从不以事务方式运行A中不能有事务，如果没有，B就以非事务方式执行，如果A存在事务，那么直接抛异常。</li><li>nested：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样开启一个事务，如果A中没有事务，那么B创建一个事务执行，如果A中也有事务，那么B会把事务嵌套在里面。</li></ul></li><li><p><strong>rollbackFor属性设置错误</strong> 默认情况下事务仅回滚运行时异常和Error，不回滚受检查异常。 如果方法中抛出了IO异常，默认情况下事务也会回滚失败。 可以通过指定@Transactional(rollbackFor = Exception.class的方式进行全异常捕获。</p></li><li><p><strong>异常被程序内部catch</strong> 如果需要对特定的异常进行捕获处理，记得再次将异常抛出，让最外层的事务感知到。</p></li><li><p><strong>嵌套事务</strong></p></li></ul></div><h2 id="_21-实现-ioc-容器" tabindex="-1">21 实现 IOC 容器 <a class="header-anchor" href="#_21-实现-ioc-容器" aria-hidden="true">#</a></h2><ol><li>先准备一个基本的容器对象，包含一些map结构的集合，用来方便后续过程中存储具体的对象</li><li>进行配置文件的读取工作或者注解的解析工作，将需要创建的bean对象都封装成BeanDefinition对象存储在容器中</li><li>容器将封装好的BeanDefinition对象通过反射的方式进行实例化，完成对象的实例化工作</li><li>进行对象的初始化操作，也就是给类中的对应属性值就行设置，也就是进行依赖注入，完成整个对象的创建，变成一个完整的bean对象，存储在容器的某个map结构中</li><li>通过容器对象来获取对象，进行对象的获取和逻辑处理工作</li><li>提供销毁操作，当对象不用或者容器关闭的时候，将无用的对象进行销毁</li></ol><h2 id="_22-aop" tabindex="-1">22 AOP <a class="header-anchor" href="#_22-aop" aria-hidden="true">#</a></h2><p>AOP全称叫做 Aspect Oriented Programming 面向切面编程。它是为解耦而生的，解耦是程序员编码开发过程中一直追求的境界，AOP在业务类的隔离上，绝对是做到了解耦，在这里面有几个核心的概念：</p><ul><li>切面（Aspect）: 指关注点模块化，这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中，切面可以使用通用类基于模式的方式（schema-based approach）或者在普通类中以<code>@Aspect</code>注解来实现。</li><li>连接点（Join point）: 在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中，一个连接点总是代表一个方法的执行。</li><li>通知（Advice）: 在切面的某个特定的连接点上执行的动作。通知有多种类型，包括“around”, “before” and “after”等等。通知的类型将在后面的章节进行讨论。 许多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。</li><li>切点（Pointcut）: 匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如，当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP的核心：Spring默认使用AspectJ切点语义。</li><li>引入（Introduction）: 声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被通知的对象上。例如，可以使用引入来使bean实现 <code>IsModified</code>接口， 以便简化缓存机制（在AspectJ社区，引入也被称为内部类型声明（inter））。</li><li>目标对象（Target object）: 被一个或者多个切面所通知的对象。也被称作被通知（advised）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个被代理（proxied）的对象。</li><li>AOP代理（AOP proxy）:AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。</li><li>织入（Weaving）: 把切面连接到其它的应用程序类型或者对象上，并创建一个被被通知的对象的过程。这个过程可以在编译时（例如使用AspectJ编译器）. 类加载时或运行时中完成。 Spring和其他纯Java AOP框架一样，是在运行时完成织入的。这些概念都太学术了，如果更简单的解释呢，其实非常简单：任何一个系统都是由不同的组件组成的，每个组件负责一块特定的功能，当然会存在很多组件是跟业务无关的，例如日志. 事务. 权限等核心服务组件，这些核心服务组件经常融入到具体的业务逻辑中，如果我们为每一个具体业务逻辑操作都添加这样的代码，很明显代码冗余太多，因此我们需要将这些公共的代码逻辑抽象出来变成一个切面，然后注入到目标对象（具体业务）中去，AOP正是基于这样的一个思路实现的，通过动态代理的方式，将需要注入切面的对象进行代理，在进行调用的时候，将公共的逻辑直接添加进去，而不需要修改原有业务的逻辑代码，只需要在原来的业务逻辑基础之上做一些增强功能即可。</li></ul><h2 id="_23-bean-生命周期" tabindex="-1">23 bean 生命周期 <a class="header-anchor" href="#_23-bean-生命周期" aria-hidden="true">#</a></h2><ol><li><p>实例化bean对象</p><p>通过反射的方式进行对象的创建，此时的创建只是在堆空间中申请空间，属性都是默认值</p></li><li><p>设置对象属性</p><p>给对象中的属性进行值的设置工作</p></li><li><p>检查Aware相关接口并设置相关依赖</p><p>如果对象中需要引用容器内部的对象，那么需要调用aware接口的子类方法来进行统一的设置</p></li><li><p>BeanPostProcessor的前置处理</p><p>对生成的bean对象进行前置的处理工作</p></li><li><p>检查是否是InitializingBean的子类来决定是否调用afterPropertiesSet方法</p><p>判断当前bean对象是否设置了InitializingBean接口，然后进行属性的设置等基本工作</p></li><li><p>检查是否配置有自定义的init-method方法</p><p>如果当前bean对象定义了初始化方法，那么在此处调用初始化方法</p></li><li><p>BeanPostProcessor后置处理</p><p>对生成的bean对象进行后置的处理工作</p></li><li><p>注册必要的Destruction相关回调接口</p><p>为了方便对象的销毁，在此处调用注销的回调接口，方便对象进行销毁操作</p></li><li><p>获取并使用bean对象</p><p>通过容器来获取对象并进行使用</p></li><li><p>是否实现DisposableBean接口</p><p>判断是否实现了DisposableBean接口，并调用具体的方法来进行对象的销毁工作</p></li><li><p>是否配置有自定义的destory方法</p><p>如果当前bean对象定义了销毁方法，那么在此处调用销毁方法</p></li></ol><h2 id="_24-spring框架中使用了哪些设计模式" tabindex="-1">24 spring框架中使用了哪些设计模式 <a class="header-anchor" href="#_24-spring框架中使用了哪些设计模式" aria-hidden="true">#</a></h2><p>1.工厂模式，在各种BeanFactory以及ApplicationContext创建中都用到了</p><p>2.模版模式，在各种BeanFactory以及ApplicationContext实现中也都用到了</p><p>3.代理模式，Spring AOP 利用了 AspectJ AOP实现的! AspectJ AOP 的底层用了动态代理</p><p>4.策略模式，加载资源文件的方式，使用了不同的方法，比如：ClassPathResourece，FileSystemResource，ServletContextResource，UrlResource但他们都有共同的借口Resource；在Aop的实现中，采用了两种不同的方式，JDK动态代理和CGLIB代理</p><p>5.单例模式，比如在创建bean的时候。</p><p>6.观察者模式，spring中的ApplicationEvent，ApplicationListener,ApplicationEventPublisher</p><p>7.适配器模式，MethodBeforeAdviceAdapter,ThrowsAdviceAdapter,AfterReturningAdapter</p><p>8.装饰者模式，源码中类型带Wrapper或者Decorator的都是</p><h2 id="_25-spring事务的实现方式原理是什么？" tabindex="-1">25 spring事务的实现方式原理是什么？ <a class="header-anchor" href="#_25-spring事务的实现方式原理是什么？" aria-hidden="true">#</a></h2><ul><li>在使用Spring框架的时候，可以有两种事务的实现方式，一种是编程式事务，有用户自己通过代码来控制事务的处理逻辑，还有一种是声明式事务，通过@Transactional注解来实现。</li><li>其实事务的操作本来应该是由数据库来进行控制，但是为了方便用户进行业务逻辑的操作，spring对事务功能进行了扩展实现，一般我们很少会用编程式事务，更多的是通过添加@Transactional注解来进行实现，当添加此注解之后事务的自动功能就会关闭，有spring框架来帮助进行控制。</li><li>其实事务操作是AOP的一个核心体现，当一个方法添加@Transactional注解之后，spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，当使用这个代理对象的方法的时候，如果有事务处理，那么会先把事务的自动提交给关系，然后去执行具体的业务逻辑，</li><li>如果执行逻辑没有出现异常，那么代理逻辑就会直接提交，</li><li>如果出现任何异常情况，那么直接进行回滚操作，当然用户可以控制对哪些异常进行回滚操作</li></ul><h2 id="_26-spring事务的隔离级别有哪些？" tabindex="-1">26 spring事务的隔离级别有哪些？ <a class="header-anchor" href="#_26-spring事务的隔离级别有哪些？" aria-hidden="true">#</a></h2><p>spring中的事务隔离级别就是数据库的隔离级别，有以下几种：</p><ul><li>read uncommitted</li><li>read committed</li><li>repeatable read</li><li>serializable</li></ul><blockquote><p>在进行配置的时候，如果数据库和spring代码中的隔离级别不同，那么以spring的配置为主。</p></blockquote><h2 id="_27-spring的事务传播机制是什么？" tabindex="-1">27 spring的事务传播机制是什么？ <a class="header-anchor" href="#_27-spring的事务传播机制是什么？" aria-hidden="true">#</a></h2><p>多个事务方法相互调用时，事务如何在这些方法之间进行传播,spring中提供了7中不同的传播特性，来保证事务的正常执行：</p><ul><li><p>REQUIRED：默认的传播特性，如果当前没有事务，则新建一个事务，如果当前存在事务，则加入这个事务</p></li><li><p>SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，则以非事务的方式执行</p></li><li><p>MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常</p></li><li><p>REQUIRED_NEW：创建一个新事务，如果存在当前事务，则挂起改事务</p></li><li><p>NOT_SUPPORTED：以非事务方式执行，如果存在当前事务，则挂起当前事务</p></li><li><p>NEVER：不使用事务，如果当前事务存在，则抛出异常</p></li><li><p>NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样</p></li><li><p>NESTED和REQUIRED_NEW的区别：</p></li><li><p>REQUIRED_NEW是新建一个事务并且新开始的这个事务与原有事务无关，而NESTED则是当前存在事务时会开启一个嵌套事务，在NESTED情况下，父事务回滚时，子事务也会回滚，而REQUIRED_NEW情况下，原有事务回滚，不会影响新开启的事务</p></li><li><p>NESTED和REQUIRED的区别：</p></li><li><p>REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一个事务，那么被调用方出现异常时，由于共用一个事务，所以无论是否catch异常，事务都会回滚，而在NESTED情况下，被调用方发生异常时，调用方可以catch其异常，这样只有子事务回滚，父事务不会回滚。</p></li></ul><h2 id="_28-spring事务什么时候会失效？" tabindex="-1">28 spring事务什么时候会失效？ <a class="header-anchor" href="#_28-spring事务什么时候会失效？" aria-hidden="true">#</a></h2><ol><li><p>bean对象没有被spring容器管理</p></li><li><p>方法的访问修饰符不是public</p></li><li><p>自身调用问题</p></li><li><p>数据源没有配置事务管理器</p></li><li><p>数据库不支持事务</p></li><li><p>异常被捕获</p></li><li><p>异常类型错误或者配置错误</p></li></ol><h2 id="_29-springmvc运行流程" tabindex="-1">29 springmvc运行流程 <a class="header-anchor" href="#_29-springmvc运行流程" aria-hidden="true">#</a></h2><ol><li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</li><li>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</li><li>返回处理器执行链，根据url查找控制器，并且将解析后的信息传递给DispatcherServlet</li><li>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</li><li>执行handler找到具体的处理器</li><li>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView</li><li>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</li><li>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</li><li>视图解析器将解析的逻辑视图名传给DispatcherServlet。</li><li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图，进行试图渲染</li><li>将响应数据返回给客户端</li></ol><h2 id="_30-springmvc的九大组件有哪些？" tabindex="-1">30 springmvc的九大组件有哪些？ <a class="header-anchor" href="#_30-springmvc的九大组件有哪些？" aria-hidden="true">#</a></h2><ol><li><p>HandlerMapping 根据request找到相应的处理器。因为Handler（Controller）有两种形式，一种是基于类的Handler，另一种是基于Method的Handler（也就是我们常用的）</p></li><li><p>HandlerAdapter 调用Handler的适配器。如果把Handler（Controller）当做工具的话，那么HandlerAdapter就相当于干活的工人</p></li><li><p>HandlerExceptionResolver 对异常的处理</p></li><li><p>ViewResolver 用来将String类型的视图名和Locale解析为View类型的视图</p></li><li><p>RequestToViewNameTranslator 有的Handler（Controller）处理完后没有设置返回类型，比如是void方法，这是就需要从request中获取viewName</p></li><li><p>LocaleResolver 从request中解析出Locale。Locale表示一个区域，比如zh-cn，对不同的区域的用户，显示不同的结果，这就是i18n（SpringMVC中有具体的拦截器LocaleChangeInterceptor）</p></li><li><p>ThemeResolver 主题解析，这种类似于我们手机更换主题，不同的UI，css等</p></li><li><p>MultipartResolver 处理上传请求，将普通的request封装成MultipartHttpServletRequest</p></li><li><p>FlashMapManager 用于管理FlashMap，FlashMap用于在redirect重定向中传递参数</p></li></ol><h2 id="_31-autowired-resource" tabindex="-1">31 @Autowired @Resource <a class="header-anchor" href="#_31-autowired-resource" aria-hidden="true">#</a></h2><ol><li>两者都可以写在字段和 setter 方法上，两者如果都写在字段上，那么就不需要再写 setter 方法。</li><li>@Autowired 是 Spring 注解，需要导包，@Resource 是 JDK 注解。</li><li>@Autowired 注解按照类型装配依赖对象，默认情况下它要求依赖对象必须存在</li><li>@Resource 默认按照 byName 自动注入。</li><li>@Resource 装配顺序 <ol><li>如果同时指定了 name 和 type ，则从 Spring 上下文中找到唯一匹配的 bean 进行装配，找不到则抛异常</li><li>如果指定了 type，则从上下文中找到类似匹配的唯一 bean 进行装配，找不到或是多个，都会抛出异常</li><li>如果指定了 name ，则从上下文中查找名称（id）匹配的 bean 进行装配，找不到则抛出异常。</li><li>如果都没有指定，则自动按照 byName 方式</li></ol></li></ol><h2 id="_32-spring-mvc" tabindex="-1">32 Spring MVC <a class="header-anchor" href="#_32-spring-mvc" aria-hidden="true">#</a></h2><blockquote><p>model 模型（完成业务逻辑：有 javaBean 构成，service dao entity） view 视图（做界面的展示 jsp） controller 控制器（接收请求 -&gt; 调用模型 -&gt; 根据结果派发页面）</p></blockquote><div class="tip custom-block"><p class="custom-block-title">mvc 工作原理</p><ol><li>用户发送请求至前端控制器 DispatcherServlet</li><li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器</li><li>处理器映射器找到具体的处理器（可以根据 xml 配置、注解进行查找），生成处理器对象及处理器拦截器 （如果有则生成）一并返回给 DispatcherServlet.</li><li>DispatcherServlet 调用 HandlerAdapter 处理器适配器。</li><li>HandlerAdapter 经过适配调用具体的处理器（Controller，也叫后端控制器）</li><li>Controller 执行完成返回 ModelAndView</li><li>HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet</li><li>DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器</li><li>ViewResolver 解析后返回具体 View</li><li>DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）</li><li>DispatcherServlet 响应用户。</li></ol></div><p>涉及到的组件</p><ul><li>前端控制器 DispatcherServlet 接收请求，响应结果</li><li>处理器映射器（HandlerMapping）根据URL去查找处理器</li><li>处理器（Handler）需要程序员去写代码处理逻辑的</li><li>处理器适配器（HandlerAdapter）会把处理器包装成适配器，这样就可以支持多种类型的处理器</li><li>视图解析器（ViewResolver）进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面</li></ul><ol><li>【web 端】发起request 请求【dispatchServlet】</li><li>【dispatchServlet】转发至对应 【control】</li><li>【control】 进行业务逻辑处理、设置业务 Model、设置返回页面</li><li>【control】返回处理结果至【dispatchServlet】</li><li>【dispatchServlet】转发至视图处理器【view】</li><li>【view】基于模板与模型转换输出</li><li>【view】基于 response 返回至【web 端】。</li></ol><h2 id="_33-spring-aop" tabindex="-1">33 Spring AOP <a class="header-anchor" href="#_33-spring-aop" aria-hidden="true">#</a></h2><ol><li>能够将那些与业务无关，却为业务模块所共同调用的逻辑或者责任封装起来，减少系统的重复代码</li><li>Spring AOP 基于动态代理，如果要代理的对象实现了某个接口，那么 Spring AOP 就会使用 JDK 动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用 JDK 动态代理，转而使用 CGLIB 动态代理生成一个被代理对象的子类作为代理。</li></ol><div class="tip custom-block"><p class="custom-block-title">AspectJ vs AOP</p><ol><li>AspectJ 是编译时增强，AOP 是运行时增强</li><li>AspectJ 是基于字节码操作，AOP 是基于代理</li><li>AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，如果切面较少，两者性能差异不大，但是，如果切面太多的话，最好选择 AspectJ。</li></ol></div><h2 id="_34-spring-ioc" tabindex="-1">34 Spring IOC <a class="header-anchor" href="#_34-spring-ioc" aria-hidden="true">#</a></h2><ol><li>IOC 控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，现在这种权力转移到 Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。</li><li>对象与对象之间松散耦合，也利于功能的复用。</li><li>应用程序在运行时依赖 IOC 容器来动态注入对象需要的外部资源。</li><li>IOC 让对象的创建不用去 new 了，可由 Spring 自动生产，使用 Java 的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法。</li></ol><h2 id="_35-applicationcontext-vs-beanfactory" tabindex="-1">35 ApplicationContext vs BeanFactory <a class="header-anchor" href="#_35-applicationcontext-vs-beanfactory" aria-hidden="true">#</a></h2><ol><li>包目录不同</li><li>国际化（BeanFactory 没有扩展 Spring 中 MessageResource 接口，由于 ApplicationContext 扩展了 MessageResource 接口，因此具有消息处理的能力）</li><li>强大的事件机制（ApplicationContext 中发布一个事件时，所有扩展了 ApplicationListener 的 Bean 都将接受这个事件，并进行相应的处理）</li><li>底层资源的访问（ApplicationContext 扩展了 ResourceLoader 资源加载器接口，从而可以用来加载多个 Resource ，而 BeanFactory 是没有扩展 ResourceLoader）</li><li>对 web 应用的支持（ApplicationContext 与 BeanFactory 通常以编程的方式来创建，ApplicationContext 能以声明的方式创建）</li></ol><div class="tip custom-block"><p class="custom-block-title">延迟加载</p><ul><li>BeanFactory 采用的是延迟加载形式来注入 Bean 的，即只有使用到某个 Bean 时（调用 getBean()），才对该 Bean 进行加载实例化，这样，我们不能发现一些存在 Spring 的配置问题。</li><li>ApplicationContext 相反，它是在容器启动时，一次性创建了所有的 Bean，这样，在容器启动时，我们可以发现 Spring 中存在的配置错误。</li><li>BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用</li><li>BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册</li></ul></div><h2 id="_36-循环依赖" tabindex="-1">36 循环依赖 <a class="header-anchor" href="#_36-循环依赖" aria-hidden="true">#</a></h2><ol><li>首先，A 完成初始化第一步并将自己提前曝光出来（通过ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会在尝试 get(B)，这个时候发现 B 还没有被创建出来。</li><li>然后，B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C ，C 也没有被创建出来。</li><li>这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories），通过 ObjectFactory 提前曝光，所以可以通过 ObjectFactory#getObject() 方法来拿到 A 对象。</li><li>C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中。</li><li>回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成初始化过程了。</li></ol><h2 id="_37-事务" tabindex="-1">37 事务 <a class="header-anchor" href="#_37-事务" aria-hidden="true">#</a></h2><ol><li>事务逻辑上是一组操作，组成这组操作的各个单元，要么一起成功，要么一起失败。</li><li>@Transactional 这个注解仅仅是一些和事务相关的元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置 bean 的事务行为。大致来说具有两方面功能，一是，表明该方法要参与事务，二是，配置相关属性来定制事务的参与方式和运行行为。</li><li>声明式事务主要得益于 Spring AOP ，使用一个事务拦截器，在方法调用的前后周围进行事务性增强，来驱动事务完成。</li></ol><div class="warning custom-block"><p class="custom-block-title">事务特性</p><ul><li>原子性：强调事务的不可分割</li><li>一致性：事务的执行的前后数据的完整性保持一致</li><li>隔离性：一个事务执行的过程中，不应该受到其它事务的干扰</li><li>持久性：事务一旦有了结果，数据就要持久化到数据库</li></ul></div><div class="danger custom-block"><p class="custom-block-title">解决读问题</p><p>设置事务的隔离级别</p><ul><li>DEFAULT 这是一个 Platform Transaction Manager 默认的隔离级别，使用数据库默认的事务隔离级别。</li><li><strong>未提交读</strong>：脏读、不可重复读、虚读都有可能发生</li><li><strong>已提交读</strong>：避免脏读。但是不可重复读和虚读有可能发生</li><li><strong>可重复读</strong>：避免脏读和不可重复读，但是虚读有可能发生</li><li><strong>串行化</strong>：避免以上所有读问题</li></ul></div><blockquote><p>Mysql 默认：可重复读 ；Oracle 默认：读已提交</p></blockquote><ul><li><strong>事务的传播行为：PROPAGATION_XXX 事务的传播行为</strong></li></ul><blockquote><p>保证同一事务中</p></blockquote><ol><li>propagation_required 支持当前事务，如果不存在，就新建一个</li><li>propagation_supports 支持当前事务，如果不存在，就不使用事务</li><li>propagation_mandatory 支持当前事务，如果不存在，抛出异常</li></ol><blockquote><p>保证没有在同一事务中</p></blockquote><ol><li>propagation_requires_new 如果有事务存在，挂起当前事务，创建一个新的事务</li><li>propagation_not_supported 以非事务方式运行，如果有事务存在，挂起当前事务</li><li>propagation_never 以非事务方式运行，如果有事务存在，抛出异常</li><li>propagation_nested 如果当前事务存在，则嵌套事务执行</li></ol></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-13T03:04:30.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>