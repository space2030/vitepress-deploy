<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Elasticsearch</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_view_java_java-13-elasticsearch.md.b01a920e.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#_01-es的集群架构，索引数据大小，分片有多少，以及一些调优手段" data-v-2d325df8>01 es的集群架构，索引数据大小，分片有多少，以及一些调优手段</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-es的倒排索引是什么" data-v-2d325df8>02 es的倒排索引是什么</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-es索引数据多了怎么办，如何调优，部署" data-v-2d325df8>03 es索引数据多了怎么办，如何调优，部署</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-es是如何实现master选举的" data-v-2d325df8>04 es是如何实现master选举的</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_05-es索引文档的过程" data-v-2d325df8>05 es索引文档的过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-详细描述一下es搜索的过程" data-v-2d325df8>06 详细描述一下es搜索的过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-es在部署时，对linux的设置有哪些优化方法" data-v-2d325df8>07 es在部署时，对Linux的设置有哪些优化方法</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-lucene内部结构是什么" data-v-2d325df8>08 lucene内部结构是什么</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-es是如何实现master选举的" data-v-2d325df8>09 es是如何实现master选举的</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-es中的节点（比如20个），其中10个选了一个master，另外10个选了另一个master，怎么办" data-v-2d325df8>10 es中的节点（比如20个），其中10个选了一个master，另外10个选了另一个master，怎么办</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-客户端在和集群连接时，如何选择特定的节点执行请求的？" data-v-2d325df8>11 客户端在和集群连接时，如何选择特定的节点执行请求的？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-详细描述一下es索引文档的过程" data-v-2d325df8>12 详细描述一下es索引文档的过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-es更新和删除文档的过程" data-v-2d325df8>13 es更新和删除文档的过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-es的搜索过程" data-v-2d325df8>14 es的搜索过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-es中，是怎么根据一个词找到对应的倒排索引的" data-v-2d325df8>15 es中，是怎么根据一个词找到对应的倒排索引的</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-es在部署时，对linux的设置有哪些优化方法" data-v-2d325df8>16 es在部署时，对Linux的设置有哪些优化方法</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_17-对于gc方面，es需注意" data-v-2d325df8>17 对于GC方面，es需注意</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_18-es对于大数据量的聚合如何实现" data-v-2d325df8>18 es对于大数据量的聚合如何实现</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_19-在并发情况下，es如何保证读写一致" data-v-2d325df8>19 在并发情况下，es如何保证读写一致</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_20-如何监控elasticsearch集群状态" data-v-2d325df8>20 如何监控Elasticsearch集群状态</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_21-字典树" data-v-2d325df8>21 字典树</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_22-es集群，一个node一般分配几个分片" data-v-2d325df8>22 es集群，一个node一般分配几个分片</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_23-es写入调优" data-v-2d325df8>23 es写入调优</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_24-es脑裂" data-v-2d325df8>24 es脑裂</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_25-读写一致" data-v-2d325df8>25 读写一致</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_26-es对于大数据量的聚合如何实现" data-v-2d325df8>26 es对于大数据量的聚合如何实现</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_27-es更新数据的执行流程" data-v-2d325df8>27 es更新数据的执行流程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_28-分析器" data-v-2d325df8>28 分析器</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_29-全文检索" data-v-2d325df8>29 全文检索</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_30-自动映射的规则" data-v-2d325df8>30 自动映射的规则</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_31-倒排索引" data-v-2d325df8>31 倒排索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_32-正排索引" data-v-2d325df8>32 正排索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_33-语法" data-v-2d325df8>33 语法</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_34-集群、主分片、副本分片" data-v-2d325df8>34 集群、主分片、副本分片</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_35-master-选举" data-v-2d325df8>35 Master 选举</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_36-集群健康度" data-v-2d325df8>36 集群健康度</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_37-主分片数不能修改" data-v-2d325df8>37 主分片数不能修改</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_38-es-vs-mysql-概念" data-v-2d325df8>38 ES vs MySQL 概念</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_39-性能优化" data-v-2d325df8>39 性能优化</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_view_java_java-13-elasticsearch" data-v-3886f8ec><div><h1 id="elasticsearch" tabindex="-1">Elasticsearch <a class="header-anchor" href="#elasticsearch" aria-hidden="true">#</a></h1><h2 id="_01-es的集群架构，索引数据大小，分片有多少，以及一些调优手段" tabindex="-1">01 es的集群架构，索引数据大小，分片有多少，以及一些调优手段 <a class="header-anchor" href="#_01-es的集群架构，索引数据大小，分片有多少，以及一些调优手段" aria-hidden="true">#</a></h2><ul><li>ES集群架构13个节点，索引根据通道不同共20+索引。</li><li>根据日期，每日递增20+索引，10分片，每日递增1亿+数据，每个通道每天索引大小控制：150GB之内。</li><li>仅索引层面调优手段：</li></ul><div class="tip custom-block"><p class="custom-block-title">设计阶段调优：</p><ol><li>根据业务增量需求，采取基于日期模板创建索引，通过roll over API滚动索引；</li><li>使用别名进行索引管理；</li><li>每天凌晨定时对索引做force merge操作，以释放空间；</li><li>采取冷热分离机制，热数据存储到SSD，提高检索效率，冷数据定期进行shrink操作，以缩减存储；</li><li>采取curator进行索引的生命周期管理；</li><li>仅针对需要分词的字段，合理的设置分词器；</li><li>Mapping阶段充分结合各个字段的属性，是否需要检索，是否需要存储等等</li></ol></div><div class="tip custom-block"><p class="custom-block-title">写入调优</p><ol><li>写入前副本数设置为0</li><li>写入前关闭refresh interval设置为-1，禁用刷新机制</li><li>写入过程中，采取bulk批量写入</li><li>写入后恢复副本数和刷新间隔</li><li>尽量使用自动生成id</li></ol></div><div class="tip custom-block"><p class="custom-block-title">查询调优</p><ol><li>禁用wildcard</li><li>禁止批量terms（成百上千的场景）</li><li>充分利用倒排索引机制，能keyword类型尽量keyword</li><li>数据量大时候，可以先基于时间敲定索引再检索</li><li>设置合理的路由机制</li></ol></div><div class="tip custom-block"><p class="custom-block-title">其它调优</p><p>部署调优，业务调优等等</p></div><h2 id="_02-es的倒排索引是什么" tabindex="-1">02 es的倒排索引是什么 <a class="header-anchor" href="#_02-es的倒排索引是什么" aria-hidden="true">#</a></h2><ul><li>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。</li><li>而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表即为倒排索引。</li><li>倒排索引，相反于一篇文章包含了哪些词，它从词出发记载了这个词在哪些文档中出现过，由两部分组成——词典和倒排表。</li><li>倒排索引的底层实现是基于：FST（Finite State Transducer）数据结构</li></ul><blockquote><p><strong>FST有两个优点：</strong> 空间占用小，通过对词典中单词前缀和后缀的重复利用，压缩了存储空间。 查询速度快，O(len(str)) 的查询时间复杂度。</p></blockquote><h2 id="_03-es索引数据多了怎么办，如何调优，部署" tabindex="-1">03 es索引数据多了怎么办，如何调优，部署 <a class="header-anchor" href="#_03-es索引数据多了怎么办，如何调优，部署" aria-hidden="true">#</a></h2><p>索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，这样才能有效的避免数据激增导致集群处理能力不足引发的线上客户检索后者其它业务受到影响。</p><div class="tip custom-block"><p class="custom-block-title"><strong>动态索引层面</strong></p><p>基于模板+时间+rollover api滚动创建索引，举例：设计阶段定义：blog索引的模板格式为：blog_index_时间戳的形式，每天递增数据。 这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线2的32次幂减1，索引存储达到TB+甚至更大 一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。</p></div><div class="tip custom-block"><p class="custom-block-title"><strong>存储层面</strong></p><p>冷热数据分离存储，热数据（比如最近3天或者一周的数据），其余为冷数据。 对于冷数据不会再写入新数据，可以考虑定期force_merge加shrink压缩操作，节省存储空间和检索效率。</p></div><div class="tip custom-block"><p class="custom-block-title"><strong>部署层面</strong></p><p>一旦之前没有规划，这里就属于应急策略，结合ES自身的支持动态扩展的特点动态新增机器的方式可以缓解集群压力。注意：之前主节点等规划合理，不需要重启集群也能完成动态新增的。</p></div><h2 id="_04-es是如何实现master选举的" tabindex="-1">04 es是如何实现master选举的 <a class="header-anchor" href="#_04-es是如何实现master选举的" aria-hidden="true">#</a></h2><ol><li>只有候选主节点（master：true）的节点才能成为主节点。</li><li>最小主节点数（min_master_nodes）的目的是防止脑裂。</li></ol><div class="tip custom-block"><p class="custom-block-title">选举流程大致如下：</p><ul><li>第一步： 确认候选节点数达标，elasticsearch.yml设置的值 discovery.zen.minimum_master_nodes;</li><li>第二步： 比较，先判定是否 具备master资格，具备候选主节点资格的优先返回；若两节点都为候选主节点，则id小的值为主节点。注意这里的id为string类型</li></ul></div><h2 id="_05-es索引文档的过程" tabindex="-1">05 es索引文档的过程 <a class="header-anchor" href="#_05-es索引文档的过程" aria-hidden="true">#</a></h2><p>文档写入ES，创建索引的过程。 文档写入包含：单文档写入和批量bulk写入，这里只解释一下：单文档写入流程。</p><ol><li>第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由/协商节点，请求的节点扮演路由节点的角色）</li><li>第二步：节点1接收到请求后，使用文档_id来确定文档属于分片0，请求会被转到另外的节点，假定节点3，因此分片0的主分片分配到节点3上。</li><li>第三步：节点3在主分片上执行写操作，如果成功，则将请求并行转发到节点1和节点2的副本分片上。等待结果返回，所有的副本分片都报告成功，节点3将向协调节点（节点1）报告成功，节点1向请求客户端报告写入成功。</li></ol><p><strong>追问：第二步中的文档获取分片的过程？</strong> 借助路由算法获取，路由算法就是根据路由和文档id计算目标的分片id的过程。 1 shard = hash(_routing) % (num_of_primary_shards)</p><h2 id="_06-详细描述一下es搜索的过程" tabindex="-1">06 详细描述一下es搜索的过程 <a class="header-anchor" href="#_06-详细描述一下es搜索的过程" aria-hidden="true">#</a></h2><p>搜索拆解为“query then fetch”两个阶段 query阶段的目的：定位到位置，但不取 步骤拆解如下：</p><ol start="5"><li>假设一个索引数据有5主 + 1 副本共10分片，一次请求会命中（主或者副本分片中）的一个。</li><li>每个分片在本地进行查询，结果返回到本地有序的优先队列中。</li><li>第2步骤的结果发送到协调节点，协调节点产生一个全局的排序列表，fetch阶段的目的：取数据，路由节点获取所有文档，返回给客户端。</li></ol><h2 id="_07-es在部署时，对linux的设置有哪些优化方法" tabindex="-1">07 es在部署时，对Linux的设置有哪些优化方法 <a class="header-anchor" href="#_07-es在部署时，对linux的设置有哪些优化方法" aria-hidden="true">#</a></h2><ol><li>关闭缓存swap;</li><li>堆内存设置为：Min（节点内存 / 2 ,32GB）</li><li>设置最大文件句柄数</li><li>线程池+队列大小根据业务需要做调整</li><li>磁盘存储raid方式——存储有条件使用RAID10，增加单节点性能以及避免单节点存储故障。</li></ol><h2 id="_08-lucene内部结构是什么" tabindex="-1">08 lucene内部结构是什么 <a class="header-anchor" href="#_08-lucene内部结构是什么" aria-hidden="true">#</a></h2><p>lucene是有索引和搜索的两个过程，包含索引创建，索引，搜索三个要点，可以基于这个脉络展开一些。</p><h2 id="_09-es是如何实现master选举的" tabindex="-1">09 es是如何实现master选举的 <a class="header-anchor" href="#_09-es是如何实现master选举的" aria-hidden="true">#</a></h2><ol><li>es的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通这两部分）</li><li>对所有可以成为master的节点（node.master：true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点</li><li>如果对某个节点的投票数达到一定的值（可以成为master节点数 n/2 + 1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件</li><li>master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理，data节点可以关闭http功能。</li></ol><h2 id="_10-es中的节点（比如20个），其中10个选了一个master，另外10个选了另一个master，怎么办" tabindex="-1">10 es中的节点（比如20个），其中10个选了一个master，另外10个选了另一个master，怎么办 <a class="header-anchor" href="#_10-es中的节点（比如20个），其中10个选了一个master，另外10个选了另一个master，怎么办" aria-hidden="true">#</a></h2><ol><li>当集群master候选数量不小于3个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题。</li><li>当候选数量为两个时，只能修改为唯一的一个master候选，其它作为data节点，避免脑裂问题。</li></ol><h2 id="_11-客户端在和集群连接时，如何选择特定的节点执行请求的？" tabindex="-1">11 客户端在和集群连接时，如何选择特定的节点执行请求的？ <a class="header-anchor" href="#_11-客户端在和集群连接时，如何选择特定的节点执行请求的？" aria-hidden="true">#</a></h2><p>TransportClient利用transport模块远程连接一个es集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的transport地址，并以轮询的方式与这些地址进行通信。</p><h2 id="_12-详细描述一下es索引文档的过程" tabindex="-1">12 详细描述一下es索引文档的过程 <a class="header-anchor" href="#_12-详细描述一下es索引文档的过程" aria-hidden="true">#</a></h2><p>协调节点默认使用文档id参与计算（也支持通过routing），以便路由提供合适的分片 shard = hash(document_id) % (num_of_primary_shards)</p><ol><li>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到MemoryBuffer，然后定时（默认每间隔1秒）写入到FileSystem Cache，这个从MomeryBuffer 到FileSystem Cache的过程叫做refresh</li><li>当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES通过translog的机制来保证数据的可靠性，其实现机制是接收到请求后，同时也会写入到translog中，当Filesystem Cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush</li><li>在flush过程中内存中的缓冲将被清除，内容被写入一个新段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。</li><li>flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认512M）时 补充：关于lucence的Segement</li><li>lucence索引是由多个段组成，段本身是一个功能齐全的倒排索引</li><li>段是不可变的，允许lucene将新的文档增量地添加到索引中，而不用从头重建索引。</li><li>对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗CPU的时钟周、文件句柄和内存，这意味着段的数量越多，搜索性能会越低。</li><li>为了解决这个问题，es会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。</li></ol><h2 id="_13-es更新和删除文档的过程" tabindex="-1">13 es更新和删除文档的过程 <a class="header-anchor" href="#_13-es更新和删除文档的过程" aria-hidden="true">#</a></h2><ol><li>删除和更新也都是写操作，但是es中的文档是不可变的，不能被删除或者改动以展示其变更</li><li>磁盘上的每个段都有一个相应的del文件，当删除请求发送后，文档并没有真的被删除，而是在del文件中被标记为删除。该文档依然能匹配查询，但是在结果中被过滤掉，当段合并时，在del文件中被标记为删除的文档将不会被写入新段。</li><li>在新的文档被创建时，es会为该文档指定一个版本号。当执行更新时，旧版本的文档在del文件中被标记为删除，新版本的文档被索引到一个新段，旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</li></ol><h2 id="_14-es的搜索过程" tabindex="-1">14 es的搜索过程 <a class="header-anchor" href="#_14-es的搜索过程" aria-hidden="true">#</a></h2><ol><li>搜索被执行成一个两阶段过程，我们称为Query Then Fetch</li><li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。每个分片在本地执行搜索并构建一个匹配文档的大小为from + size的优先队列。</li><li>每个分片返回各自优先队列中所有文档的id和排序值给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li><li>接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个Get请求，每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点，一旦所有的文档都被取回了，协调节点返回结果给客户端。</li><li>补充：Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch增加了一个预查询的处理，询问Term和Document frequency。这个评分更准确，但是性能会变差。</li></ol><h2 id="_15-es中，是怎么根据一个词找到对应的倒排索引的" tabindex="-1">15 es中，是怎么根据一个词找到对应的倒排索引的 <a class="header-anchor" href="#_15-es中，是怎么根据一个词找到对应的倒排索引的" aria-hidden="true">#</a></h2><p>lucene的索引文件格式</p><h2 id="_16-es在部署时，对linux的设置有哪些优化方法" tabindex="-1">16 es在部署时，对Linux的设置有哪些优化方法 <a class="header-anchor" href="#_16-es在部署时，对linux的设置有哪些优化方法" aria-hidden="true">#</a></h2><ol><li>64GB内存的机器是非常理想的，但是32GB和16GB的机器也是很常见的，少于8GB会适得其反。</li><li>如果你要在快的cpu和更多核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。</li><li>如果你负担得起SSD，它将远远超出任何旋转介质，基于SSD的节点，查询和索引性能都有提升，如果你负担得起，SSD是一个好的选择。</li><li>即使数据中心近在咫尺，也要避免集群跨越多个数据中心，绝对要避免集群跨越大的地理距离</li><li>请确保运行你应用程序的JVM和服务器的JVM是完全一样的。在es的几个地方，使用java的本地序列化</li><li>通过设置gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。</li><li>es默认被配置为使用单播发现，以防止节点无意中加入集群，只有在同一台机器上运行的节点才会自动组成集群，最好使用单播代替组播。</li><li>不要随意修改垃圾回收器和各个线程池的大小</li><li>把你的内存的（少于）一半给lucence（但不要超过32GB），通过ES_HEAP_SIZE环境变量设置。</li><li>内存交换到磁盘对服务器性能来说是致命的，如果内存交换到磁盘上，一个100微秒的操作可能变成10毫秒，再想想那么多10微妙的操作时延累加起来，不难看出swapping对于性能是多么可怕</li><li>lucene使用了大量的文件，同时es在节点和http客户端之间进行通信也使用了大量的套接字，所有这一切都需要足够的文件描述符，你应该增加你的 文件描述符，设置一个很大的值，如：64000</li></ol><div class="tip custom-block"><p class="custom-block-title">索引阶段性能提升方法</p><ol><li>使用批量请求并调整请求大小：每次批量数据5~15MB大小是个不错的起始点。</li><li>存储：使用SSD</li><li>段和合并：es默认值20MB/s。对机械磁盘应该是个不错的设置，如果你用的是SSD，可以考虑提高到100~200MB/s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流，另外还可以增加index.translog.flush_threshold_size设置，从默认的512MB到更大一些的值，比如1GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。</li><li>如果你的搜索结果不需要近实时的准确度，考虑把每个索引的index.refresh_interval改到30s</li><li>如果你在做大批量导入，考虑通过设置index.number_of_replicas:0关闭副本</li></ol></div><h2 id="_17-对于gc方面，es需注意" tabindex="-1">17 对于GC方面，es需注意 <a class="header-anchor" href="#_17-对于gc方面，es需注意" aria-hidden="true">#</a></h2><ol><li>倒排词典的索引需要常驻内存，无法GC，需要监控data node上segmentmemory增长趋势</li><li>各类缓存field cache、filter cache、indexing cache、bulk queue等等，要设置合理的大小，并且要应该根据最坏的情况来看heap是否够用，也就是各类缓存全部占满的时候，还有heap空间可以分配给其他任务吗，避免采用clear cache等“自欺欺人”的方式来释放内存。</li><li>避免返回大量结果集的搜索与聚合，确实需要大量拉取数据的场景，可以采用scan &amp; scroll api来实现</li><li>cluster stats驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过tribe node连接。</li><li>想知道heap够不够，必须结合实际应用场景，并对集群的heap使用情况做持续的监控。</li></ol><h2 id="_18-es对于大数据量的聚合如何实现" tabindex="-1">18 es对于大数据量的聚合如何实现 <a class="header-anchor" href="#_18-es对于大数据量的聚合如何实现" aria-hidden="true">#</a></h2><ol><li>es提供的首个近似聚合是cardinality度量，它提供一个字段的基数，即该字段的distinct或者unique值的数目，它是基于HLL算法的，HLL会先对我们的输入作哈希运算，然后根据哈希运算的结果中bits做概率估算从而得到基数。</li><li>特点是可配置的精度，用来控制内存的使用（更精确 = 更多内存）小的数据集精度是非常高的，我们可以通过配置参数，来设置去重需要的固定内存使用量，无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关</li></ol><h2 id="_19-在并发情况下，es如何保证读写一致" tabindex="-1">19 在并发情况下，es如何保证读写一致 <a class="header-anchor" href="#_19-在并发情况下，es如何保证读写一致" aria-hidden="true">#</a></h2><ol><li>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</li><li>另外对于写操作，一致性级别支持quorum/one/all。默认为quorum，即只有当大多数分片可用时才允许写操作，但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</li><li>对于读操作，可以设置replication为sync（默认）这使得操作在主分片和副分片都完成后才会返回，如果设置replication为async时，也可以通过设置搜索请求参数preferenece为primary来查询主分片，确保文档是最新版本。</li></ol><h2 id="_20-如何监控elasticsearch集群状态" tabindex="-1">20 如何监控Elasticsearch集群状态 <a class="header-anchor" href="#_20-如何监控elasticsearch集群状态" aria-hidden="true">#</a></h2><p>Marvel让你可以很简单的通过，kibana监控es。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。</p><h2 id="_21-字典树" tabindex="-1">21 字典树 <a class="header-anchor" href="#_21-字典树" aria-hidden="true">#</a></h2><ul><li>核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</li><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同</li></ul><h2 id="_22-es集群，一个node一般分配几个分片" tabindex="-1">22 es集群，一个node一般分配几个分片 <a class="header-anchor" href="#_22-es集群，一个node一般分配几个分片" aria-hidden="true">#</a></h2><p>官方建议，一个node最好不要多于三个shards</p><h2 id="_23-es写入调优" tabindex="-1">23 es写入调优 <a class="header-anchor" href="#_23-es写入调优" aria-hidden="true">#</a></h2><ol><li>写入前副本数设置为0</li><li>写入前关闭refresh_interval设置为-1，禁用刷新机制</li><li>写入过程中，采取bulk批量写入</li><li>写入后恢复副本数和刷新间隔</li><li>尽量使用自动生成的id</li></ol><h2 id="_24-es脑裂" tabindex="-1">24 es脑裂 <a class="header-anchor" href="#_24-es脑裂" aria-hidden="true">#</a></h2><p>避免脑裂，可通过设置最少投票通过数量超过所有候选节点一半以上，来解决脑裂问题</p><h2 id="_25-读写一致" tabindex="-1">25 读写一致 <a class="header-anchor" href="#_25-读写一致" aria-hidden="true">#</a></h2><ol><li>更新操作：通过版本号使用乐观并发控制，每个文档都有一个 _version 版本号，对其更新会默认携带 version = _version + 1，如果 _version + 1 小于更新时的 _version ，说明已经被更新了，会更新失败。</li><li>写操作：支持 3 种一致性级别，默认是：只有大多数分片可用时才允许写操作，如果大多数可用，进行了写操作，写入失败的副本分片在一个不同的节点上重建。</li><li>读操作：默认是主分片和副本分片更新/写的操作都完成之后的文档才会被查到，可以修改参数，只要主分片更新/写操作的完成的文档即可被查到。</li></ol><div class="tip custom-block"><p class="custom-block-title">es并发下读写一致</p><ol><li>可通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体冲突</li><li>另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作，但即使大多数可用，也可能存在网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建</li><li>对于读操作，可设置replication为sync，这使得操作在主分片和副本分片都完成后才会返回，如果设置replication为async时，可通过设置搜索请求参数preference为primary来查询主分片，确保文档是最新版本。</li></ol></div><h2 id="_26-es对于大数据量的聚合如何实现" tabindex="-1">26 es对于大数据量的聚合如何实现 <a class="header-anchor" href="#_26-es对于大数据量的聚合如何实现" aria-hidden="true">#</a></h2><ol><li>es提供的首个近似聚合cardinality度量，它提供一个字段的基础，即该字段的distinct或者unique值的数目，它是基于HLL算法的，HLL会先对我们输入做哈希运算，然后根据哈希运算结果中的bits做概率估算，从而得到基数。</li><li>可配置的精度，用来控制内存的使用，小的数据精度是非常高的，我们可通过配置参数来设置去重需要的固定内存使用量，无论数千还是数十亿的唯一值，内存使用量只与你的配置的精确度相关。</li></ol><h2 id="_27-es更新数据的执行流程" tabindex="-1">27 es更新数据的执行流程 <a class="header-anchor" href="#_27-es更新数据的执行流程" aria-hidden="true">#</a></h2><ol><li>将原来的doc标识为deleted状态，然后新写入一条数据</li><li>buffer每refresh一次，就会产生一个 segmentfile ，所以默认情况下是1s一个 segmentfile ，segmentfile 会越来越多，此时会定期执行 merge</li><li>每次merge时，会将多个 segmentfile 合并成一个，同时这里将会标识为deleted的doc的物理删除掉，</li><li>然后将新的segmentfile写入磁盘，这里会写一个 commitpoint，标识所有新的 segmentfile，然后打开 segmentfile 供搜索使用，同时删除旧的 segmentfile</li></ol><h2 id="_28-分析器" tabindex="-1">28 分析器 <a class="header-anchor" href="#_28-分析器" aria-hidden="true">#</a></h2><ol><li>在es中索引数据，数据由为索引定义的analyzer在内部进行转换，分析器由一个tokenizer和零个或多个tokenFilter组成，编译器可在一个或多个charFilter之前，分析模块允许你在逻辑名称下注册分析器，然后可在映射定义或某些API中引用它们</li><li>es附带了许多可随时使用的预建分析器</li><li>组合内置的字符过滤器，编译器和过滤器来创建自定义分析器。</li></ol><h2 id="_29-全文检索" tabindex="-1">29 全文检索 <a class="header-anchor" href="#_29-全文检索" aria-hidden="true">#</a></h2><ol><li>客户端使用restful api向对应的node发送查询请求</li><li>协调节点将请求转发到所有节点，所有节点将对应的数据查询之后返回对应的doc id返回给协调节点</li><li>协调节点将doc进行排序聚合</li><li>协调节点再根据doc id把查询请求发送到对应的shard的node，返回document</li></ol><h2 id="_30-自动映射的规则" tabindex="-1">30 自动映射的规则 <a class="header-anchor" href="#_30-自动映射的规则" aria-hidden="true">#</a></h2><ol><li>es 映射用于确定字段类型，将新增的每个字段数据类型映射后确定的字段类型</li><li>常见的映射类型有基本数据类型，复杂数据类型映射，有数组对象，但对象映射扁平化后相关性会丢失，不能确定哪个是哪个属性。</li><li>全局映射的方式默认继承 default 的配置：动态模板映射（dynamic_templates）使用动态模板映射覆盖默认模板，可设置关键字，默认模板是 String 类型的。</li></ol><h2 id="_31-倒排索引" tabindex="-1">31 倒排索引 <a class="header-anchor" href="#_31-倒排索引" aria-hidden="true">#</a></h2><ol><li>倒排索引是搜索引擎的核心，搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。</li><li>倒排索引是一种像数据结构一样的散列图，可将用户从单词导向文档或网页，它是搜索引擎的核心，其主要目标是快速搜索从数百万文件中查找数据。</li><li>创建索引：把每个文档拆分为独立的词、创建一个包含所有且不重复的词条列表、记录每个词条出现在哪些文档中</li><li>搜索时，直接根据词，返回对应的文章 ID</li></ol><h2 id="_32-正排索引" tabindex="-1">32 正排索引 <a class="header-anchor" href="#_32-正排索引" aria-hidden="true">#</a></h2><ol><li>正排索引主要用于实现根据指定字段进行排序和聚合的功能。</li><li>正排索引类似于数据库 key-value-value，可以只读取 ID 和排序字段到内存进行排序。</li></ol><div class="tip custom-block"><p class="custom-block-title">如何利用正排和倒排索引</p><p>在生成文档时，会分别生成倒排索引和正排索引，先用倒排索引找到文档，然后用正排索引聚合排序等操作。</p></div><h2 id="_33-语法" tabindex="-1">33 语法 <a class="header-anchor" href="#_33-语法" aria-hidden="true">#</a></h2><ul><li>新增文档 create 和 index 的区别 <ul><li>index 文档不存在：新增；文档存在：删除旧的、新增</li><li>create 文档不存在：新增，文档存在：报错；</li></ul></li><li>更新文档 update 与 index 的区别 <ul><li>index：文档不存在：新增；文档存在：删除旧的、新增；</li><li>update：文档不存在：报错；文档存在：直接更新；</li></ul></li><li>text 和 keyword 类型的区别 <ul><li>keyword 类型的字段不会分词，只能精确匹配，区分大小写的</li><li>text 类型会被分词并且转为小写</li></ul></li><li>query 和 filter 的区别 <ul><li>query 查询会计算相关度分数，进行排序</li><li>filter 查询不进行分数计算，并且查询结果会被缓存，性能较高</li></ul></li></ul><h2 id="_34-集群、主分片、副本分片" tabindex="-1">34 集群、主分片、副本分片 <a class="header-anchor" href="#_34-集群、主分片、副本分片" aria-hidden="true">#</a></h2><ol><li>ES 将索引细分为分片，一个索引被拆成多个主分片，分布在不同节点上，用于解决存储空间水平扩容问题</li><li>副本分片是对主分片的拷贝，保证一个节点挂了，剩余节点主分片 + 副本分片能组成完成的数据，保证服务可用。</li></ol><div class="tip custom-block"><p class="custom-block-title">主节点</p><ul><li>Master 节点的职责主要包括集群、节点和索引的管理、不负责文档级别的管理。</li><li>主节点负载创建索引，删除索引，分配分片，追踪集群中的节点状态等工作。</li><li>主节点的工作量相对较轻，用户的请求可以发往任何一个节点，并由该节点负责分发请求，收集结果等操作，而并不需要经过主节点转发。</li></ul></div><ol start="3"><li>分片特性：主分片在创建索引时指定，后续不允许修改，副本分片数可以动态调整。</li></ol><h2 id="_35-master-选举" tabindex="-1">35 Master 选举 <a class="header-anchor" href="#_35-master-选举" aria-hidden="true">#</a></h2><p>es 的选主是 <code>ZenDiscovery</code> 模块负责的，主要包含 <code>Ping</code> 和 <code>Unicast</code> 这两部分</p><ul><li><code>es.yml</code> 配置文件中确定当master 节点最少票数阈值，确认候选主节点的最少投票通过数量，<code>es.yml </code>设置的值 <code>discovery.zen.minimum_master_nodes</code></li><li>每个节点给能 ping 通的 <code>nodeId</code> 最小的节点投票，对所有候选 master 的节点（<code>node.master: true</code>）根据 <code>nodeId</code> 字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点。</li><li>选举投票达到阈值且选举了自己的节点为 master 节点，如果对某个节点的投票数达到阈值，并且该节点自己也选举自己，那这个节点就是 master。否则重新选举一直到满足上述条件。</li></ul><h2 id="_36-集群健康度" tabindex="-1">36 集群健康度 <a class="header-anchor" href="#_36-集群健康度" aria-hidden="true">#</a></h2><p>为了保证集群的高可用，分片是要被分配到不同节点上的 yellow 或 red 原因是分片没有被合理分配，可以通过 <code>_cluster/allocation/explain</code> 查看具体原因</p><ul><li>红：至少有一个主分片没有分配（节点挂了、存储空间不足等）</li><li>黄：至少有一个副本没有分配（节点不够）</li><li>绿：主副本分片全部正常分配</li></ul><h2 id="_37-主分片数不能修改" tabindex="-1">37 主分片数不能修改 <a class="header-anchor" href="#_37-主分片数不能修改" aria-hidden="true">#</a></h2><ol><li>因为 es 在存储文档时，会根据主分片数和文档 id ，通过 hash 算法，计算出文档应该分布在哪个分片上，确保了文档可以均匀的分布在各个分片中。</li><li>如果修改了主分片数，那计算规则就变了，会导致文档不能均匀的分布在各个分片中。保存文档时，可以传_routing 参数，自定义存储到指定的分片上。</li></ol><h2 id="_38-es-vs-mysql-概念" tabindex="-1">38 ES vs MySQL 概念 <a class="header-anchor" href="#_38-es-vs-mysql-概念" aria-hidden="true">#</a></h2><ol><li>由于倒排索引一旦生成，不可改变，所以每次新建文档（到某个分片），就会生成一个新的Segment，用来存储该分片上新的倒排索引。</li><li>关系型数据库中的数据库 <code>db</code> ，等价于es 中的索引 <code>index</code></li><li>一个数据库下面有 n 张表（table），等价于 1 个索引 index 下面有 n 多类型 （type）</li><li>一个数据库表下的数据由多行 row 多列 column ，等价于 es 中由多个文档 document 和多 field 组成。</li><li>在一个关系型数据库里面，schema 定义了表，每个表的字段，还有表和字段之间的关系，与之对应的，在 es 中，mapping 定义索引下的 type 的</li></ol><h2 id="_39-性能优化" tabindex="-1">39 性能优化 <a class="header-anchor" href="#_39-性能优化" aria-hidden="true">#</a></h2><blockquote><p>参考</p></blockquote><p><a href="https://blog.csdn.net/wlei0618/article/details/124104738" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/wlei0618/article/details/124104738</a></p><p><a href="https://juejin.cn/post/6862238580094435342" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6862238580094435342</a></p></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-17T02:57:15.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>