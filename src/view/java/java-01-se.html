<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java 标准版</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_view_java_java-01-se.md.d50e6d5e.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#_01-构造" data-v-2d325df8>01 构造</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-继承" data-v-2d325df8>02 继承</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-和equals和hashcode" data-v-2d325df8>03 ==和equals和hashCode</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-序列化" data-v-2d325df8>04 序列化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_05-linkedhashmap" data-v-2d325df8>05 LinkedHashMap</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-cloneable接口实现原理" data-v-2d325df8>06 Cloneable接口实现原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-数据库连接池的工作机制" data-v-2d325df8>07 数据库连接池的工作机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-接口和抽象类的区别" data-v-2d325df8>08 接口和抽象类的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-错误" data-v-2d325df8>09 错误</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-异常分类" data-v-2d325df8>10 异常分类</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-注解" data-v-2d325df8>11 注解</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-序列化-serializable" data-v-2d325df8>12 序列化 Serializable</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-如何进行进程通信" data-v-2d325df8>13 如何进行进程通信</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-页面置换算法" data-v-2d325df8>14 页面置换算法</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-进程的内核态和用户态" data-v-2d325df8>15 进程的内核态和用户态</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-进程调度算法" data-v-2d325df8>16 进程调度算法</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_17-如何实现进程同步" data-v-2d325df8>17 如何实现进程同步</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_18-什么是死锁" data-v-2d325df8>18 什么是死锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_19-什么是虚拟内存" data-v-2d325df8>19 什么是虚拟内存</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_20-什么是上下文切换" data-v-2d325df8>20 什么是上下文切换</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_21-进程比线程上下文切换代价高" data-v-2d325df8>21 进程比线程上下文切换代价高</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_22-时间片概念" data-v-2d325df8>22 时间片概念</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_23-段-页式存储" data-v-2d325df8>23 段/页式存储</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_24-内存管理方式" data-v-2d325df8>24 内存管理方式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_25-synchronized-锁升级" data-v-2d325df8>25 synchronized 锁升级</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_26-synchronized-底层实现" data-v-2d325df8>26 synchronized 底层实现</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_27-synchronized-vs-volatile" data-v-2d325df8>27 synchronized vs volatile</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_28-synchronized-vs-lock" data-v-2d325df8>28 synchronized vs Lock</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_29-synchronized-vs-reentrantlock" data-v-2d325df8>29 synchronized vs ReentrantLock</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_30-说一下-atomic-的原理？" data-v-2d325df8>30 说一下 atomic 的原理？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_31-threadlocal" data-v-2d325df8>31 ThreadLocal</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_32-cyclicbarrier-vs-countdownlatch" data-v-2d325df8>32 CyclicBarrier vs CountDownLatch</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_33-synchronized-作用" data-v-2d325df8>33 Synchronized 作用</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_34-volatile关键字" data-v-2d325df8>34 volatile关键字</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_35-cas" data-v-2d325df8>35 CAS</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_36-string" data-v-2d325df8>36 String</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_38-map" data-v-2d325df8>38 Map</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_40-list" data-v-2d325df8>40 List</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_41-高并发中的集合有哪些问题" data-v-2d325df8>41 高并发中的集合有哪些问题</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_42-synchronized" data-v-2d325df8>42 synchronized</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_43-volatile" data-v-2d325df8>43 volatile</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_44-future" data-v-2d325df8>44 Future</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_45-threadlocal" data-v-2d325df8>45 ThreadLocal</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_46-线程调度器" data-v-2d325df8>46 线程调度器</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_47-异常" data-v-2d325df8>47 异常</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_48-线程安全" data-v-2d325df8>48 线程安全</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_49-线程池" data-v-2d325df8>49 线程池</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_50-volatile-synchronized-threadlocal" data-v-2d325df8>50 volatile &amp; synchronized &amp; ThreadLocal</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_51-加解密" data-v-2d325df8>51 加解密</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_52-bio-nio-aio" data-v-2d325df8>52 BIO &amp; NIO &amp; AIO</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_53-bin-log-undo-log-redo-log" data-v-2d325df8>53 bin log &amp; undo log &amp; redo log</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_54-synchronized-和-reentrantlock-是如何实现的" data-v-2d325df8>54 synchronized 和 ReentrantLock 是如何实现的</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_view_java_java-01-se" data-v-3886f8ec><div><h1 id="java-标准版" tabindex="-1">Java 标准版 <a class="header-anchor" href="#java-标准版" aria-hidden="true">#</a></h1><h2 id="_01-构造" tabindex="-1">01 构造 <a class="header-anchor" href="#_01-构造" aria-hidden="true">#</a></h2><blockquote><p>构造方法就是对类进行初始化。</p></blockquote><ol><li>如果你没有定义任何构造方法的形式，系统会为你自动调用一个 不带任何参数的构造函数，那么你产生的对象只能用不带参数的方法。</li><li>一般无参构造方法不需要我们写，每一个类都有无参构造方法，当创建实例化对象时，如果没有写构造方法，系统会默认调用无参构造方法，当写了构造方法时，就调用我们写了的构造方法。</li><li>使用<code>static</code>关键字定义的代码块，一般用于初始化静态成员属性，静态代码块不管生成多少个，其只会执行一次，且是最先执行的，然后就地初始化与普通代码块初始化看书写的先后顺序，写在前面的先执行，然后才是构造方法初始化。</li></ol><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#FF7B72;">class</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">A</span><span style="color:#C9D1D9;">{</span></span>
<span class="line"><span style="color:#C9D1D9;">    String</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">name</span><span style="color:#FF7B72;">=</span><span style="color:#A5D6FF;">&quot;丘比特&quot;</span><span style="color:#C9D1D9;">; </span><span style="color:#8B949E;">//就地初始化</span></span>
<span class="line"><span style="color:#C9D1D9;">    {</span></span>
<span class="line"><span style="color:#C9D1D9;">        System.out.</span><span style="color:#D2A8FF;">println</span><span style="color:#C9D1D9;">(</span><span style="color:#79C0FF;">this</span><span style="color:#C9D1D9;">.name);</span></span>
<span class="line"><span style="color:#C9D1D9;">        System.out.</span><span style="color:#D2A8FF;">println</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;我是普通代码块&quot;</span><span style="color:#C9D1D9;">);</span></span>
<span class="line"><span style="color:#C9D1D9;">    }</span></span>
<span class="line"><span style="color:#C9D1D9;">    </span><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">A</span><span style="color:#C9D1D9;">(){</span></span>
<span class="line"><span style="color:#C9D1D9;">        System.out.</span><span style="color:#D2A8FF;">println</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;构造方法初始化&quot;</span><span style="color:#C9D1D9;">);</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#79C0FF;">this</span><span style="color:#C9D1D9;">.name</span><span style="color:#FF7B72;">=</span><span style="color:#A5D6FF;">&quot;小丘比特&quot;</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"><span style="color:#C9D1D9;">        System.out.</span><span style="color:#D2A8FF;">println</span><span style="color:#C9D1D9;">(</span><span style="color:#79C0FF;">this</span><span style="color:#C9D1D9;">.name);</span></span>
<span class="line"><span style="color:#C9D1D9;">    }</span></span>
<span class="line"><span style="color:#C9D1D9;">    </span><span style="color:#FF7B72;">static</span><span style="color:#C9D1D9;"> {</span></span>
<span class="line"><span style="color:#C9D1D9;">        System.out.</span><span style="color:#D2A8FF;">println</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;我是静态代码块&quot;</span><span style="color:#C9D1D9;">);</span></span>
<span class="line"><span style="color:#C9D1D9;">    }</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">class</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">Test</span><span style="color:#C9D1D9;"> {</span></span>
<span class="line"><span style="color:#C9D1D9;">    </span><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">static</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">void</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">main</span><span style="color:#C9D1D9;">(</span><span style="color:#FF7B72;">String</span><span style="color:#C9D1D9;">[] </span><span style="color:#FFA657;">args</span><span style="color:#C9D1D9;">) {</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#FF7B72;">new</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">A</span><span style="color:#C9D1D9;">();</span></span>
<span class="line"><span style="color:#C9D1D9;">    }</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">输出结果</p><p>我是静态代码块</p><p>丘比特</p><p>我是普通代码块</p><p>构造方法初始化</p><p>小丘比特</p></div><h2 id="_02-继承" tabindex="-1">02 继承 <a class="header-anchor" href="#_02-继承" aria-hidden="true">#</a></h2><p>父类对象和子类对象可以调用本类中的对象。</p><p>子类中没有但是父类中有的方法会实现继承。</p><p><strong>子类在实现向上转型后，子类和父类方法中重名的方法将会被子类重写后的方法所覆盖（方法重写），不重名的方法将会得到子类的继承，当测试类中进行方法调用时，方法会以重写后的方法为准进行调用。</strong></p><ul><li>继承子类只能覆盖父类中的方法（方法重写），而不能覆盖父类中成员变量。</li><li>当有同名变量时，则变量之间相互独立，直接获取变量时依据变量前的对象类型进行获取，调用时依据对象在哪个类中进行调用。</li><li>方法一旦进行重写，再次被调用时均以重写后的方法为准，进行执行。</li><li>用子类对父类对象进行实例化是基于继承和子类对父类方法的重写而实现的。</li></ul><h2 id="_03-和equals和hashcode" tabindex="-1">03 ==和equals和hashCode <a class="header-anchor" href="#_03-和equals和hashcode" aria-hidden="true">#</a></h2><ol><li>==若是基本数据类型比较，是比较值；若是引用类型，则比较的是它们在内存中的存放地址。对象是存放在堆中的，栈中存放对象的引用，所以==是对栈中的值进行比较，若返回true代表变量的内存地址相等。</li><li>equals是object类中的方法，object类的equals方法用于判断对象的内存地址引用是不是同一个地址，若是类中覆盖了equals方法，就要根据具体代码来确定，一般覆盖后都是通过对象的内容是否相等来判断对象是否相等。</li><li>hashCode（）计算出对象实例的哈希码，在对象进行散列时作为key存入，之所以有hashCode方法，因为在批量的对象比较中，hashCode比较要比equals快，在添加新元素时，先调用这个元素的hashCode方法，一下子能定位到它应该旋转的物理位置，若位置没有元素，可直接存储，若该位置有元素，就调用它的equals方法与新元素进行比较，若相同则不存，不相同就放到该位置的链表末端。</li><li>equals与hashCode方法联系：hashCode()是一个本地方法，实际是根据本地机器相关的，equals()相等的对象，hashCode（）也不一定相等，所以在重写equals(Object obj)方法有必要重写hashCode()方法，确保通过equal(Object obj)方法判断结果为true的两个具备相等的hashCode（）返回值。</li><li>equals与==的关系：Integer b1 = 127；在java编译时被编译成Integer b1 = Integer.valueOf(127);对于-128~127的Integer值，用的原生数据类型int，会在内存里共重用，也就是这之间的Integer值进行==比较时，只是进行int原生数据类型的数据进行比较。而超出-128~127的范围，进行==比较时进行地址及数值比较。</li></ol><h2 id="_04-序列化" tabindex="-1">04 序列化 <a class="header-anchor" href="#_04-序列化" aria-hidden="true">#</a></h2><ol><li>将一个对象转换成可存储或可传输的状态，序列化后的对象可以在网络上传输，也可以存储到本地，或实现跨进程传输。</li><li>开发过程中，我们需要将对象的引用传给其他activiy或fragment使用时，需要将这些对象放到一个Intent或Bundle中，再进行传递，而Intent或Bundle只能识别基本数据类型和被序列化的类型。</li><li>Serializable在序列化时会产生大量的临时变量，引起频繁GC。本质上是用了反射，序列化过程慢。若持久化操作选Serializable，若仅内存中使用，优先Parcelable。</li><li><strong>String 转换成Integer方式及原理</strong> parseInt（String s）内部调用parseInt(s , 10)默认为10进制</li><li>正常判断null、进制范围，length等</li><li>判断第一个字符是否是符号位</li><li>循环遍历确定每个字符的十进制值</li><li>通过 “*=”和“-=”进行计算拼接</li><li>判断是否负值返回结果</li></ol><h2 id="_05-linkedhashmap" tabindex="-1">05 LinkedHashMap <a class="header-anchor" href="#_05-linkedhashmap" aria-hidden="true">#</a></h2><p>基于LinkedHashMap的访问顺序的特点，可构造一个LRU（Least Recently Used）最近最少使用简单缓存，也有一些开源的缓存产品如ehcache的淘汰策略就是在LinkedHashMap上扩展的。</p><h2 id="_06-cloneable接口实现原理" tabindex="-1">06 Cloneable接口实现原理 <a class="header-anchor" href="#_06-cloneable接口实现原理" aria-hidden="true">#</a></h2><ol><li>拷贝的是一个类的实例中各字段的值。</li><li>浅拷贝是指拷贝对象时仅仅拷贝对象本身（包含对象中的基本变量），而不拷贝对象包含的引用指向的对象。</li><li>深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><p>对象A1中包含B1的引用，B1中包含C1的引用。</p></li><li><p>浅拷贝A1得到A2。A2中依然包含B1的引用，B1中依然包含对C1的引用。</p></li><li><p>深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，</p></li><li><p>B2中包含对C2(C1的copy)的引用,若不对clone()方法进行改写，则调用方法得到的对象即为浅拷贝。</p></li></ul></div><h2 id="_07-数据库连接池的工作机制" tabindex="-1">07 数据库连接池的工作机制 <a class="header-anchor" href="#_07-数据库连接池的工作机制" aria-hidden="true">#</a></h2><ol><li>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。</li><li>客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其标记为忙。</li><li>如果当没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。</li><li>当使用的池连接调用完成后，池驱动程序将此连接标记为空闲，其他调用就可以使用这个连接。</li></ol><div class="tip custom-block"><p class="custom-block-title">实现方式</p><ul><li>返回的Connection是原始Connection的代理，代理Connection的close方法不是真正关闭连接，</li><li>而是把它代理的Connection对象还回到连接池中。</li></ul></div><h2 id="_08-接口和抽象类的区别" tabindex="-1">08 接口和抽象类的区别 <a class="header-anchor" href="#_08-接口和抽象类的区别" aria-hidden="true">#</a></h2><ol><li>接口中所有方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。</li><li>类可以实现很多个接口。但是只能继承一个抽象类。</li><li>类如果要实现一个接口，它必须要实现接口声明的所有方法，但是类可以不是实现。</li><li>抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li><li>抽象类可以不提供接口方法实现的情况下实现接口。</li><li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</li><li>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private、protected或者public。</li><li>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的 。</li></ol><h2 id="_09-错误" tabindex="-1">09 错误 <a class="header-anchor" href="#_09-错误" aria-hidden="true">#</a></h2><ol><li>向用户通告错误、保存所有的工作结果、允许用户以妥善的形式退出程序、可能造成程序崩溃的错误输入，称为异常处理</li></ol><div class="danger custom-block"><p class="custom-block-title">处理错误</p><ol><li><p>如果由于出现错误而使得某些操作没有完成，程序应该返回到一种安全状态， 并能够让用户执行一些其他的命令。或者允许用户保存所有操作的结果，并以妥善的方式终止程序。</p></li><li><p>异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。 为了能够在程序中处理异常情况，必须研究程序中可能出现的错误和问题，以及哪类问题需要关注。</p><ul><li>用户输入错误，在程序代码中应该对此进行检查，如果没有检查，网络层就会给出警告</li><li>设备错误</li><li>物理限制</li><li>代码错误</li></ul></li></ol></div><h2 id="_10-异常分类" tabindex="-1">10 异常分类 <a class="header-anchor" href="#_10-异常分类" aria-hidden="true">#</a></h2><ol><li>派生于RuntimeException的异常包含下面几种情况：错误的类型转换、数组访问越界、访问null指针</li><li>不派生于RuntimeException的异常包括 <ul><li>试图在文件尾部后面读取数据</li><li>试图打开一个不存在的文件</li><li>视图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在</li></ul></li><li>如果出现RuntimeException异常，那么就一定是你的问题。</li></ol><h2 id="_11-注解" tabindex="-1">11 注解 <a class="header-anchor" href="#_11-注解" aria-hidden="true">#</a></h2><ol><li>注解不会改变程序的编译方式，java编译器对于包含注解和不包含注解的代码会生成相同的虚拟机指令。</li><li>注解的一些可能用法： <ul><li>附属文件的自动生成，例如部署描述符或者bean信息类</li><li>测试、日志、事务语义等代码的自动生成</li></ul></li></ol><h2 id="_12-序列化-serializable" tabindex="-1">12 序列化 Serializable <a class="header-anchor" href="#_12-序列化-serializable" aria-hidden="true">#</a></h2><ul><li>java提供的序列化接口，它是一个空接口。</li><li>Serializable用来标识当前类可以被ObjectOutputStream 序列化，以及被ObjectInputStream反序列化。</li><li>用transient关键字标记的成员变量不参与序列化</li><li>静态成员属于类不属于对象，所以不会参与序列化。对象序列化保存的是对象的“状态”，</li><li>也就是它的成员变量，因此序列化不会关注静态变量。</li><li>可序列化类中，未实现Serializable的属性状态无法被序列化/反序列化。</li><li>也就是说，反序列化一个类的过程中，它的非可序列化的属性将会调用无参构造函数重新创建。</li><li>因此这个属性的无参构造函数必须可以访问，否则运行时会报错。</li></ul><div class="tip custom-block"><p class="custom-block-title">序列化作用</p><ul><li><p>序列化是将对象转换为字节流。</p></li><li><p>反序列化是将字节流转换为对象</p></li><li><p>序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中。</p></li><li><p>在网络上传递对象的字节序列。</p></li><li><p>RMI远程方法调用。</p></li><li><p>注：使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来再将这些字节组装成对象。</p></li><li><p>必须注意的是，对象序列化保存的是对象的“状态”，即它的成员变量。</p></li><li><p>由此可知，对象序列化不会关注类中的静态变量。</p></li></ul></div><div class="danger custom-block"><p class="custom-block-title">能序列化的前提</p><p>如果一个类想被序列化，需要实现Serializable接口进行自动序列化，或者实现Extetnalizable接口进行</p></div><blockquote><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p></blockquote><p><strong>以下情况需要使用Java 序列化：</strong></p><ul><li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过RMI（远程方法调用）传输对象的时候。</li></ul><h2 id="_13-如何进行进程通信" tabindex="-1">13 如何进行进程通信 <a class="header-anchor" href="#_13-如何进行进程通信" aria-hidden="true">#</a></h2><ol><li>共享存储：两个进程通过对一块共享空 间的访问实现通信。各进程对共享空间的访问是互斥的。又可以细分为基于数据结构（共享空间放一个长度为10的数组，这种共享方式比较慢，是一种低级的通信方式） 基于存储区（在内存中划一块共享储存区，数据的形式 存放位置都由进程控制，而不是OS，相比之下这种共享方式更快，是一种高级通信方式）。</li></ol><blockquote><p>共享内存通信的优缺点：可以解决消息队列通信带来的数据拷贝带来的开销问题。</p></blockquote><ol start="2"><li>消息队列传递：进程间的数据交换以格式化信息为单位，进程通过OS提供的发送消息/接收消息两个原语进行数据交换。消息队列是保存在内核中的消息链表。</li></ol><ul><li>直接通信方式：消息直接挂到接收进程的消息缓冲队列上</li><li>间接通信方式：消息要先发送到中间实体（信箱）中。</li></ul><div class="tip custom-block"><p class="custom-block-title">消息队列通信的优缺点：</p><p>首先解决了管道通信的不适合进程频繁通信的问题。但是它的缺点是：一，通信不及时。二，附件有大小的限制。三，通信过程中会存在着用户态与内核态之间的数据拷贝带来的开销。</p></div><ol start="3"><li>管道通信：管道是指用于连接读写进程的一个共享文件，又名pipe，其实就是内存中开辟的一个大小固定的缓冲区。单管道只能进行半双工通信。Linux中管道符为 | 。</li></ol><div class="tip custom-block"><p class="custom-block-title">管道通信的优缺点：</p><p>管道通信的效率低，不适合进程间频繁的交换数据，好处是简单，我们很容易的就可以知道管道中的数据被另一个进程读取。</p></div><ol start="4"><li>信号量</li><li>Socket</li></ol><blockquote><p>前面提到的管道 消息队列 共享内存 信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</p></blockquote><h2 id="_14-页面置换算法" tabindex="-1">14 页面置换算法 <a class="header-anchor" href="#_14-页面置换算法" aria-hidden="true">#</a></h2><p>现在大多数都采用了虚拟内存技术，所以需要页面置换算法。</p><div class="tip custom-block"><p class="custom-block-title">什么是页面置换</p><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断（要访问的资源不存在，由用户态陷入内核态调用相关资源，是一种内中断）从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p></div><ol><li><p>最佳置换算法（OPT）是一种仅存在于理论中的算法，因为无法得知哪一个页面是最长时间没有被访问的。</p></li><li><p>先进先出置换算法（FIFO）把调入内存的页面根据调入的先后顺序排成一个队列，队列的大小为OS为进程分配的多少个内存块。需要置换的时候将第一个进入队列的页调出。该算法并不符合实际的运行规律。</p></li><li><p>最近最久未使用置换算法（LRU）每次淘汰的是最近最久未使用的页面。页表中用访问字段记录该页面自上次访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页中t值最大的。 算法性能较好，但是开销较大</p></li><li><p>时钟置换算法（CLOCK）</p></li></ol><div class="tip custom-block"><p class="custom-block-title">实现过程：</p><ul><li>为页面设置一个访问位，然后将内存中的页面通过指针连结成一个循环队列。</li><li>当某个页被访问时，访问位置1。当需要淘汰一个页时，只需要检查访问位，0则换出；如果是1则置0，暂不换出，继续检查下一个页面访问位。最多经过两轮检查会找到一个淘汰页面。</li><li>时钟置换算法是一种兼顾性能与开销的算法。</li></ul></div><h2 id="_15-进程的内核态和用户态" tabindex="-1">15 进程的内核态和用户态 <a class="header-anchor" href="#_15-进程的内核态和用户态" aria-hidden="true">#</a></h2><p>为了维护OS安全，设置了特权级概念。运行于不同特权级的进程所拥有的权限也不同。大部分进程都是运行在用户态的。只有当需要完成一些自己本身权限无法完成的业务时，会通过系统调用切换到内核态来让操作系统帮忙执行。</p><h2 id="_16-进程调度算法" tabindex="-1">16 进程调度算法 <a class="header-anchor" href="#_16-进程调度算法" aria-hidden="true">#</a></h2><p>为什么需要进程调度 由于cpu资源的有限性，导致需要一套完整的算法来对进程做一个管理。</p><div class="tip custom-block"><p class="custom-block-title"><strong>非抢占式调度算法</strong></p><ol><li>先来先服务（FCFS，first come first served）：进程按照它们请求CPU的顺序使用CPU.就像你买东西去排队，谁第一个排，谁就先被执行，在它执行的过程中，不会中断它。当其他人也想进入内存被执行，就要排队等着，如果在执行过程中出现一些事，他现在不想排队了，下一个排队的就补上。此时如果他又想排队了，只能站到队尾去</li><li>最短作业优先 （SJF, Shortest Job First）：对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。对于长进程不利，可能会导致长进程的饥饿。</li></ol></div><div class="tip custom-block"><p class="custom-block-title"><strong>抢占式调度算法</strong></p><ol><li>最短剩余时间优先 ：是最短作业优先的抢占版本，按照剩余运行时间进行调度。当一个新作业到达时，其整个的运行时间与当前运行进程的剩余时间对比。如果新的进程所需时间更少会将当前运行进程挂起，运行新的进程。</li><li>时间片轮转算法（RR，Round-Robin）：每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按照FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。</li><li>多级反馈队列(Multilevel Feedback Queue) ：如果一个进程需要执行100个时间片，如果采用时间片轮转算法则需要交换100次，多级队列专门为了这种需要连续执行多个时间片的进程考虑。它设置多个队列。每个队列时间片的大小也不相同。假设现在有四个队列。时间片分别为 1 2 4 8那么一个需要100时间片的进程仅需要交换7次（100/（1+2+4+8）= 7）。 进程在队列1中执行结束后进入队列2.....依次直到进程耗尽时间片。最上面的队列优先级最高，只有当上一个队列没有进程排队，才能调度当前队列的进程。</li></ol></div><h2 id="_17-如何实现进程同步" tabindex="-1">17 如何实现进程同步 <a class="header-anchor" href="#_17-如何实现进程同步" aria-hidden="true">#</a></h2><p>什么是进程同步 多个进程按照一定的顺序执行。</p><blockquote><p><strong>信号量机制</strong> 、<strong>管程</strong></p></blockquote><h2 id="_18-什么是死锁" tabindex="-1">18 什么是死锁 <a class="header-anchor" href="#_18-什么是死锁" aria-hidden="true">#</a></h2><p>多个进程在运行过程中因资源争夺而造成的一种僵局。</p><div class="danger custom-block"><p class="custom-block-title">死锁的必要条件</p><ul><li>互斥：被争夺的资源要么分配给了一个进程要么就是可用的</li><li>请求与保持：已经得到资源的进程依旧可以申请新资源</li><li>不可抢占：已经分配的资源不可以强制性的被抢占，只能被拥有者显式释放</li><li>环路等待：有两个或以上的进程形成一条环路。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">如何处理死锁</p><ol><li>鸵鸟策略：假装没有发生死锁</li><li>死锁检测与死锁恢复</li><li>死锁预防：破坏死锁产生的必要条件，破坏互斥条件 不可抢占条件 环路等待条件。</li><li>死锁避免：在程序运行时避免发生死锁。</li></ol></div><h2 id="_19-什么是虚拟内存" tabindex="-1">19 什么是虚拟内存 <a class="header-anchor" href="#_19-什么是虚拟内存" aria-hidden="true">#</a></h2><p>对于一些很大的程序，将很快需要用到的页装入内存，当需要访问的页不在内存时再由OS外存调入（依据页面置换算法）。当内存吃紧时，再由OS将内存中暂时不用的信息换出到外存。这就是虚拟内存技术。</p><h2 id="_20-什么是上下文切换" tabindex="-1">20 什么是上下文切换 <a class="header-anchor" href="#_20-什么是上下文切换" aria-hidden="true">#</a></h2><p>将CPU资源从一个进程分配到另一个进程的机制。在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p><h2 id="_21-进程比线程上下文切换代价高" tabindex="-1">21 进程比线程上下文切换代价高 <a class="header-anchor" href="#_21-进程比线程上下文切换代价高" aria-hidden="true">#</a></h2><p>进程切换分两步：</p><ul><li>切换页目录以使用新的地址空间</li><li>切换内核栈和硬件上下文</li><li>线程切换不需要切换页目录。</li></ul><h2 id="_22-时间片概念" tabindex="-1">22 时间片概念 <a class="header-anchor" href="#_22-时间片概念" aria-hidden="true">#</a></h2><p>是时分操作系统分配给每个正在运行的进程微观上的一段CPU时间。</p><h2 id="_23-段-页式存储" tabindex="-1">23 段/页式存储 <a class="header-anchor" href="#_23-段-页式存储" aria-hidden="true">#</a></h2><ul><li>分页存储：将内存空间分成的一个个大小相等的分区，每一个页有自己的编号，页框不能设置太大，否则会产生内部碎片。不方便按照逻辑模块实现信息的共享。</li><li>分段存储：信息的逻辑单位，很方便的按照逻辑模块实现信息的共享，缺点是可能会由于段长度过大导致。</li></ul><h2 id="_24-内存管理方式" tabindex="-1">24 内存管理方式 <a class="header-anchor" href="#_24-内存管理方式" aria-hidden="true">#</a></h2><ul><li>物理内存管理：包括程序装入等概念 交换技术 连续分配管理方式和非连续分配管理方式（分页 分段 段页式）。</li><li>虚拟内存管理：虚拟内存管理包括虚拟内存概念 请求分页管理方式 页面置换算法 页面分配策略 工作集和抖动。</li></ul><h2 id="_25-synchronized-锁升级" tabindex="-1">25 synchronized 锁升级 <a class="header-anchor" href="#_25-synchronized-锁升级" aria-hidden="true">#</a></h2><ol><li>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，</li><li>jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，</li><li>如果一致则可以直接使用此对象，</li><li>如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，</li><li>如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</li></ol><div class="tip custom-block"><p class="custom-block-title">锁的升级的目的</p><p>锁升级是为了减低了锁带来的性能消耗。 在Java 6 之后优化 synchronized 的实现方式， 使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p></div><h2 id="_26-synchronized-底层实现" tabindex="-1">26 synchronized 底层实现 <a class="header-anchor" href="#_26-synchronized-底层实现" aria-hidden="true">#</a></h2><ol><li>synchronized 是由一对 monitorenter/monitorexit 指令实现的，</li><li>monitor 对象是同步的基本实现单元。</li><li>在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，</li><li>因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。</li><li>但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，</li><li>也就是常说的三种不同的锁：<strong>偏向锁（Biased Locking）</strong>、<strong>轻量级锁</strong>和<strong>重量级锁</strong>，大大改进了其性能。</li></ol><h2 id="_27-synchronized-vs-volatile" tabindex="-1">27 synchronized vs volatile <a class="header-anchor" href="#_27-synchronized-vs-volatile" aria-hidden="true">#</a></h2><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul><h2 id="_28-synchronized-vs-lock" tabindex="-1">28 synchronized vs Lock <a class="header-anchor" href="#_28-synchronized-vs-lock" aria-hidden="true">#</a></h2><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；</li><li>而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h2 id="_29-synchronized-vs-reentrantlock" tabindex="-1">29 synchronized vs ReentrantLock <a class="header-anchor" href="#_29-synchronized-vs-reentrantlock" aria-hidden="true">#</a></h2><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大， 但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><div class="tip custom-block"><p class="custom-block-title">主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul></div><h2 id="_30-说一下-atomic-的原理？" tabindex="-1">30 说一下 atomic 的原理？ <a class="header-anchor" href="#_30-说一下-atomic-的原理？" aria-hidden="true">#</a></h2><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作， 从而避免 synchronized 的高开销，执行效率大为提升。</p><h2 id="_31-threadlocal" tabindex="-1">31 ThreadLocal <a class="header-anchor" href="#_31-threadlocal" aria-hidden="true">#</a></h2><ol><li>为每个使用该变量的线程提供独立的变量副本，</li><li>所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</li></ol><blockquote><p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p></blockquote><h2 id="_32-cyclicbarrier-vs-countdownlatch" tabindex="-1">32 CyclicBarrier vs CountDownLatch <a class="header-anchor" href="#_32-cyclicbarrier-vs-countdownlatch" aria-hidden="true">#</a></h2><ol><li>CountDownLatch简单的说就是一个线程等待，直到它所等待的其他线程都执行完成并调用countDown（）方法发出通知后，当前线程才可以继续执行。</li><li>cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await（）方法之后，所有线程同时开始执行。</li><li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可使用reset（）方法重置，CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li><li>CyclicBarrier提供其他方法，比如getNumberWaiting方法获得CyclicBarrier阻塞的线程数量，isBroken方法用来知道阻塞的线程是否被中断，如果被中断，返回true，否则返回false。</li></ol><h2 id="_33-synchronized-作用" tabindex="-1">33 Synchronized 作用 <a class="header-anchor" href="#_33-synchronized-作用" aria-hidden="true">#</a></h2><p>synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行， synchronized 既既可以加上一段代码上，也可以加在方法上。</p><h2 id="_34-volatile关键字" tabindex="-1">34 volatile关键字 <a class="header-anchor" href="#_34-volatile关键字" aria-hidden="true">#</a></h2><p>volatiel关键字来保证可见性，当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存， 当有其他线程需要读取时，它会去内存中读取新值， 从实践角度而言，volatile的一个重要作用就是CAS结合，保证了原子性</p><h2 id="_35-cas" tabindex="-1">35 CAS <a class="header-anchor" href="#_35-cas" aria-hidden="true">#</a></h2><p>compare and swap，比较交换 cas是一种基于锁的操作，是乐观锁。</p><div class="tip custom-block"><p class="custom-block-title">在java中锁分为乐观锁和悲观锁，</p><ul><li>悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问，</li><li>而乐观锁通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大提高。</li></ul></div><ul><li><p>cas操作包含三个操作数，内存位置（V）、预期原值（A）和新值（B）。 如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。</p></li><li><p>cas是通过无限循环来获取数据的，若第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有机会执行。</p></li><li><p>java.util.concurrent.atomic包下的类大多是使用CAS操作类实现的AtomicInteger，AtomicBoolean，AtomicLong</p></li></ul><div class="danger custom-block"><p class="custom-block-title">CAS问题</p><ol><li>CAS容易造成ABA问题。一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题</li><li>不能保证代码的原子性。CAS机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性，需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。</li><li>CAS造成CPU利用率增加。之前说过CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，CPU资源会一直被占用。</li></ol></div><h2 id="_36-string" tabindex="-1">36 String <a class="header-anchor" href="#_36-string" aria-hidden="true">#</a></h2><ol><li>String类是final型，不能被继承，它的成员方法也默认为final方法，String对象一旦创建就固定不变了，</li><li>对String对象的任何改变都不影响到原对象，相关的任何改变操作都会生成新的String对象。</li><li>String类通过char数组来保存字符串的，String对equals方法进行了重定，比较的是值相等。</li></ol><h2 id="_38-map" tabindex="-1">38 Map <a class="header-anchor" href="#_38-map" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">HashMap</p><ol><li>以键值对的形式存储元素</li><li>需要一个hash函数，它使用hashCode（）和equals（）方法来向集合、添加和检索元素。</li><li>当调用put（）方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合合适的索引上。如果key已经存在了，value会被更新成新值。</li><li>HashMap特性：容量、负载因子、扩容极限</li></ol></div><div class="tip custom-block"><p class="custom-block-title">HashMap JDK1.7</p><blockquote><p>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p></blockquote><ol><li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li><li>loadFactor：负载因子，默认为 0.75。</li><li>threshold：扩容的阈值，等于 capacity * loadFactor</li></ol></div><div class="tip custom-block"><p class="custom-block-title">HashMap JDK1.8</p><ol><li>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</li><li>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，</li><li>但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，</li><li>时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，</li><li>在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，</li><li>在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</li></ol></div><div class="tip custom-block"><p class="custom-block-title">LinkedHashMap</p><ul><li>底层是基于拉链式散列结构即由数组和链表或红黑树组成。</li><li>增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序，同时通过对链表进行相应的操作，实现了访问顺序相关的逻辑。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">ConcurrentHashMap JDK1.7</p><ul><li>JDK1.7时，对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，</li><li>多线程访问容器里不同数据段的数据，就不存在锁竞争，提高并发访问率</li><li>一个ConcurrentHashMap里面包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，</li><li>一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构元素，</li><li>每一个Segment守护着一个HashEntry数组里的元素</li><li>当对HashEntry数组进行修改时，必须首先获得对应的Segment的锁。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">ConcurrentHashMap JDK1.8</p><ul><li>JDK1.8时，摒弃了Segment的概念，直接用Node数组+链表+红黑树的数据结构实现，</li><li>并发控制使用synchronized和CAS来操作。整个看起来就像优化过且线程安全的HashMap.</li><li>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍</li></ul></div><div class="danger custom-block"><p class="custom-block-title">HashMap线程安全的方式</p><p>HashMap不是线程安全的,往往在写程序时需要通过一些方法来回避.其实JDK原生的提供了2种方法让HashMap支持线程安全.</p><ul><li><p>方法一:通过Collections.synchronizedMap()返回一个新的Map,这个新的map就是线程安全的. 这个要求大家习惯基于接口编程,因为返回的并不是HashMap,而是一个Map的实现.</p></li><li><p>方法二:重新改写了HashMap,具体的可以查看java.util.concurrent.ConcurrentHashMap. 这个方法比方法一有了很大的改进.</p></li><li><p>方法一特点:通过Collections.synchronizedMap()来封装所有不安全的HashMap的方法,就连toString, hashCode都进行了封装. 封装的关键点有2处,</p></li><li><p>1)使用了经典的synchronized来进行互斥,</p></li><li><p>2)使用了代理模式new了一个新的类,这个类同样实现了Map接口.在Hashmap上面,synchronized锁住的是对象,所以第一个申请的得到锁,其他线程将进入阻塞,等待唤醒. 优点:代码实现十分简单,一看就懂.缺点:从锁的角度来看,方法一直接使用了锁住方法,基本上是锁住了尽可能大的代码块.性能会比较差.</p></li><li><p><strong>方法二</strong>特点:重新写了HashMap,比较大的改变有如下几点.使用了新的锁机制,把HashMap进行了拆分,拆分成了多个独立的块,这样在高并发的情况下减少了锁冲突的可能,使用的是NonfairSync. 这个特性调用CAS指令来确保原子性与互斥性.当如果多个线程恰好操作到同一个segment上面,那么只会有一个线程得到运行.</p></li><li><p><strong>方法二</strong>优点:需要互斥的代码段比较少,性能会比较好. ConcurrentHashMap把整个Map切分成了多个块,发生锁碰撞的几率大大降低,性能会比较好. 缺点:代码繁琐</p></li></ul></div><h2 id="_40-list" tabindex="-1">40 List <a class="header-anchor" href="#_40-list" aria-hidden="true">#</a></h2><ol><li>ArrayList和LinkedList都实现了List接口，</li></ol><div class="tip custom-block"><p class="custom-block-title">不同点：</p><ul><li>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。</li><li>与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。</li><li>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</li><li>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</li></ul><div class="warning custom-block"><p class="custom-block-title">ArrayList vs LinkedList</p><ol><li>因为 Array 是基于索引 (index) 的数据结构，它使用索引在数组中搜索和读取数据是很快的。 Array 获取数据的时间复杂度是 O(1), 但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</li><li>相对于 ArrayList ， LinkedList 插入是更快的。因为 LinkedList 不像 ArrayList 一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是 ArrayList 最坏的一种情况，时间复杂度是 O(n) ，而 LinkedList 中插入或删除的时间复杂度仅为 O(1) 。 ArrayList 在插入数据时还需要更新索引（除了插入数组的尾部）。</li><li>类似于插入数据，删除数据时， LinkedList 也优于 ArrayList 。</li><li>LinkedList 需要更多的内存，因为 ArrayList 的每个索引的位置是实际的数据，而 LinkedList 中的每个节点中存储的是实际的数据和前后节点的位置 ( 一个 LinkedList 实例存储了两个值： Node first 和 Node last 分别表示链表的其实节点和尾节点，每个 Node 实例存储了三个值： E item,Node next,Node pre) 。</li></ol></div></div><div class="danger custom-block"><p class="custom-block-title">什么场景下更适宜使用 LinkedList，而不用ArrayList</p><ol><li>你的应用不会随机访问数据 。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。</li><li>你的应用更多的插入和删除元素，更少的读取数据 。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。</li></ol></div><blockquote><p>换句话说，ArrayList的实现用的是数组，LinkedList是基于链表，ArrayList适合查找，LinkedList适合增删 以上就是关于 ArrayList和LinkedList的差别。你需要一个不同步的基于索引的数据访问时， 请尽量使用ArrayList。ArrayList很快，也很容易使用。但是要记得要给定一个合适的初始大小，尽可能的减少更改数组的大小。</p></blockquote><h2 id="_41-高并发中的集合有哪些问题" tabindex="-1">41 高并发中的集合有哪些问题 <a class="header-anchor" href="#_41-高并发中的集合有哪些问题" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">第一代线程安全集合类</p><p>Vector、Hashtable</p><ul><li><p>是怎么保证线程安排的： 使用synchronized修饰方法*</p></li><li><p>缺点：效率低下</p></li></ul></div><div class="tip custom-block"><p class="custom-block-title"><strong>第二代线程非安全集合类</strong></p><p>ArrayList、HashMap</p><ul><li><p>线程不安全，但是性能好，用来替代Vector、Hashtable</p></li><li><p>使用ArrayList、HashMap，需要线程安全怎么办呢？</p></li><li><p>使用 Collections.<em>synchronizedList</em>(list); Collections.<em>synchronizedMap</em>(m);</p></li><li><p>底层使用synchronized代码块锁 虽然也是锁住了所有的代码，但是锁在方法里边，并所在方法外边性能可以理解为稍有提高吧。毕竟进方法本身就要分配资源的</p></li></ul></div><div class="tip custom-block"><p class="custom-block-title"><strong>第三代线程安全集合类</strong></p><ul><li><p>在大量并发情况下如何提高集合的效率和安全呢？</p></li><li><p>java.util.concurrent.*</p></li><li><p>ConcurrentHashMap：</p></li><li><p>CopyOnWriteArrayList ：</p></li><li><p>CopyOnWriteArraySet： 注意 不是CopyOnWriteHashSet*</p></li><li><p>底层大都采用Lock锁（1.8的ConcurrentHashMap不使用Lock锁），保证安全的同时，性能也很高。</p></li></ul></div><h2 id="_42-synchronized" tabindex="-1">42 synchronized <a class="header-anchor" href="#_42-synchronized" aria-hidden="true">#</a></h2><ul><li><p><code>synchronized</code>关键字是用来控制线程同步的，就是在多线程的环境下，控制<code>synchronized</code>代码段不被多个线程同时执行。</p></li><li><p><code>synchronized</code>即可加在一段代码上，也可加在方法上。</p></li></ul><h2 id="_43-volatile" tabindex="-1">43 volatile <a class="header-anchor" href="#_43-volatile" aria-hidden="true">#</a></h2><ul><li><p>Java提供<code>volatile</code>关键字保证可见性。</p></li><li><p>当一个共享变量被<code>volatile</code>修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p></li><li><p><code>volatile</code>和CAS结合，保证了原子性。</p></li></ul><h2 id="_44-future" tabindex="-1">44 Future <a class="header-anchor" href="#_44-future" aria-hidden="true">#</a></h2><ol><li><p>并发编程，通过实现Callback接口，可用Future接收多线程的执行结果。</p></li><li><p>Future表示一个可能还没有完成的异步任务的结果，针对这个结果可添加Callback以便在任务执行成功或失败后作出相应的操作。</p></li></ol><h2 id="_45-threadlocal" tabindex="-1">45 ThreadLocal <a class="header-anchor" href="#_45-threadlocal" aria-hidden="true">#</a></h2><ol><li><p>ThreadLocal是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p></li><li><p>ThreadLocal是一种以空间换时间的做法，每个Thread里面维护了一个以开地址实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享。</p></li></ol><h2 id="_46-线程调度器" tabindex="-1">46 线程调度器 <a class="header-anchor" href="#_46-线程调度器" aria-hidden="true">#</a></h2><ol><li><p>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间，一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。</p></li><li><p>时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可基于线程优先级或线程等待的时间。</p></li><li><p>线程调度并不受Java虚拟机控制，不要让你的程序依赖于线程的优先级。</p></li></ol><h2 id="_47-异常" tabindex="-1">47 异常 <a class="header-anchor" href="#_47-异常" aria-hidden="true">#</a></h2><ol><li>受检查异常编译器在编译期间检查，对于这种异常，方法强制处理或者通过throws子句声明，其中一种情况是Exception的子类但不是RuntimeExcepiton的子类。</li></ol><p>2.非受检查是RuntimeException的子类，在编译阶段不受编译器的检查。</p><h2 id="_48-线程安全" tabindex="-1">48 线程安全 <a class="header-anchor" href="#_48-线程安全" aria-hidden="true">#</a></h2><ol><li><p>线程安全：如果线程执行过程中不会产生共享资源的冲突，则线程安全。</p></li><li><p>线程不安全：如果有多个线程同时在操作主内存中的变量，则线程不安全。</p></li></ol><div class="tip custom-block"><p class="custom-block-title">实现线程安全的三种方式</p><ol><li>互斥同步</li></ol><ul><li>临界区：synchronized、reentrantLock</li><li>信号量：semaphore</li><li>互斥量：mutex</li></ul><ol start="2"><li>非阻塞同步（CAS compare and swap）</li><li>无同步方案：可重入代码，使用 ThreadLocal 类来包装共享变量，做到每个线程有自己的 copy</li></ol></div><h2 id="_49-线程池" tabindex="-1">49 线程池 <a class="header-anchor" href="#_49-线程池" aria-hidden="true">#</a></h2><p>核心参数</p><ul><li>核心线程数量大小</li><li>线程池最大容纳线程数</li><li>线程空闲后的存活时长</li><li>时间单位</li><li>缓存异步任务的队列</li><li>线程工厂用来构造线程池里的 worker 线程</li><li>线程池任务满载后采取的任务拒绝策略</li></ul><p>核心说明</p><ul><li>当线程池中线程数量小于核心线程数则创建线程，并处理请求。</li><li>当线程池中线程数量大于等于核心线程数时，则把请求放入对列中，随着线程池中的核心线程们不断执行任务，只要线程池中有空闲的核心线程，线程池就会从队列中取任务并处理。</li><li>当队列已存满，放不下新任务时则新建非核心线程入池，并处理请求直到线程数达到最大线程数量设置值。</li><li>如果线程池中线程数大于最大线程数，则使用拒绝策略来进行拒绝处理。</li></ul><p>线程池大小分配</p><ul><li>线程池究竟设置多大要看你的线程执行的什么任务了。CPU 密集型、IO 密集型、混合型、任务类型不同，设置的方式也不一样。</li><li>CPU 密集型：尽量使用较小的线程池，一般 CPU 核心数 + 1</li><li>IO 密集型：可以使用较大的线程池，一般 CPU 核心数 * 2</li><li>混合型：将任务分为 CPU 密集型和 IO 密集型，然后分别使用不同的线程池去处理，按情况而定</li></ul><h2 id="_50-volatile-synchronized-threadlocal" tabindex="-1">50 volatile &amp; synchronized &amp; ThreadLocal <a class="header-anchor" href="#_50-volatile-synchronized-threadlocal" aria-hidden="true">#</a></h2><p>volatile 原理</p><ul><li>volatile 变量进行写操作时，jvm 会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写到系统内存。</li><li>lock 前缀指令实际上相当于一个内存屏障，它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面，即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</li></ul><p>volatile 适用场景</p><ol><li>状态标志，初始化或请求停机</li><li>一次性安全发布，如：单列模式</li><li>独立观察，如：定期更新某个值</li><li>volatile bean 模式</li><li>开销较低的 &quot;读/写锁&quot; 策略，如计时器</li></ol><p>ThreadLocal 原理</p><ul><li>ThreadLocal 是用来维护本线程的变量的，并不能解决共享变量的并发问题。</li><li>ThreadLocal 是各线程将值存入该线程的 map 中，以 ThreadLocal 自身作为 key，需要用时获得的是该线程之前存入的值。</li><li>如果存入的是共享变量，那取出的也是共享变量，并发问题还是存在的。</li></ul><p>ThreadLocal 适用场景</p><ul><li>数据库连接、session 管理</li></ul><p>ThreadLocal 什么时候会出现 OOM 的情况</p><ol><li>ThreadLocal 变量是维护在 Thread 内部的，这样的话只要我们的线程不退出，对象的引用就会一直存在。</li><li>当线程退出时，Thread 类会进行一些清理工作，其中就包含 ThreadLocalMap</li><li>Thread 调用 exit 方法，ThreadLocal 在没有线程池使用的情况下，正常情况下不会存在内存泄露，但是如果使用了线程池的话，就依赖于线程池的实现，如果线程池不销毁线程的话，那么就会存在内存泄露。</li></ol><p>synchronized vs volatile</p><ol><li>volatile 主要应用在多个线程对应实例变量更改的场合，刷新主内存共享变量的值从而使得各个线程可以获得最新的值，线程读取变量的值需要从主内存中读取；</li><li>synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其它线程被阻塞住。</li><li>synchronized 还会创建一个内存屏障，内存屏障指令保证了 CPU 操作结果都会直接刷新到主存中（即锁释放前），从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作。</li><li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的</li><li>volatile 不会造成线程的阻塞。</li><li>synchronized 可能会造成线程的阻塞，比如多个线程争抢 synchronized 锁对象时，会出现阻塞。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性，而 synchronized 则可以保证变量修改可见性和原子性，因为线程获得锁才能进入临界区，从而保证临界区中的所有语句全部得到执行。</li><li>volatile 标记的变量不会被编译器优化，可以禁止进行指令重排。</li><li>synchronized 标记的变量可以被编译器优化。</li></ol><h2 id="_51-加解密" tabindex="-1">51 加解密 <a class="header-anchor" href="#_51-加解密" aria-hidden="true">#</a></h2><ol><li>数据保密，防止用户的数据被窃取或泄露</li><li>保证数据的完整性，防止用户传输的数据被篡改</li><li>通讯双方的身份确认，确保数据来源与合法的用户</li></ol><p>对称加密、非对称加密、单向加密</p><ol><li>对称密钥方式 <ol><li>加密解密都用相同的密钥</li><li>对称加密适合大量数据加密，安全性差</li><li>AES</li></ol></li><li>非对称加密 <ol><li>公钥私钥两种进行加解密</li><li>公钥和私钥是成对存在</li><li>公钥是从私钥中提取产生公开给所有人的</li><li>适合对密钥或身份信息等敏感信息加密</li><li>非对称加密过程： <ol><li>甲使用乙的公钥并结合相应的非对称算法将明文加密后发送给乙</li><li>乙收到密文后，结合自己的私钥和非对称算法解密得到明文，得到最初的明文。</li></ol></li><li>优点缺点 <ol><li>优点具有比对称密钥加/解密方式更高的安全性，因为加密和解密用的是不同密钥， 而且无法从一个密钥推导出另一个密钥，且公钥加密的信息只能用同一方的私钥进行解密。</li><li>非对称密钥加密的缺点算法非常复杂，导致加密大量数据所用的时间较长</li><li>加密过程也会添加较多附加信息，使得加密后的报文比较长，容易造成数据分片，不利于网络传输</li></ol></li><li>算法 <ol><li>RSA</li><li>开放平台支持的签名算法 <ul><li>RSA2(SHA256WithRSA):（强烈推荐使用），强制要求RSA密钥的长度至少为2048.</li><li>RSA(SHA1WithRSA):对RSA密钥的长度不限制，推荐使用2048位以上</li></ul></li></ol></li></ol></li><li>单向加密 <ol><li>只能对数据加密，无法解密，特点是定长输出</li><li>发送者将明文MD5，然后传递给接收方</li><li>接收方将用于比对验证的明文使用相同的单向加密算法进行加密</li><li>得出加密后的密文串进行对比，</li><li>若发送前和发送后的密文串相一致，则说明传输过程中数据没有损坏，</li><li>若不一致，说明传输过程中数据丢失了</li><li>算法 <ol><li>MD5</li></ol></li></ol></li></ol><h2 id="_52-bio-nio-aio" tabindex="-1">52 BIO &amp; NIO &amp; AIO <a class="header-anchor" href="#_52-bio-nio-aio" aria-hidden="true">#</a></h2><p>bio 同步并阻塞，服务器实现模式为一个连接一个线程， 即客户端有连接请求时服务器端就需要启动一个线程进行处理， 如果这个连接不做任何事情会造成不必要的线程开销</p><p>nio 同步非阻塞，服务器实现模式为一个线程处理多个请求（连接）， 即客户端发送的连接请求都会注册到多路复用器上， 多路复用器轮询到连接有I/O请求就进行处理</p><p>aio 异步非阻塞，服务器实现模式为一个有效请求一个线程， 客户端的I/O请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理， 一般适用于连接数较多且连接时间较长的应用</p><p>NIO有三大核心部分：Channel（通道）、Buffer（缓冲区）、Selector（选择器）</p><h2 id="_53-bin-log-undo-log-redo-log" tabindex="-1">53 bin log &amp; undo log &amp; redo log <a class="header-anchor" href="#_53-bin-log-undo-log-redo-log" aria-hidden="true">#</a></h2><p>binlog 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。</p><p>binlog 是通过追加的方式进行写入的，可以通过max_binlog_size参数设置每个binlog文件的大小， 当文件大小达到给定值之后，会生成新的文件来保存日志。</p><p>redo log 是只记录事务对数据页做了哪些修改，相对而言文件改动更小并且是顺序IO 一个是内存中的日志缓冲(redo log buffer)， 另一个是磁盘上的日志文件(redo log file)。</p><p>mysql 每执行一条 ML 语句，先将记录写入 redo log buffer，后续某个时间点再一次性将多个操作记录写到 redo log file</p><p>但只有 redo log 也不行，因为 redo log 是 InnoDB 特有的，且日志上的记录落盘后会被覆盖掉。 因此需要 binlog 和 redo log 二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p><p>原子性底层就是通过 undo log 实现的。 undo log 主要记录了数据的逻辑变化，比如一条 INSERT 语句，对应一条 DELETE 的 undo log 。</p><h2 id="_54-synchronized-和-reentrantlock-是如何实现的" tabindex="-1">54 synchronized 和 ReentrantLock 是如何实现的 <a class="header-anchor" href="#_54-synchronized-和-reentrantlock-是如何实现的" aria-hidden="true">#</a></h2><ol><li>synchronized 属于独占式悲观锁，是通过 JVM 隐式实现的，synchronized 只允许同一时刻只有一个线程操作资源。</li></ol><blockquote><p>在 java 中每个对象都隐式包含一个 monitor (监视器对象)，加锁的过程其实就是竞争 monitor 的过程，当线程进入字节码 monitorenter 指令之后， 线程将持有 monitor 对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。</p></blockquote><ol start="2"><li><p>ReentrantLock 是 Lock 的默认实现方式之一，它是基于 AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的， 在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1 ，并成功获得锁，而其他未获得锁 的线程只能排队等待获取锁资源。</p></li><li><p>synchronized 和 ReentrantLock 都提供了锁的功能，具备互斥性和不可见性。 在 jdk1.5 中 synchronized 的性能远远低于 ReentrantLock ，但在 JDK 1.6 之后 synchronized 的性能略低于 ReentrantLock，它的区别如下：</p></li></ol><div class="tip custom-block"><p class="custom-block-title">区别</p><ul><li>synchronized 是 jvm 隐式实现的，而 ReentrantLock 是 java 语言提供的 API</li><li>ReentrantLock 可设置为公平锁，而 synchronized 却不行。</li><li>ReentrantLock 只能修饰代码块，而 synchronized 可用于修饰方法，修饰代码块等</li><li>ReentrantLock 需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而 synchronized 无需手动释放锁。</li><li>ReentrantLock 可以知道是否成功获得了锁，而 synchronized 却不行。</li></ul></div></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-19T07:32:22.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>