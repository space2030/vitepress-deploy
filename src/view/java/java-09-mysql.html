<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_view_java_java-09-mysql.md.00f74996.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#_01-连接查询" data-v-2d325df8>01 连接查询</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-聚合函数" data-v-2d325df8>02 聚合函数</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-sql-关键字" data-v-2d325df8>03 SQL 关键字</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-sql-select-语句完整的执行顺序" data-v-2d325df8>04 SQL Select 语句完整的执行顺序</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_05-数据库三范式" data-v-2d325df8>05 数据库三范式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-存储引擎" data-v-2d325df8>06 存储引擎</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-数据库事务" data-v-2d325df8>07 数据库事务</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-索引" data-v-2d325df8>08 索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-索引的底层实现原理" data-v-2d325df8>09 索引的底层实现原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-如何避免索引失效" data-v-2d325df8>10 如何避免索引失效</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-数据库锁" data-v-2d325df8>11 数据库锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-悲观锁和乐观锁" data-v-2d325df8>12 悲观锁和乐观锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-mysql优化" data-v-2d325df8>13 MySQL优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-定位执行效率慢的sql语句" data-v-2d325df8>14 定位执行效率慢的sql语句</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-优化索引" data-v-2d325df8>15 优化索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-合理的数据库设计" data-v-2d325df8>16 合理的数据库设计</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_17-笛卡尔积" data-v-2d325df8>17 笛卡尔积</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_18-查数据库怎么防止sql注入" data-v-2d325df8>18 查数据库怎么防止sql注入</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_19-mysql走索引怎么查到数据" data-v-2d325df8>19 MySQL走索引怎么查到数据</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_20-b-树的特性" data-v-2d325df8>20 B+树的特性</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_21-mysql-常用的引擎" data-v-2d325df8>21 MySQL 常用的引擎</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_22-事务的-acid-特性在mysql中的实现" data-v-2d325df8>22 事务的 ACID 特性在MySQL中的实现</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_23-聚簇索引与非聚簇索引" data-v-2d325df8>23 聚簇索引与非聚簇索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_24-非聚簇索引的叶子节点储存什么数据" data-v-2d325df8>24 非聚簇索引的叶子节点储存什么数据</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_25-多字段查询如何设置索引" data-v-2d325df8>25 多字段查询如何设置索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_26-mvcc是什么原理" data-v-2d325df8>26 MVCC是什么原理</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_27-联合索引的数据结构" data-v-2d325df8>27 联合索引的数据结构</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_28-explain-查询到的字段" data-v-2d325df8>28 explain 查询到的字段</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_29-mysql的自增id用完了怎么办" data-v-2d325df8>29 MySQL的自增ID用完了怎么办</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_30-数据库中保存商品价格使用什么数据类型" data-v-2d325df8>30 数据库中保存商品价格使用什么数据类型</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_31-死锁" data-v-2d325df8>31 死锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_32-幻读" data-v-2d325df8>32 幻读</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_33-redo-log-undo-log" data-v-2d325df8>33 redo log / undo log</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_34-mysql中除了undo-log-以外还有什么操作是为了保证事务的一致性" data-v-2d325df8>34 MySQL中除了undo log 以外还有什么操作是为了保证事务的一致性</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_35-数据库是怎么去做持久性的，做持久性的时候可能会遇到什么问题" data-v-2d325df8>35 数据库是怎么去做持久性的，做持久性的时候可能会遇到什么问题</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_36-如何保证mysql的主从强一致性" data-v-2d325df8>36 如何保证MySQL的主从强一致性</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_37-如何保证mysql主从的高可用性" data-v-2d325df8>37 如何保证MySQL主从的高可用性</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_38-bin-log" data-v-2d325df8>38 bin log</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_39-四种隔离级别解决的问题" data-v-2d325df8>39 四种隔离级别解决的问题</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_40-innodb与myisam的适用场景" data-v-2d325df8>40 innodb与myisam的适用场景</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_41-acid" data-v-2d325df8>41 ACID</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_42-myisam-static和myisam-dynamic的区别" data-v-2d325df8>42 MyISAM Static和MyISAM Dynamic的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_43-federated表是什么" data-v-2d325df8>43 federated表是什么</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_44-如果一个表有一列定义为timestamp，将发生什么" data-v-2d325df8>44 如果一个表有一列定义为TIMESTAMP，将发生什么</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_45-列设置为auto-increment时，如果在表中达到最大值，会发生什么情况" data-v-2d325df8>45 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_46-最后一次插入时分配了哪个自动增量" data-v-2d325df8>46 最后一次插入时分配了哪个自动增量</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_47-表格定义的所有索引" data-v-2d325df8>47 表格定义的所有索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_48-如何在unix和mysql时间戳之间进行转换" data-v-2d325df8>48 如何在Unix和MySQL时间戳之间进行转换</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_49-可以使用多少列创建索引" data-v-2d325df8>49 可以使用多少列创建索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_50-now（）和current-date（）区别" data-v-2d325df8>50 Now（）和CURRENT_DATE（）区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_51-mysql数据表什么情况下容易损坏" data-v-2d325df8>51 MySQL数据表什么情况下容易损坏</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_52-mysql有关权限的表" data-v-2d325df8>52 MySQL有关权限的表</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_53-session加载实体对象的过程" data-v-2d325df8>53 session加载实体对象的过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_54-sql的执行顺序" data-v-2d325df8>54 sql的执行顺序</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_55-慢查询优化" data-v-2d325df8>55 慢查询优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_56-覆盖索引、回表" data-v-2d325df8>56 覆盖索引、回表</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_57-幻读、脏读、不可重复读" data-v-2d325df8>57 幻读、脏读、不可重复读</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_58-select-for-update" data-v-2d325df8>58 select for update</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_59-索引策略" data-v-2d325df8>59 索引策略</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_60-三范式" data-v-2d325df8>60 三范式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_61-mysql权限表" data-v-2d325df8>61 mysql权限表</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_62-innodb引擎的4大特性" data-v-2d325df8>62 innoDB引擎的4大特性</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_63-什么是索引下推" data-v-2d325df8>63 什么是索引下推</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_64-不可重复读与幻读的区别" data-v-2d325df8>64 不可重复读与幻读的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_65-当前读与快照读" data-v-2d325df8>65 当前读与快照读</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_66-ddl与dml" data-v-2d325df8>66 DDL与DML</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_67-jdbc" data-v-2d325df8>67 JDBC</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_68-mysql是如何与应用系统进行交互的" data-v-2d325df8>68 mysql是如何与应用系统进行交互的</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_69-悲观锁" data-v-2d325df8>69 悲观锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_70-乐观锁" data-v-2d325df8>70 乐观锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_71-cas与synchronized的使用场景" data-v-2d325df8>71 CAS与Synchronized的使用场景</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_72-一张表里面有id自增主键，当insert了17条记录之后，删除了第15、16、17条记录，再把insert一条记录，这条记录的id是18还是15？" data-v-2d325df8>72 一张表里面有ID自增主键，当insert了17条记录之后，删除了第15、16、17条记录，再把insert一条记录，这条记录的ID是18还是15？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_73-heap表" data-v-2d325df8>73 Heap表</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_74-如何区分float和double" data-v-2d325df8>74 如何区分FLOAT和DOUBLE</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_75-区分char-length和length" data-v-2d325df8>75 区分CHAR_LENGTH和LENGTH</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_76-mysql中innodb支持四种事务隔离级别" data-v-2d325df8>76 MySQL中InnoDB支持四种事务隔离级别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_77-enum" data-v-2d325df8>77 ENUM</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_78-定义regexp" data-v-2d325df8>78 定义REGEXP</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_79-char和varchar区别" data-v-2d325df8>79 CHAR和VARCHAR区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_80-列的字符串类型" data-v-2d325df8>80 列的字符串类型</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_81-timestamp在update-current-timestamp数据类型上做什么" data-v-2d325df8>81 TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_82-主键和候选键" data-v-2d325df8>82 主键和候选键</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_83-如何控制heap表的最大尺寸" data-v-2d325df8>83 如何控制HEAP表的最大尺寸</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_84-mysql-支持事务吗" data-v-2d325df8>84 mysql 支持事务吗</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_85-mysql-锁" data-v-2d325df8>85 mysql 锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_86-mysql-锁优化" data-v-2d325df8>86 mysql 锁优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_87-mysql-表格" data-v-2d325df8>87 mysql 表格</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_88-myisam-和-innodb-的区别" data-v-2d325df8>88 myisam 和 innodb 的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_89-innodb-四大事务隔离级别" data-v-2d325df8>89 innodb 四大事务隔离级别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_90-char-和-varchar-的区别" data-v-2d325df8>90 char 和 varchar 的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_91-主键、超键、候选键、外键的区别" data-v-2d325df8>91 主键、超键、候选键、外键的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_92-主键、索引、唯一索引、联合索引的区别" data-v-2d325df8>92 主键、索引、唯一索引、联合索引的区别</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_93-外连接、内连接、自连接" data-v-2d325df8>93 外连接、内连接、自连接</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_94-数据增量优化" data-v-2d325df8>94 数据增量优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_95-数据库事务" data-v-2d325df8>95 数据库事务</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_96-完整性约束" data-v-2d325df8>96 完整性约束</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_97-视图-游标" data-v-2d325df8>97 视图 游标</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_98-存储过程" data-v-2d325df8>98 存储过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_99-范式" data-v-2d325df8>99 范式</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_100-sql-优化" data-v-2d325df8>100 SQL 优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_101-sql-分哪几部分" data-v-2d325df8>101 SQL 分哪几部分</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_102-锁" data-v-2d325df8>102 锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_103-锁优化" data-v-2d325df8>103 锁优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_104-索引" data-v-2d325df8>104 索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_105-事务" data-v-2d325df8>105 事务</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_106-交叉连接、内连接、外连接" data-v-2d325df8>106 交叉连接、内连接、外连接</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_107-数据完整性" data-v-2d325df8>107 数据完整性</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_108-索引" data-v-2d325df8>108 索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_109-sql" data-v-2d325df8>109 SQL</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_110-sql-执行" data-v-2d325df8>110 SQL 执行</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_111-mysql-锁" data-v-2d325df8>111 MySQL 锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_112-锁升级" data-v-2d325df8>112 锁升级</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_113-悲观锁-vs-乐观锁" data-v-2d325df8>113 悲观锁 vs 乐观锁</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_114-尽量避免死锁的出现" data-v-2d325df8>114 尽量避免死锁的出现</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_115-union-union-all" data-v-2d325df8>115 union &amp; union all</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_116-性能优化" data-v-2d325df8>116 性能优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_117-优化语句" data-v-2d325df8>117 优化语句</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_118-优化分库" data-v-2d325df8>118 优化分库</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_119-优化索引" data-v-2d325df8>119 优化索引</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_120-优化数据库" data-v-2d325df8>120 优化数据库</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_view_java_java-09-mysql" data-v-3886f8ec><div><h1 id="mysql" tabindex="-1">MySQL <a class="header-anchor" href="#mysql" aria-hidden="true">#</a></h1><h2 id="_01-连接查询" tabindex="-1">01 连接查询 <a class="header-anchor" href="#_01-连接查询" aria-hidden="true">#</a></h2><ul><li><p>左外连接。以左边 为基准进行查询，左表数据会全部显示出来，右表如果和左表匹配的数据则显示相应字段的数据，如果不匹配，则显示为null</p></li><li><p>右连接。以右表为基准进行查询，右表数据会全部显示出来，右表如果和左表匹配的数据则显示相应字段的数据，如果不匹配，则显示为null</p></li></ul><h2 id="_02-聚合函数" tabindex="-1">02 聚合函数 <a class="header-anchor" href="#_02-聚合函数" aria-hidden="true">#</a></h2><ul><li>count统计行数量</li><li>sum获取单个列的合计值</li><li>avg获取某个列的平均值</li><li>max获取列的最大值</li><li>min获取列的最小值</li></ul><h2 id="_03-sql-关键字" tabindex="-1">03 SQL 关键字 <a class="header-anchor" href="#_03-sql-关键字" aria-hidden="true">#</a></h2><ul><li>limit2,6从第三条开始，显示六条</li><li>group by ：select sex,count(*) from student group by sex</li><li>distinct ：select distinct name from student</li></ul><h2 id="_04-sql-select-语句完整的执行顺序" tabindex="-1">04 SQL Select 语句完整的执行顺序 <a class="header-anchor" href="#_04-sql-select-语句完整的执行顺序" aria-hidden="true">#</a></h2><ul><li>from</li><li>on</li><li>left</li><li>join</li><li>where</li><li>group by</li><li>avg/sum</li><li>having</li><li>select</li><li>order by</li><li>asc/desc</li><li>limit</li></ul><h2 id="_05-数据库三范式" tabindex="-1">05 数据库三范式 <a class="header-anchor" href="#_05-数据库三范式" aria-hidden="true">#</a></h2><ul><li>第一范式。原子性，列或字段不能再分</li><li>第二范式。唯一性，一张表只说一件事，是对记录的唯一性约束</li><li>第三范式。直接性，数据不能存在传递关系，即每个属性都跟主键有直接关系，而不是间接关系</li></ul><h2 id="_06-存储引擎" tabindex="-1">06 存储引擎 <a class="header-anchor" href="#_06-存储引擎" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">MyISAM存储引擎。</p><p>MySQL5.5版本之前的默认存储引擎</p><ul><li>支持表级锁（表级锁是MySQL中锁粒度最大的一种锁，表示对当前操作的整张表加锁）</li><li>不支持事务，外键</li><li>适用场景（对事务完整性没有要求）或select、insert为主的应用基本都可以选MyISAM，在web、数据仓库中应用广泛</li><li>每个myisam在磁盘上存储为3个文件，文件名和表名相同，扩展名分别是.frm存储表定义//.MYD存储数据//.MYI存储索引</li></ul></div><div class="tip custom-block"><p class="custom-block-title">InnoDB存储引擎</p><ul><li>支持行级锁。行级锁是MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁</li><li>支持事务</li><li>支持聚集索引方式存储数据</li></ul></div><h2 id="_07-数据库事务" tabindex="-1">07 数据库事务 <a class="header-anchor" href="#_07-数据库事务" aria-hidden="true">#</a></h2><p><strong>事务特性</strong></p><ul><li><strong>原子性</strong>：即不可分割性，事务要么全部被执行，要么就全部不执行</li><li><strong>一致性</strong>：事务的执行使得数据库从一种正确状态转换成另一种正确状态</li><li><strong>隔离性</strong>：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务</li><li><strong>持久性</strong>：事务正确提交后，其结果将永久保存在数据库，即使事务提交后有了其他故障，事务的处理结果也会的得到保存</li></ul><div class="danger custom-block"><p class="custom-block-title">隔离级别</p><ul><li>读未提交。在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项目中基本不怎么用，安全性太差</li><li>读已提交。这是大多数据库默认的隔离级别，但不是MYSQL的默认隔离级别，这个隔离级别满足了简单的隔离要求，一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题，由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等问题</li><li>可重复读。这是MySQL的默认级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数据，不过理论上，这会导致另一个棘手的问题，幻读（简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”行） InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题</li><li>可串行化（serializable）事务的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题，简而言之，它是在每个读的数据行上加上共享锁，在这个级别，可能导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个：</li></ul></div><h2 id="_08-索引" tabindex="-1">08 索引 <a class="header-anchor" href="#_08-索引" aria-hidden="true">#</a></h2><p>索引的概念和优点。索引存储在内存中，为了服务存储引擎为了快速找到记录的一种数据结构，索引的主要作用是加快数据查找速度，提高数据库的性能</p><div class="tip custom-block"><p class="custom-block-title">优点</p><ul><li>1）创建唯一性索引，保证数据库表中每一个行数据的唯一性</li><li>2）大大加快数据的检索速度，这也是创建索引的最主要的原因</li><li>3）加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li><li>4）在使用分组和排序子句进行数据检索，同样可以显著减小查询中分组和排序的时间</li></ul></div><div class="warning custom-block"><p class="custom-block-title">索引的分类</p><ul><li>普通索引：最基本的索引，它没有任何限制</li><li>唯一索引：与普通索引类似，不同的就是索引列的值必须唯一，但允许有空值，如果是组合索引，则列值的组合必须唯一</li><li>主键索引：它是一种特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用primary key来约束</li><li>联合索引：多个字段上建立的索引，能够加锁复合查询条件的检索</li><li>全文索引：MySQL自带的全文索引只能用于数据库引擎为了MyISAM的数据表，新版本MySQL5.6的InnoDB支持全文索引，默认MySQL不支持中文检索，可以通过扩展MySQL，添加中文检索或为中文内容表提供一个对应的英文索引表的方式来支持中文</li></ul></div><h2 id="_09-索引的底层实现原理" tabindex="-1">09 索引的底层实现原理 <a class="header-anchor" href="#_09-索引的底层实现原理" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">索引结构</p><p>索引是在MySQL的存储引擎（InnoDB MyISAM）层中实现的，而不是在服务层实现的，所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持的索引类型的，MySQL目前提供了4中索引</p><ul><li>B+Tree索引，最常见的索引类型，大部分索引都支持B+树索引</li><li>Hash索引：只有Memory引擎支持，使用场景简单</li><li>R-Tree索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要地理空间数据，使用也很少</li><li>S-Full-text（全文索引）全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从MySQL5.6版本开始支持全文索引</li></ul></div><div class="tip custom-block"><p class="custom-block-title">BTree/B+Tree结构</p><ol><li>B+Tree是在BTree基础上进行演变的，先看看BTree叫多路平衡搜索树，一课m叉Btree特性</li></ol><ul><li>树中每个节点最多包含m个孩子</li><li>除跟节点与叶子节点外，每一个节点至少有[ceil(m/2)]个孩子ceil函数指向上取整</li><li>若根节点不是叶子节点，则至少有两个孩子</li><li>每个非叶子节点由n个key和n+1个指针组成</li></ul><ol start="2"><li>B+Tree结构B+Tree为BTree的变种，B+Tree与BTree的区别</li></ol><ul><li>B+Tree的叶子节点保存所有的key信息，依Key大小顺序排列</li><li>B+Tree叶子节点元素维护了一个单项链表</li><li>B+Tree查询效率更稳定</li><li>MySQL索引数据结构对经典的B+Tree进行优化，在原B+Tree的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能</li></ul></div><h2 id="_10-如何避免索引失效" tabindex="-1">10 如何避免索引失效 <a class="header-anchor" href="#_10-如何避免索引失效" aria-hidden="true">#</a></h2><ul><li>范围查询，右边的列不能使用索引，否则右边的索引也会失效</li><li>不要在索引上使用运算，否则索引也会失效</li><li>字符串不加引号，造成索引失效。如果索引列是字符串类型的整数，条件查询的时候不加引号会造成索引失效，MySQL内置的优化会有隐式转换</li><li>尽量使用覆盖索引，避免select*，这样能提高查询效率</li><li>or关键字连接。用or分割开的条件，如果or前面的列有索引，or后面的列没有索引，那么查询的时候前后索引都会失效 如果一定要用or查询，可以考虑下or连接的条件列都加索引，这样就不会失效</li></ul><h2 id="_11-数据库锁" tabindex="-1">11 数据库锁 <a class="header-anchor" href="#_11-数据库锁" aria-hidden="true">#</a></h2><p><strong>行锁和表锁</strong></p><ul><li>主要是针对锁粒度划分的，一般分为行锁、表锁、库锁 <ul><li>行锁：访问数据库的时候，锁定整个行数据，防止并发错误</li><li>表锁：访问数据库的时候，锁定整个表数据，防止并发错误</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">行锁和表锁的区别</p><ul><li>表锁：开销小，加锁快，不会出现死锁，锁定力度大，发生锁冲突概率高，并发度最低</li><li>行锁：开销大，加锁慢，会出现死锁，锁定粒度小，发生锁冲突的概率低，并发度最高</li></ul></div><h2 id="_12-悲观锁和乐观锁" tabindex="-1">12 悲观锁和乐观锁 <a class="header-anchor" href="#_12-悲观锁和乐观锁" aria-hidden="true">#</a></h2><ul><li>悲观锁：每次去拿数据的时候都认为别人会修改，在每次操作的时候都会上锁，这样别人想拿个这个数据就会block直到它拿到锁</li></ul><div class="warning custom-block"><p class="custom-block-title">乐观锁</p><ol><li>乐观锁：每次拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制</li><li>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁</li></ol></div><h2 id="_13-mysql优化" tabindex="-1">13 MySQL优化 <a class="header-anchor" href="#_13-mysql优化" aria-hidden="true">#</a></h2><ul><li>索引优化---表优化---sql慢查询优化</li></ul><h2 id="_14-定位执行效率慢的sql语句" tabindex="-1">14 定位执行效率慢的sql语句 <a class="header-anchor" href="#_14-定位执行效率慢的sql语句" aria-hidden="true">#</a></h2><ul><li>命令：show status like &#39;com_&#39;通过这条命令，可以知道当前数据库是以查询为主还是更新为主，如果查询为主，就是重点查询，如果增删改多就重点优化写入操作</li><li>explain+sql语句查询sql执行过程，通过执行计划，我们能得到哪些信息 <ul><li>(1)哪个步骤花费的成本比较高</li><li>(2)哪些步骤产生的数据量多，数据量的多少用线条的粗细表示，很直观</li><li>(3)这条sql语句是否走索引</li></ul></li><li>show profile分析sql，可以查看所有sql语句的执行效率（所以时间）前提是这个命令需要被打开，严格的说也就是打开这个命令执行的所有sql命令，它都能记录执行时间，并展示出来，可以通过这命令分析哪些sql语句执行效率低，耗时长，就更有针对性的优化这条sql</li><li>慢查询日志。慢查询日志记录了所有执行时间超过参数long_query_time的sql语句的日志，long_query_time默认为10秒（可以通过配置文件设置），日志保存在/var/lib/mysql目录下有个slow_query.log文件</li></ul><h2 id="_15-优化索引" tabindex="-1">15 优化索引 <a class="header-anchor" href="#_15-优化索引" aria-hidden="true">#</a></h2><p><strong>索引设计原则</strong></p><ul><li>对查询频次较高，且数据量比较大的表，建立索引</li><li>索引字段的选择，最佳或候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用的，过滤效果最好的列的组合</li><li>使用唯一索引，区分度越高，使用索引的效率越高</li><li>索引并非越多越好，如果该表增删改操作较多，慎重选择建立索引，过多索引会降低表维护效率</li><li>使用短索引，提高索引访问时的I/O效率，因此也相应提升了MySQL查询效率</li><li>如果where后有多个条件经常被用到，建议建立符合索引，复合索引需要遵循最左前缀法，N个列组合而成的复合索引，相当于创建N个索引</li><li>复合索引命名规则 index_表名_列名1_列名2_列名3</li></ul><div class="language-text"><span class="copy"></span><pre><code><span class="line"><span style="color:#c9d1d9;">create index idx_seller_name_sta_addr on tb_seller（name,status,address）</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">避免索引失效</p><ol><li>如果在查询的时候，使用了复合索引，要遵循最左前缀法则，也就是查询从索引的最左列开始，并且不能跳过索引中的列</li><li>尽量不要在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在where子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li><li>不做列运算where age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数，计算表达式，都会使索引失效</li><li>查询like，如果是&#39;%aaa&#39;也会造成索引失效</li><li>应尽量避免在where子句中使用o来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描Sql语句调优</li><li>根据业务场景建立复合索引只查询业务需要的字段，如果这些字段被索引覆盖，将极大的提高查询效率</li><li>多表连接的字段上需要建立索引，这样可以极大提高表连接的效率</li><li>where条件字段上需要建立索引，但where条件上不要使用运算函数，以免索引失效</li><li>排序字段上，因为排序效率低，添加索引能提高查询效率</li><li>优化insert语句：批量列插入数据要比单个列插入数据效率高</li><li>优化order by语句，在使用order by语句时，不要使用select * ，select 后面要查有索引的列，如果一条SQL语句中对多个列进行排序，在业务允许情况下，尽量同时用升序或同时用降序</li><li>优化group by语句，在我们对某一字段进行分组的时候，MySQL默认就进行了排序，但是排序并不是我们业务所需的，额外的排序会降低效率，所以在用的时候可以禁止排序，使用order by null禁用，select age,count（*）from emp group by age order by null</li><li>尽量避免子查询，将子查询优化为join多表连接查询</li></ol></div><h2 id="_16-合理的数据库设计" tabindex="-1">16 合理的数据库设计 <a class="header-anchor" href="#_16-合理的数据库设计" aria-hidden="true">#</a></h2><p><strong>三范式</strong></p><ul><li>第一范式，数据表中每个字段都必须是不可拆分的最小单元</li><li>第二范式，表中每一列必须有唯一性，都必须依赖于主键</li><li>第三范式，表中的每一列只与主键直接相关而不是间接相关（外键也是直接相关），字段没有冗余</li></ul><p><strong>反三范式</strong></p><ol><li><p>保留冗余字段，当两个或多个表在查询中经常需要连接时，可以在其中一个表上增加若干冗余字段，以避免表之间的连接过于频繁，一般在冗余列的数据不经常变动的情况下使用</p></li><li><p>增加派生列，派生列是由表中的其它多个列的计算所得，增加派生列可以减少统计运算，在数据汇总时可以大大缩短运算时间，前提是这个列经常被用到，这就是反三范式</p></li><li><p>分割表</p><ul><li>数据表拆分：主要就是垂直拆分和水平拆分</li><li>水平切分：将记录散列到不同的表中各表的结构完全相同，每次从分表中查询，提高效率</li><li>垂直切分：将表中大字段单独拆分到另外一张表，形成一对一的关系</li></ul></li><li><p>字段设计</p><ul><li>表的字段尽可能用NOT NULL</li><li>字段长度固定的表查询会更快</li><li>把数据库的大表按时间或一些标志分成小表</li></ul></li></ol><h2 id="_17-笛卡尔积" tabindex="-1">17 笛卡尔积 <a class="header-anchor" href="#_17-笛卡尔积" aria-hidden="true">#</a></h2><p>左连接 右连接 内连接</p><h2 id="_18-查数据库怎么防止sql注入" tabindex="-1">18 查数据库怎么防止sql注入 <a class="header-anchor" href="#_18-查数据库怎么防止sql注入" aria-hidden="true">#</a></h2><div class="language-text"><span class="copy"></span><pre><code><span class="line"><span style="color:#c9d1d9;">Mybatis中使用#{ }代替数据部分防止SQL注入</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span></code></pre></div><h2 id="_19-mysql走索引怎么查到数据" tabindex="-1">19 MySQL走索引怎么查到数据 <a class="header-anchor" href="#_19-mysql走索引怎么查到数据" aria-hidden="true">#</a></h2><p>innodb引擎以页的形式将数据储存到磁盘，查询时将页读入内存，在叶子节点中查取数据， 叶节点内部通过二分法查找，找不到转到该页指向的下一个页继续查询。</p><h2 id="_20-b-树的特性" tabindex="-1">20 B+树的特性 <a class="header-anchor" href="#_20-b-树的特性" aria-hidden="true">#</a></h2><ol><li>所有的非叶子节点只保存索引，不保存数据。因此树结构更加矮胖，减少磁盘I/O次数。</li><li>对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历。</li></ol><h2 id="_21-mysql-常用的引擎" tabindex="-1">21 MySQL 常用的引擎 <a class="header-anchor" href="#_21-mysql-常用的引擎" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">InnoDB 引擎</p><p>mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束， 它的设计的目标就是处理大数据容量的数据库系统。 MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索， 同时启动也比较的慢，它是不会保存表的行数的， 所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。 由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p></div><div class="tip custom-block"><p class="custom-block-title">MyIASM 引擎：</p><p>不提供事务的支持，也不支持行级锁和外键。 因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。 不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数， 于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。 所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p></div><h2 id="_22-事务的-acid-特性在mysql中的实现" tabindex="-1">22 事务的 ACID 特性在MySQL中的实现 <a class="header-anchor" href="#_22-事务的-acid-特性在mysql中的实现" aria-hidden="true">#</a></h2><ul><li><p>原子性：利用undo log 实现的</p></li><li><p>持久性：利用redo log 实现的</p></li><li><p>一致性:是利用 原子性 持久性 隔离性来实现的。事务的四大特性中一致性是目的，其他都是保证一致性的手段。</p></li><li><p>redo log :记录了数据操作在物理层面的修改，事务进行中会不断的产生redo log 在事务进行提交时一次flush操作保存到磁盘中。</p></li><li><p>undo log: 记录事务的修改操作，可以实现事务的回滚。</p></li></ul><p><strong>事务的隔离性由MVCC（多版本并发控制）与锁实现：因而隔离性也可以叫做并发控制。</strong></p><blockquote><p>InnoDB储存引擎标准实现的锁只有两种：行级锁 意向锁。</p></blockquote><blockquote><p>InnoDB实现了如下两种标准的行级锁： 共享锁（读锁 S Lock），允许事务读一行数据 排它锁（写锁 X Lock），允许事务删除一行数据或者更新一行数据</p></blockquote><p><strong>InnoDB支持两种意向锁（即为表级别的锁）：</strong></p><ol><li><p>意向共享锁（读锁 IS Lock），事务想要获取一张表的几行数据的共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p></li><li><p>意向排他锁（写锁 IX Lock），事务想要获取一张表中几行数据的排它锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p></li></ol><div class="danger custom-block"><p class="custom-block-title">意向锁</p><p>加意向锁表明某个事务正在锁定一行或者将要锁定一行。首先申请意向锁的动作是InnoDB完成的，怎么理解意向锁呢 例如：事务A要对一行记录r进行上X锁，那么InnoDB会先申请表的IX锁，再锁定记录r的X锁。 在事务A完成之前，事务B想要来个全表操作，此时直接在表级别的IX就告诉事务B需要等待 而不需要在表上判断每一行是否有锁。意向排它锁存在的价值在于节约InnoDB对于锁的定位和处理性能。</p></div><div class="tip custom-block"><p class="custom-block-title">InnoDB有3种行锁的算法</p><ul><li>Record Lock：单个行记录上的锁</li><li>Gap Lock：间隙锁，锁定一个范围，而非记录本身</li><li>Next-Key Lock：结合Gap Lock和Record Lock，锁定一个范围，并且锁定记录本身。主要解决的问题是RR隔离级别下的幻读问题。</li></ul></div><h2 id="_23-聚簇索引与非聚簇索引" tabindex="-1">23 聚簇索引与非聚簇索引 <a class="header-anchor" href="#_23-聚簇索引与非聚簇索引" aria-hidden="true">#</a></h2><p>页的概念：一块小的且连续的内存空间</p><div class="tip custom-block"><p class="custom-block-title">聚簇索引：</p><ol><li><p>InnoDB储存引擎中，聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。</p></li><li><p>一般建表会用一个自增主键做聚簇索引，没有的话MySQL会默认创建，但是这个主键如果更改代价较高（页撕裂），故建表时要考虑自增ID不能频繁update这点。</p></li><li><p>我们日常工作中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了寻找主键索引的二级索引，先找到主键索引再通过主键索引找数据。非聚簇索引的叶子节点存储的是数据行的主键信息。</p></li></ol></div><ul><li><strong>聚簇索引的优点：</strong><ul><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul></li></ul><div class="danger custom-block"><p class="custom-block-title"><strong>聚簇索引的缺点：</strong></p><ul><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键</li><li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。这种二次查询的方式叫做回表查询。</li></ul></div><h2 id="_24-非聚簇索引的叶子节点储存什么数据" tabindex="-1">24 非聚簇索引的叶子节点储存什么数据 <a class="header-anchor" href="#_24-非聚簇索引的叶子节点储存什么数据" aria-hidden="true">#</a></h2><p>非聚簇索引又叫二级索引，该索引的叶子节点保存的是数据行的主键值， 想要得到结果还需要使用主键值去聚簇索引中进行二次检索。</p><h2 id="_25-多字段查询如何设置索引" tabindex="-1">25 多字段查询如何设置索引 <a class="header-anchor" href="#_25-多字段查询如何设置索引" aria-hidden="true">#</a></h2><p>最长搜索的字段放最右侧。范围搜索后面的字段的索引会失效。尽量使用覆盖索引。</p><h2 id="_26-mvcc是什么原理" tabindex="-1">26 MVCC是什么原理 <a class="header-anchor" href="#_26-mvcc是什么原理" aria-hidden="true">#</a></h2><ol><li><p>全称多版本并发控制，与之相对的是基于锁的并发控制。</p></li><li><p>MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的， 极大的增加了系统的并发性能</p></li><li><p>MVCC 利用了多版本快照的思想，写操作更新最新的版本快照， 而读操作去读旧版本快照(read view)根据隔离级别不同读取的规则也不同，没有互斥关系。</p></li></ol><h2 id="_27-联合索引的数据结构" tabindex="-1">27 联合索引的数据结构 <a class="header-anchor" href="#_27-联合索引的数据结构" aria-hidden="true">#</a></h2><p>联合索引的数据结构依然是B+树。其非叶子节点储存的是第一个关键字的索引。叶子节点存储的是三个关键字的顺序。且按照字段从左到右排序。</p><blockquote><p>如，index(年龄, 姓氏,名字)，叶节点上data域存储的是三个关键字的数据。 且是按照年龄 姓氏 名字的顺序排列的。 如果跳过年纪按照后面两个字段搜索，会导致全表扫描。</p></blockquote><h2 id="_28-explain-查询到的字段" tabindex="-1">28 explain 查询到的字段 <a class="header-anchor" href="#_28-explain-查询到的字段" aria-hidden="true">#</a></h2><div class="danger custom-block"><p class="custom-block-title">explain</p><ol><li>select_type : 查询类型，有简单查询 联合查询 子查询等</li><li>key : 实际使用到的索引，如果为null，表示没有使用到索引。</li><li>possible_key：</li><li>type：显示查询使用了何种索引类型，all &lt; index &lt; range &lt; ref</li><li>table：显示这一行的数据是关于哪张表的</li><li>rows : 根据表统计信息及索引选用情况，大致估算出找到所需数据所需要读取的行数。</li><li>id：select查询的序列号,包含一组数字，表示查询中执行select子句的顺序。</li><li>extra：其他信息，显示如 using index using filesort 等等。</li></ol></div><h2 id="_29-mysql的自增id用完了怎么办" tabindex="-1">29 MySQL的自增ID用完了怎么办 <a class="header-anchor" href="#_29-mysql的自增id用完了怎么办" aria-hidden="true">#</a></h2><p>数据库表的自增 ID 达到上限之后，再申请时它的值就不会在改变了， 继续插入数据时会导致报主键冲突错误。 因此在设计数据表时，尽量根据业务需求来选择合适的字段类型。可 以考虑使用bigint 类型。</p><h2 id="_30-数据库中保存商品价格使用什么数据类型" tabindex="-1">30 数据库中保存商品价格使用什么数据类型 <a class="header-anchor" href="#_30-数据库中保存商品价格使用什么数据类型" aria-hidden="true">#</a></h2><ol><li>在java的开发中，货币在数据库中MySQL常用Decimal和Numric类型表示，这两种类型被MySQL实现为同样的类型。</li><li>DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</li><li>不使用float或者double的原因：因为float和double是以二进制存储的，所以有一定的误差。</li></ol><h2 id="_31-死锁" tabindex="-1">31 死锁 <a class="header-anchor" href="#_31-死锁" aria-hidden="true">#</a></h2><ol><li>通过获取死锁日志来获取死锁信息。mysql使用几个特殊的表名来作为监控的开关。</li></ol><blockquote><p>比如在数据库中创建一个表名为innodb_monitor的表用于开启标准监控。</p></blockquote><ol start="2"><li><p>创建一个表名为 innodb_lock_monitor 的表开启锁监控。</p></li><li><p>MySQL 通过检测是否存在这个表名来决定是否开启监控，至于表的结构和表里的内容无所谓。</p></li></ol><blockquote><p>相反的，如果要关闭监控，则将这两个表删除即可。</p></blockquote><h2 id="_32-幻读" tabindex="-1">32 幻读 <a class="header-anchor" href="#_32-幻读" aria-hidden="true">#</a></h2><div class="language-text"><span class="copy"></span><pre><code><span class="line"><span style="color:#c9d1d9;">-- 事务1</span></span>
<span class="line"><span style="color:#c9d1d9;">select age from table where id &gt; 2</span></span>
<span class="line"><span style="color:#c9d1d9;">-- 事务2</span></span>
<span class="line"><span style="color:#c9d1d9;">Insert into table(id , age) values (5, 10)</span></span>
<span class="line"><span style="color:#c9d1d9;">commit</span></span>
<span class="line"><span style="color:#c9d1d9;">-- 事务1</span></span>
<span class="line"><span style="color:#c9d1d9;">select age from table where id &gt; 2</span></span>
<span class="line"><span style="color:#c9d1d9;">commit</span></span>
<span class="line"><span style="color:#c9d1d9;">事务1两个相同的select语句执行了两次，两次的查询结果不相同，这就是产生了幻读。</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span></code></pre></div><h2 id="_33-redo-log-undo-log" tabindex="-1">33 redo log / undo log <a class="header-anchor" href="#_33-redo-log-undo-log" aria-hidden="true">#</a></h2><ul><li><p>redo log 常用作MySQL服务器异常宕机后的数据恢复工作，复杂保证事务的持久性</p></li><li><p>undo log 常用于记录被改动的数据，负责事务的一致性。</p></li></ul><h2 id="_34-mysql中除了undo-log-以外还有什么操作是为了保证事务的一致性" tabindex="-1">34 MySQL中除了undo log 以外还有什么操作是为了保证事务的一致性 <a class="header-anchor" href="#_34-mysql中除了undo-log-以外还有什么操作是为了保证事务的一致性" aria-hidden="true">#</a></h2><p>各种隔离级别保证事务的一致性。</p><h2 id="_35-数据库是怎么去做持久性的，做持久性的时候可能会遇到什么问题" tabindex="-1">35 数据库是怎么去做持久性的，做持久性的时候可能会遇到什么问题 <a class="header-anchor" href="#_35-数据库是怎么去做持久性的，做持久性的时候可能会遇到什么问题" aria-hidden="true">#</a></h2><ul><li>利用 redo log 做持久性，redo log主要记录了data在物理层面的修改。</li><li>redo log 在事务进行提交时一次flush操作保存到磁盘中。</li></ul><h2 id="_36-如何保证mysql的主从强一致性" tabindex="-1">36 如何保证MySQL的主从强一致性 <a class="header-anchor" href="#_36-如何保证mysql的主从强一致性" aria-hidden="true">#</a></h2><ol><li>在主库事务提交的时候，同时发起两个操作，操作一是将日志写到本地磁盘，操作二是将日志同步到从库并确保落盘。</li><li>主库此时等待两个操作全部成功返回之后，才返回给应用程序，事务提交成功。</li></ol><div class="tip custom-block"><p class="custom-block-title">mysql 主从一致要求强一致会导致什么问题</p><p>事务的每次提交都需要等到从机的落盘完成后才可以提交。</p></div><h2 id="_37-如何保证mysql主从的高可用性" tabindex="-1">37 如何保证MySQL主从的高可用性 <a class="header-anchor" href="#_37-如何保证mysql主从的高可用性" aria-hidden="true">#</a></h2><ol><li>HA（High Availability）检测工具应运而生。</li><li>HA工具一般部署在第三台服务器上，同时连接主从，检测主从是否存活， 如果主库宕机则及时将仓库升级为主库，将原来的主库降级为从库。</li></ol><h2 id="_38-bin-log" tabindex="-1">38 bin log <a class="header-anchor" href="#_38-bin-log" aria-hidden="true">#</a></h2><p>bin log 是MySQL数据库的二进制日志，用于记录用户对数据库操作的SQL语句（(除了数据查询语句）信息。</p><div class="danger custom-block"><p class="custom-block-title">bin log 与 redo log 的区别</p><ol><li>bin log是MySQL级别的日志文件，无论使用哪种存储引擎都会生成。而redo log 是innodb引擎独有的日志，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。</li><li>两种日志记录的内容形式不同。MySQL的bin log是逻辑日志，其记录是对应的SQL语句。而innodb存储引擎层面的重做日志是物理日志。</li><li>两种日志与记录写入磁盘的时间点不同，二进制日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。</li><li>bin log可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</li></ol></div><h2 id="_39-四种隔离级别解决的问题" tabindex="-1">39 四种隔离级别解决的问题 <a class="header-anchor" href="#_39-四种隔离级别解决的问题" aria-hidden="true">#</a></h2><ol><li>读未提交:会导致 脏读 不可重复读 幻读。解决了更新丢失问题（两个事务对一条数据修改导致的更新覆盖问题）可以直接使用排它写锁实现。</li><li>读已提交:会导致不可重复读 幻读。解决了脏读问题（可以使用共享读锁+排他写锁实现）</li><li>可重复度:解决了不可重复读问题，会导致幻读</li><li>序列化:全部解决（提供严格的事务隔离，事务没有并发性可言）</li></ol><div class="tip custom-block"><p class="custom-block-title">读已提交隔离级别为什么会有不可重复读的问题出现</p><div class="language-text"><span class="copy"></span><pre><code><span class="line"><span style="color:#c9d1d9;">//开启事务并设置隔离级别为读已提交,表count两个字段 name, money</span></span>
<span class="line"><span style="color:#c9d1d9;">A事务 select * from count  结果name = Tom money = 1000</span></span>
<span class="line"><span style="color:#c9d1d9;">B事务 update money = 2000 from count where name = Tom B事务提交</span></span>
<span class="line"><span style="color:#c9d1d9;">A事务 select * from count  结果name = Tom money = 2000 显然A事务对一个数据行两次读操作结果不一致,这就导致了不可重复读问题</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span></code></pre></div></div><h2 id="_40-innodb与myisam的适用场景" tabindex="-1">40 innodb与myisam的适用场景 <a class="header-anchor" href="#_40-innodb与myisam的适用场景" aria-hidden="true">#</a></h2><ol><li>大量读不需要事务控制的情况下使用myisam，写操作多的情况下使用innodb存储引擎。</li><li>需要用到行锁的场景下要使用myisam。</li></ol><h2 id="_41-acid" tabindex="-1">41 ACID <a class="header-anchor" href="#_41-acid" aria-hidden="true">#</a></h2><ul><li><p>Atomicity：事务本身被视为不可分割的最小单元，事务的操作要么全部成功要么全部失败回滚</p></li><li><p>Consistency：数据库在事务的执行前后都保持一致，所有事务对同一数据的读取结果都相同</p></li><li><p>Isolation：一个事务的操作在提交之前，对其他事务是不可见的</p></li><li><p>Durability：一旦事务提交之后对于数据库的更改就是永久不可回退的</p></li></ul><h2 id="_42-myisam-static和myisam-dynamic的区别" tabindex="-1">42 MyISAM Static和MyISAM Dynamic的区别 <a class="header-anchor" href="#_42-myisam-static和myisam-dynamic的区别" aria-hidden="true">#</a></h2><ol><li>MyISAM Static上所有字段有固定宽度</li><li>MyISAM Dynamic表将具有像TEXT、BLOB等字段，以适应不同长度的数据类型</li><li>MyISAM Static在受损情况下更容易恢复</li></ol><h2 id="_43-federated表是什么" tabindex="-1">43 federated表是什么 <a class="header-anchor" href="#_43-federated表是什么" aria-hidden="true">#</a></h2><p>federated表，允许访问位于其他服务器数据库上的表。</p><h2 id="_44-如果一个表有一列定义为timestamp，将发生什么" tabindex="-1">44 如果一个表有一列定义为TIMESTAMP，将发生什么 <a class="header-anchor" href="#_44-如果一个表有一列定义为timestamp，将发生什么" aria-hidden="true">#</a></h2><p>每当行被更改时，时间戳字段将获取当前时间戳</p><h2 id="_45-列设置为auto-increment时，如果在表中达到最大值，会发生什么情况" tabindex="-1">45 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况 <a class="header-anchor" href="#_45-列设置为auto-increment时，如果在表中达到最大值，会发生什么情况" aria-hidden="true">#</a></h2><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p><h2 id="_46-最后一次插入时分配了哪个自动增量" tabindex="-1">46 最后一次插入时分配了哪个自动增量 <a class="header-anchor" href="#_46-最后一次插入时分配了哪个自动增量" aria-hidden="true">#</a></h2><p>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称</p><h2 id="_47-表格定义的所有索引" tabindex="-1">47 表格定义的所有索引 <a class="header-anchor" href="#_47-表格定义的所有索引" aria-hidden="true">#</a></h2><p>索引是通过以下方式为表格定义的 SHOW INDEX FROM</p><h2 id="_48-如何在unix和mysql时间戳之间进行转换" tabindex="-1">48 如何在Unix和MySQL时间戳之间进行转换 <a class="header-anchor" href="#_48-如何在unix和mysql时间戳之间进行转换" aria-hidden="true">#</a></h2><ul><li>UNIX_TIMESTAMP是从MySQL时间戳转换为Unix时间戳的命令</li><li>FROM_UNIXTIME是从Unix时间戳转换为MySQL时间戳的命令</li></ul><h2 id="_49-可以使用多少列创建索引" tabindex="-1">49 可以使用多少列创建索引 <a class="header-anchor" href="#_49-可以使用多少列创建索引" aria-hidden="true">#</a></h2><p>任何标准表最多可创建16个索引列</p><h2 id="_50-now（）和current-date（）区别" tabindex="-1">50 Now（）和CURRENT_DATE（）区别 <a class="header-anchor" href="#_50-now（）和current-date（）区别" aria-hidden="true">#</a></h2><ul><li>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒</li><li>CURRENT_DATE（）仅显示当前年份，月份和日期</li></ul><h2 id="_51-mysql数据表什么情况下容易损坏" tabindex="-1">51 MySQL数据表什么情况下容易损坏 <a class="header-anchor" href="#_51-mysql数据表什么情况下容易损坏" aria-hidden="true">#</a></h2><ul><li>服务器突然断电导致数据文件损坏</li><li>强制关机</li><li>没有先关闭mysql服务</li></ul><h2 id="_52-mysql有关权限的表" tabindex="-1">52 MySQL有关权限的表 <a class="header-anchor" href="#_52-mysql有关权限的表" aria-hidden="true">#</a></h2><ul><li>权限表存放在mysql数据库里，由mysql_install_db脚本初始化，</li><li>这些权限表分别user、db、table_priv、columns_priv和host</li></ul><h2 id="_53-session加载实体对象的过程" tabindex="-1">53 session加载实体对象的过程 <a class="header-anchor" href="#_53-session加载实体对象的过程" aria-hidden="true">#</a></h2><ol><li>session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回</li><li>如果一级缓存没有命中，接下来session会在当前的nonexists记录中查找（相当于查询黑名单），如果出现重复的无效查询可迅速做出判断，从而提升性能，如果nonexists中存在同样的查询条件，则返回null</li><li>如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回。</li><li>如果之前的查询都未命中，则发出sql语句，如果查询未发现对应记录则将此次查询添加到session的nonexists加以记录，并返回null</li><li>根据映射配置和sql语句得到resultSet，并创建对应的实体对象</li><li>将对象纳入session的管理</li><li>如果有对应的拦截器，则执行拦截器的onLoad方法</li><li>如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存</li><li>返回数据对象</li></ol><h2 id="_54-sql的执行顺序" tabindex="-1">54 sql的执行顺序 <a class="header-anchor" href="#_54-sql的执行顺序" aria-hidden="true">#</a></h2><ul><li>from 将数据从硬盘加载到数据缓冲区，方便对接下来的数据进行操作</li><li>where 从基表或视图中选择满足条件的元组（不能使用聚合函数）</li><li>join 如right left 右连接，从右边表中读取某个元组，并且找到该元组在左边表中对应的元组或元组集</li><li>on join on实现多表连接查询，推荐该种方式进行多表查询，不使用子查询</li><li>group by 分组，一般和聚合函数一起使用</li><li>having 在元组的基础上进行筛选，选出符合条件的元组</li><li>select 查询的得到所有元组罗列的哪些列</li><li>distinct 去重功能</li><li>union 将多个查询结果合并</li><li>order by 进行相应的排序</li><li>limit 1 显示输出一条数据记录</li></ul><h2 id="_55-慢查询优化" tabindex="-1">55 慢查询优化 <a class="header-anchor" href="#_55-慢查询优化" aria-hidden="true">#</a></h2><ol><li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写</li><li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句尽可能的命中索引</li><li>如果对语句的优化已经无法进行，可考虑表中的数据量是否太大，如果是的话，可进行横向或纵向的分表</li></ol><h2 id="_56-覆盖索引、回表" tabindex="-1">56 覆盖索引、回表 <a class="header-anchor" href="#_56-覆盖索引、回表" aria-hidden="true">#</a></h2><ol><li>覆盖索引查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖</li><li>回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，叫回表。</li></ol><h2 id="_57-幻读、脏读、不可重复读" tabindex="-1">57 幻读、脏读、不可重复读 <a class="header-anchor" href="#_57-幻读、脏读、不可重复读" aria-hidden="true">#</a></h2><ol><li>事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据，这就是脏读</li><li>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读</li><li>事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交了，然后事务了再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读</li></ol><h2 id="_58-select-for-update" tabindex="-1">58 select for update <a class="header-anchor" href="#_58-select-for-update" aria-hidden="true">#</a></h2><p>select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢， 而且它是悲观锁，至于加了是行锁还是表锁，这就要看是不是用了索引/主键，没有用索引/主键的话就是表锁，否则就是行锁</p><h2 id="_59-索引策略" tabindex="-1">59 索引策略 <a class="header-anchor" href="#_59-索引策略" aria-hidden="true">#</a></h2><ul><li>覆盖索引</li><li>最左前缀原则</li><li>索引下推。索引下推优化是mysql 5.6引入的，可在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</li></ul><h2 id="_60-三范式" tabindex="-1">60 三范式 <a class="header-anchor" href="#_60-三范式" aria-hidden="true">#</a></h2><ol><li>第一范式：数据表中的每一列（每个字段）都不可以再拆分</li><li>第二范式：在第一范式的基础上，分主键列完全依赖于主键，而不能是依赖于主键的一部分</li><li>第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键</li></ol><h2 id="_61-mysql权限表" tabindex="-1">61 mysql权限表 <a class="header-anchor" href="#_61-mysql权限表" aria-hidden="true">#</a></h2><ol><li>user权限表，记录允许连接到服务器的用户账号信息，里面的权限是全局级的</li><li>db权限表，记录各个账号在各个数据库上的操作权限</li><li>table_priv权限表：记录数据表级的操作权限</li><li>columns_priv权限表：记录数据列级的操作权限</li><li>host权限表：配合db权限表给定主机上数据库级操作权限更细致的控制，这个权限表不受GRANT和REVOKE语句的影响</li></ol><h2 id="_62-innodb引擎的4大特性" tabindex="-1">62 innoDB引擎的4大特性 <a class="header-anchor" href="#_62-innodb引擎的4大特性" aria-hidden="true">#</a></h2><ol><li>插入缓冲</li><li>二次写</li><li>自适应哈希索引</li><li>预读</li></ol><h2 id="_63-什么是索引下推" tabindex="-1">63 什么是索引下推 <a class="header-anchor" href="#_63-什么是索引下推" aria-hidden="true">#</a></h2><p>索引下推在非主键索引上的优化，可以有效减少回表的次数，大大提升了查询的效率。</p><h2 id="_64-不可重复读与幻读的区别" tabindex="-1">64 不可重复读与幻读的区别 <a class="header-anchor" href="#_64-不可重复读与幻读的区别" aria-hidden="true">#</a></h2><ol><li><p>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的「数据不一样」。（因为中间有其他事务提交了修改）</p></li><li><p>幻读的重点在于新增或者删除：在同一事务中，同样的条件，第一次和第二次读出来的「记录数不一样」。（因为中间有其他事务提交了插入/删除）</p></li></ol><h2 id="_65-当前读与快照读" tabindex="-1">65 当前读与快照读 <a class="header-anchor" href="#_65-当前读与快照读" aria-hidden="true">#</a></h2><p>在一个支持MVCC的系统中，读操作被分为当前读与快照读</p><p><strong>快照读：简单的select操作，不加锁。</strong></p><div class="language-shell"><span class="copy"></span><pre><code><span class="line"><span style="color:#FF7B72;">select</span><span style="color:#C9D1D9;"> * from table where </span><span style="color:#FF7B72;">?;</span></span>
<span class="line"></span></code></pre></div><p><strong>当前读：插入/更新/删除操作，需要加锁</strong></p><div class="language-shell"><span class="copy"></span><pre><code><span class="line"><span style="color:#FF7B72;">select</span><span style="color:#C9D1D9;"> * from table where </span><span style="color:#FF7B72;">?</span><span style="color:#C9D1D9;"> lock </span><span style="color:#FF7B72;">in</span><span style="color:#C9D1D9;"> share mode</span><span style="color:#FF7B72;">;</span></span>
<span class="line"><span style="color:#FF7B72;">select</span><span style="color:#C9D1D9;"> * from table where </span><span style="color:#FF7B72;">?</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">for</span><span style="color:#C9D1D9;"> update</span><span style="color:#FF7B72;">;</span></span>
<span class="line"><span style="color:#C9D1D9;">insert into table values (…)</span><span style="color:#FF7B72;">;</span></span>
<span class="line"><span style="color:#C9D1D9;">update table </span><span style="color:#79C0FF;">set</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">?</span><span style="color:#C9D1D9;"> where </span><span style="color:#FF7B72;">?;</span></span>
<span class="line"><span style="color:#C9D1D9;">delete from table where </span><span style="color:#FF7B72;">?;</span></span>
<span class="line"></span></code></pre></div><h2 id="_66-ddl与dml" tabindex="-1">66 DDL与DML <a class="header-anchor" href="#_66-ddl与dml" aria-hidden="true">#</a></h2><ul><li><p>DML（data manipulation language）数据操纵语言：就是我们最经常用到的 SELECT UPDATE INSERT DELETE。 主要用来对数据库的数据进行一些操作。</p></li><li><p>DDL（data definition language）数据库定义语言：其实就是我们在创建表的时候用到的一些sql，比如说：CREATE ALTER DROP等。DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上</p></li></ul><h2 id="_67-jdbc" tabindex="-1">67 JDBC <a class="header-anchor" href="#_67-jdbc" aria-hidden="true">#</a></h2><ol><li>通过驱动建立一个连接，这个连接代表着一个真实的数据库连接。</li><li>由conn建立一个Statement或PreparedStatement对象。</li><li>stmt.executeUpdate(sql)执行语句，返回即查询解决。</li></ol><h2 id="_68-mysql是如何与应用系统进行交互的" tabindex="-1">68 mysql是如何与应用系统进行交互的 <a class="header-anchor" href="#_68-mysql是如何与应用系统进行交互的" aria-hidden="true">#</a></h2><ol><li><p><strong>系统如何连接访问数据库？</strong> 使用MySQL驱动才能跟MySQL数据库建立连接，然后执行各种各样的SQL语句。</p></li><li><p><strong>系统如何建立多个数据库连接？</strong></p></li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>如果Tomcat中的多个线程并发处理多个请求的时候，都要去抢夺一个连接去访问数据库的话，那么效率肯定是很低下的。</li><li>如果Tomcat中的每个线程在每次访问数据库的时候，都基于MySQL驱动去创建一个数据库连接，然后执行SQL语句，然后执行完之后再销毁这个数据库连接，这也不行，因为每次建立一个数据库连接都很耗时。</li><li>一般我们必须要使用一个数据库连接池，也就是说在一个池子里维持多个数据库连接，让多个线程使用里面的不同的数据库连接去执行SQL语句，然后执行完SQL语句之后，不要销毁这个数据库连接，而是连接放回池子里，后续还可以继续使用。</li></ol></div><h2 id="_69-悲观锁" tabindex="-1">69 悲观锁 <a class="header-anchor" href="#_69-悲观锁" aria-hidden="true">#</a></h2><ol><li>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其它线程）。</li><li>传统关系型数据库里边用到了很多这种锁机制，比如：行锁，表锁，读锁，写锁等，都是在操作之前先上锁。</li><li>Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</li></ol><h2 id="_70-乐观锁" tabindex="-1">70 乐观锁 <a class="header-anchor" href="#_70-乐观锁" aria-hidden="true">#</a></h2><ol><li>总是假设最好的情况，每次去拿数据的时候都会认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现，乐观锁使用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似write_condition机制，其实都是提供的乐观锁。</li><li>java中java.util.concurrent.atomic包下面的原子变量就是使用了乐观锁的一种实现方式CAS实现的。</li></ol><div class="tip custom-block"><p class="custom-block-title">场景</p><ul><li>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。</li><li>但是如果多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的retry，这样反倒降低了性能，一般多写的场景下用悲观锁就比较合适。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">乐观锁导致 ABA 问题</p><ol start="8"><li>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其它线程修改过了吗？很明显是不能的，因为这段时间它的值可能被改为其它值，然后又改回A，那么CAS操作就会误认为它从来没被修改过。</li><li>JDK1.5以后的AtomicStampedReference类就提供了此种能力，其中的compareAndSet方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li></ol></div><div class="warning custom-block"><p class="custom-block-title">循环时间长开销大</p><p>自旋CAS，也就是不成功就一直循环执行直到成功，如果长时间不成功， 会给CPU带来非常大的执行开销，如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升，</p><ul><li><strong>pause指令有两个作用</strong>，</li><li>第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源， 延迟的时间取决于具体的实现版本，在一些处理器上延迟时间是零。</li><li>第二它可以避免在退出循环的时候因内存顺序冲突， 而引起CPU流水线被清空，从而提高CPU的执行效率。</li></ul></div><div class="danger custom-block"><p class="custom-block-title">只能保证一个共享变量的原子操作</p><p>CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效， 但是从JDK1.5，提供了AtomicReference类来保证引用对象之间的原子性， 你可以把多个变量放在一个对象里来进行CAS操作， 所以我们可使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p></div><h2 id="_71-cas与synchronized的使用场景" tabindex="-1">71 CAS与Synchronized的使用场景 <a class="header-anchor" href="#_71-cas与synchronized的使用场景" aria-hidden="true">#</a></h2><blockquote><p>CAS适用于写比较少的情况下：多读场景，冲突一般较少 Synchronized适用于写比较多的情况下：多写场景，冲突一般较多</p></blockquote><ol><li>对于资源竞争较少的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而cas基于硬件实现，，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li><li>JDK1.6之后，synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可获得和CAS类似的性能，而线程冲突严重的情况下，性能远高于CAS。</li></ol><h2 id="_72-一张表里面有id自增主键，当insert了17条记录之后，删除了第15、16、17条记录，再把insert一条记录，这条记录的id是18还是15？" tabindex="-1">72 一张表里面有ID自增主键，当insert了17条记录之后，删除了第15、16、17条记录，再把insert一条记录，这条记录的ID是18还是15？ <a class="header-anchor" href="#_72-一张表里面有id自增主键，当insert了17条记录之后，删除了第15、16、17条记录，再把insert一条记录，这条记录的id是18还是15？" aria-hidden="true">#</a></h2><ul><li>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。</li><li>如果表的类型是InnoDB，那么是15。InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。</li></ul><h2 id="_73-heap表" tabindex="-1">73 Heap表 <a class="header-anchor" href="#_73-heap表" aria-hidden="true">#</a></h2><ul><li>HEAP表存在于内存中，用于临时高速存储</li><li>BLOB或TEXT字段是不允许的，只能使用比较运算符 = ， &lt; ，&gt; , =&gt; ，=&lt;</li><li>HEAP表不支持AUTO_INCREMENT</li><li>索引不可为NULL</li></ul><h2 id="_74-如何区分float和double" tabindex="-1">74 如何区分FLOAT和DOUBLE <a class="header-anchor" href="#_74-如何区分float和double" aria-hidden="true">#</a></h2><ul><li>浮点数以8位精度存储在FLOAT中，并且有四个字节</li><li>浮点数存储在DOUBLE中，精度位18位，有八个字节</li></ul><h2 id="_75-区分char-length和length" tabindex="-1">75 区分CHAR_LENGTH和LENGTH <a class="header-anchor" href="#_75-区分char-length和length" aria-hidden="true">#</a></h2><ul><li>CHAR_LENGTH是字符数，而LENGTH是字节数，</li><li>Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。</li></ul><h2 id="_76-mysql中innodb支持四种事务隔离级别" tabindex="-1">76 MySQL中InnoDB支持四种事务隔离级别 <a class="header-anchor" href="#_76-mysql中innodb支持四种事务隔离级别" aria-hidden="true">#</a></h2><ul><li>read uncommited：读到未提交数据</li><li>read commited：脏读，不可重复读</li><li>repeatable read：可重读</li><li>serializable：串行事务</li></ul><h2 id="_77-enum" tabindex="-1">77 ENUM <a class="header-anchor" href="#_77-enum" aria-hidden="true">#</a></h2><p>ENUM是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用</p><div class="language-shell"><span class="copy"></span><pre><code><span class="line"><span style="color:#C9D1D9;">Create table size(name  ENUM(</span><span style="color:#A5D6FF;">&#39;Smail&#39;</span><span style="color:#C9D1D9;">,</span><span style="color:#A5D6FF;">&#39;Medium&#39;</span><span style="color:#C9D1D9;">,</span><span style="color:#A5D6FF;">&#39;Large&#39;</span><span style="color:#C9D1D9;">))</span><span style="color:#FF7B72;">;</span></span>
<span class="line"></span></code></pre></div><h2 id="_78-定义regexp" tabindex="-1">78 定义REGEXP <a class="header-anchor" href="#_78-定义regexp" aria-hidden="true">#</a></h2><p>REGEXP是模式匹配，其中匹配模式在搜索值的任何位置</p><h2 id="_79-char和varchar区别" tabindex="-1">79 CHAR和VARCHAR区别 <a class="header-anchor" href="#_79-char和varchar区别" aria-hidden="true">#</a></h2><ul><li>CHAR和VARCHAR类型在存储和检索方面有所不同</li><li>CHAR列长度固定为创建表时声明的长度，长度值范围是1到255</li><li>当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格</li></ul><h2 id="_80-列的字符串类型" tabindex="-1">80 列的字符串类型 <a class="header-anchor" href="#_80-列的字符串类型" aria-hidden="true">#</a></h2><p>SET、BLOB、ENUM、CHAR、TEXT、VARCHAR</p><h2 id="_81-timestamp在update-current-timestamp数据类型上做什么" tabindex="-1">81 TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么 <a class="header-anchor" href="#_81-timestamp在update-current-timestamp数据类型上做什么" aria-hidden="true">#</a></h2><p>创建表时TIMESTAMP列用Zero更新，只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP修饰符将时间戳字段更新为当前时间。</p><h2 id="_82-主键和候选键" tabindex="-1">82 主键和候选键 <a class="header-anchor" href="#_82-主键和候选键" aria-hidden="true">#</a></h2><ul><li>表格的每一行都由主键唯一标识，一个表只有一个主键</li><li>主键也是候选键，候选键可以被指定为主键，并且可以用于任何外键引用</li></ul><h2 id="_83-如何控制heap表的最大尺寸" tabindex="-1">83 如何控制HEAP表的最大尺寸 <a class="header-anchor" href="#_83-如何控制heap表的最大尺寸" aria-hidden="true">#</a></h2><p>Heal表的大小可通过称为max_heap_table_size的MySQL配置变量来控制</p><h2 id="_84-mysql-支持事务吗" tabindex="-1">84 mysql 支持事务吗 <a class="header-anchor" href="#_84-mysql-支持事务吗" aria-hidden="true">#</a></h2><ol><li>在缺省模式下，MySQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的</li><li>如果你的MySQL表类型是使用InnoDB Tables或BDB tables的话，MySQL是支持事务处理的，使用set autocommit = 0 就可以使用MySQL允许在非autocommit模式，此时你必须使用commit来提交你的更改，或者用rollback来回滚你的更改</li></ol><div class="language-sql"><span class="copy"></span><pre><code><span class="line"><span style="color:#FF7B72;">start</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">transaction</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF7B72;">select</span><span style="color:#C9D1D9;"> @A:</span><span style="color:#FF7B72;">=</span><span style="color:#79C0FF;">SUM</span><span style="color:#C9D1D9;">(salary) </span><span style="color:#FF7B72;">from</span><span style="color:#C9D1D9;"> table1 </span><span style="color:#FF7B72;">where</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">type</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">1</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF7B72;">update</span><span style="color:#C9D1D9;"> table2 </span><span style="color:#FF7B72;">set</span><span style="color:#C9D1D9;"> summary </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> @A </span><span style="color:#FF7B72;">where</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">type</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">1</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF7B72;">commit</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"></span></code></pre></div><h2 id="_85-mysql-锁" tabindex="-1">85 mysql 锁 <a class="header-anchor" href="#_85-mysql-锁" aria-hidden="true">#</a></h2><ol><li>表级锁：开销小，加锁快，不会出现死锁，锁粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁：开销大，加锁慢，会出现死锁，锁粒度最小，发生锁冲突的概率最低，并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间，会出现死锁，锁粒度界于表锁和行锁之间，并发度一般。</li></ol><blockquote><p>数据库是一个多用户使用的共享资源，当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况， 若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p><p>加锁是实现数据库并发控制的一个非常重要的技术，当事务在对某个数据对象进行操作时，先向系统发出请求，对其加锁， 加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其它事务不能对此数据对象进行更新操作。</p></blockquote><h2 id="_86-mysql-锁优化" tabindex="-1">86 mysql 锁优化 <a class="header-anchor" href="#_86-mysql-锁优化" aria-hidden="true">#</a></h2><ol><li>读写分离</li><li>分段加锁</li><li>减少锁持有的时间</li><li>多个线程尽量以相同的顺序去获取资源</li><li>不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放锁次数过多，反而效率不如一次加一把大锁。</li></ol><h2 id="_87-mysql-表格" tabindex="-1">87 mysql 表格 <a class="header-anchor" href="#_87-mysql-表格" aria-hidden="true">#</a></h2><p>共有5种类型的表格</p><ol><li>myisam</li><li>heap</li><li>merge</li><li>innodb</li><li>isam</li></ol><h2 id="_88-myisam-和-innodb-的区别" tabindex="-1">88 myisam 和 innodb 的区别 <a class="header-anchor" href="#_88-myisam-和-innodb-的区别" aria-hidden="true">#</a></h2><p><strong>myisam</strong></p><ul><li>不支持事务，但是每次查询都是原子的。</li><li>支持表级锁，即每次操作是对整个表加锁。</li><li>存储表的总行数。</li><li>一个 myisam 表有三个文件：索引文件、表结构文件、数据文件。</li><li>采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。</li><li>辅索引与主索引基本一致，但是辅索引不保证唯一性。</li></ul><p><strong>innodb</strong></p><ul><li>支持ACID的事务，支持事务的四种隔离级别。</li><li>支持行级锁及外键约束，因此可以支持写并发。</li><li>不存储总行数。</li><li>一个 innodb 引擎存储在一个文件空间 <ul><li>共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里，也有可能分布在多个文件里</li><li>独立表空间，表大小受操作系统控制，一般为2G</li></ul></li><li>主键索引采用聚簇索引（索引数据域存储数据文件本身）</li><li>辅索引的数据域存储主键的值，因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引。</li><li>最好使用自增主键，防止插入数据时，为维持 B+Tree 结构，文件的大调整。</li></ul><h2 id="_89-innodb-四大事务隔离级别" tabindex="-1">89 innodb 四大事务隔离级别 <a class="header-anchor" href="#_89-innodb-四大事务隔离级别" aria-hidden="true">#</a></h2><p>SQL 标准定义的四个隔离级别为：</p><ol><li>read uncommitted 读未提交数据</li><li>read committed 读已提交数据</li><li>repeatable read 可重复读</li><li>serializable 可串行化</li></ol><h2 id="_90-char-和-varchar-的区别" tabindex="-1">90 char 和 varchar 的区别 <a class="header-anchor" href="#_90-char-和-varchar-的区别" aria-hidden="true">#</a></h2><ol><li>char 和 varchar 类型在存储和检索方面有所不同。</li><li>char 列长度固定为创建表时声明的长度，长度值范围是 1 到 255。</li><li>当 char 值被存储时，它们被用空格填充到特定长度，检索 char 值时需删除尾随空格。</li></ol><h2 id="_91-主键、超键、候选键、外键的区别" tabindex="-1">91 主键、超键、候选键、外键的区别 <a class="header-anchor" href="#_91-主键、超键、候选键、外键的区别" aria-hidden="true">#</a></h2><blockquote><p><strong>原文链接</strong> <a href="https://blog.csdn.net/qq_41860497/article/details/103384657" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_41860497/article/details/103384657</a></p></blockquote><p><strong>定义</strong></p><ol><li><strong>超键</strong>：在关系中能唯一标识元组的属性集被称为关系模式的超键。</li><li><strong>候选键</strong>：不含多余属性的超键被称为候选键。</li><li><strong>主键</strong>：用户选作元组标识的一个候选键称为主键。</li><li><strong>外键</strong>：关系模式 R1 中的某属性集不是 R1 的主键，而是另一个关系 R2 的主键则该属性集是关系模式 R1 的外键。</li></ol><p><strong>举例</strong></p><blockquote><p>假设有两个关系模式</p></blockquote><div class="language-text"><span class="copy"></span><pre><code><span class="line"><span style="color:#c9d1d9;">学生（学号，姓名，班级，课程号，身份证号）</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span>
<span class="line"><span style="color:#c9d1d9;">课程（课程号，课程名）</span></span>
<span class="line"><span style="color:#c9d1d9;"></span></span></code></pre></div><ol><li><strong>超键</strong>：能够唯一表示元组的属性集都可构成超键，所以，由上表知是含有学号，身份证号的集合都可以作为此表的超键。</li></ol><blockquote><p>如 ：(学号) , (学号，姓名 ，班级)，(身份证号，课程号)都可以构成。</p></blockquote><ol start="2"><li><strong>候选键</strong>：候选键是属于超键的，被称为最小的超键。也就是去掉候选键的任一属性，它都不是超键了。</li></ol><blockquote><p>上例中候选键有(学号) ， (身份证号)。</p></blockquote><ol start="3"><li><strong>主键</strong>：主键是候选键中的一个，是人为规定选出符合业务的一个候选键。</li></ol><blockquote><p>如上，虽然学生表有两个候选键但是由于业务需要，通常你可以选择学号作为主键。</p></blockquote><ol start="4"><li><strong>外键</strong>：外键主要是用来描述表之间关系的属性。</li></ol><blockquote><p>学生表中的外键就是课程号。</p></blockquote><p><strong>总结</strong></p><ol><li>表格的每一行都由主键唯一标识，一个表只有一个主键。</li><li>主键也是候选键，按照惯例，候选键可以被指定为主键，并且可用于任何外键引用。</li><li>主键一定是候选键，候选键不一定是主键。</li><li>候选键一定是超键，但超键不一定是候选键。</li><li>外键用来连接两个张表，是另一张表的主键。</li></ol><h2 id="_92-主键、索引、唯一索引、联合索引的区别" tabindex="-1">92 主键、索引、唯一索引、联合索引的区别 <a class="header-anchor" href="#_92-主键、索引、唯一索引、联合索引的区别" aria-hidden="true">#</a></h2><ol><li>索引是一种特殊的文件，它们包含着对数据表里所有记录的引用指针。</li></ol><blockquote><p>innodb 数据表上的索引是表空间的一个组成部分</p></blockquote><ol start="2"><li>普通索引有关键字 KEY 或 INDEX 定义的索引。</li></ol><blockquote><p>唯一任务是加快对数据的访问速度，普通索引允许被索引的数据列包含重复的值</p></blockquote><ol start="3"><li>唯一索引可以保证数据记录的唯一性。</li><li>主键是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录。</li></ol><blockquote><p>关键字 PRIMARY KEY 来创建。</p></blockquote><ol start="5"><li>索引可覆盖多个数据列，像 INDEX(columnA, columnB) 索引，这就是联合索引。</li><li>索引可极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还有操作索引文件。</li></ol><h2 id="_93-外连接、内连接、自连接" tabindex="-1">93 外连接、内连接、自连接 <a class="header-anchor" href="#_93-外连接、内连接、自连接" aria-hidden="true">#</a></h2><blockquote><p>交叉连接：又称笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</p></blockquote><ol><li><strong>内连接</strong>则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中。</li></ol><blockquote><p>内连接只连接匹配的行。</p></blockquote><ol start="2"><li><strong>外连接</strong>其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或者两个表中的所有数据行。</li></ol><blockquote><p>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中， 对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以 NULL 来填充。 右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中，左连接和右连接可以互换</p></blockquote><ol start="3"><li><strong>mysql 目前还不支持全外连接</strong>。</li></ol><h2 id="_94-数据增量优化" tabindex="-1">94 数据增量优化 <a class="header-anchor" href="#_94-数据增量优化" aria-hidden="true">#</a></h2><ol><li>设计良好的数据库结构，允许部分数据冗余，尽量避免 join 查询，提高效率。</li><li>选择合适的表字段数据类型和存储引擎，适当的添加索引。</li><li>主从集群，读写分离。</li><li>找规律分表，减少单表中的数据量提高查询速度。</li><li>添加缓存机制。</li><li>不经常改动的页面，生成静态页面。</li><li>SQL 优化。</li></ol><h2 id="_95-数据库事务" tabindex="-1">95 数据库事务 <a class="header-anchor" href="#_95-数据库事务" aria-hidden="true">#</a></h2><blockquote><p>事务是作为一个单元的一组有序的数据库操作，如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。</p></blockquote><p><strong>事务特性</strong></p><ol><li><strong>原子性</strong>：即不可分割性，事务要么全部被执行，要么全部不被执行。</li><li><strong>一致性或可串行</strong>：事务的执行使得数据库从一种正确状态转换成另一种正确的状态。</li><li><strong>隔离性</strong>：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务。</li><li><strong>持久性</strong>：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</li></ol><h2 id="_96-完整性约束" tabindex="-1">96 完整性约束 <a class="header-anchor" href="#_96-完整性约束" aria-hidden="true">#</a></h2><p>数据完整性是指数据的精确和可靠性</p><ol><li>实体完整性：规定表的每一行在表中是唯一的实体。</li><li>域完整性：是指表中列必须满足某种特定的数据类型约束，其中约束又包括取值范围，精度等规定。</li><li>参考完整性：是指两个表中的主关键字和外关键字的数据应一致，保证了表之间的数据一致性，防止数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。</li></ol><blockquote><p>用户定义的完整性是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</p></blockquote><ol start="5"><li>与表有关约束：包括列约束（NOT NULL 非空约束）和表约束（PRIMARY KEY、CHECK、UNIQUE）</li></ol><h2 id="_97-视图-游标" tabindex="-1">97 视图 游标 <a class="header-anchor" href="#_97-视图-游标" aria-hidden="true">#</a></h2><ol><li>视图是一种虚拟的表，具有和物理表相同的功能，可以对视图进行增、改、查、操作，视图通常是有一个表或者多个表的行或列的子集。</li><li>对视图的修改不影响基本表，它使得我们获取数据更容易，相比多表查询。</li><li>游标：是对查询出来的结果集作为一个单元来有效的处理。</li><li>游标可在该单元中的特定行，从结果集的当前行检索一行或多行，可以对结果集当前行做修改。</li><li>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</li></ol><div class="tip custom-block"><p class="custom-block-title">视图优点</p><ol><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图为数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li></ol></div><h2 id="_98-存储过程" tabindex="-1">98 存储过程 <a class="header-anchor" href="#_98-存储过程" aria-hidden="true">#</a></h2><ol><li>存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。</li><li>如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快，可以用一个命令对象来调用存储过程。</li></ol><h2 id="_99-范式" tabindex="-1">99 范式 <a class="header-anchor" href="#_99-范式" aria-hidden="true">#</a></h2><ol><li>第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解。</li><li>第二范式：2NF 是对记录的唯一性约束，要求记录有唯一标识，即实体的唯一性。</li><li>第三范式：3NF 是对字段冗余性的约束，即任何字段不能由字段派生出来。</li></ol><blockquote><p><strong>三范式设计</strong></p><ul><li><strong>优点</strong>：可以尽量减少数据冗余，使得更新快，体积小。</li><li><strong>缺点</strong>：对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化。</li></ul></blockquote><div class="tip custom-block"><p class="custom-block-title">反范式化</p><ul><li>优点：可以减少表得关联，可更好得进行索引优化。</li><li>缺点：数据冗余以及数据异常，数据得修改需要更多的成本。</li></ul></div><h2 id="_100-sql-优化" tabindex="-1">100 SQL 优化 <a class="header-anchor" href="#_100-sql-优化" aria-hidden="true">#</a></h2><ol><li>where 子句中，where 表之间的连接必须写在其他 where 条件之前。</li></ol><blockquote><p>那些可以过滤最大数量记录的条件必须写在 where 子句的末尾 .HAVING 最后。</p></blockquote><ol start="2"><li>用 EXISTS 代替 IN，用 NOT EXISTS 代替 NOT IN</li><li>避免在索引列上使用计算，使用 IS NULL 和 IS NOT NULL</li><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。</li><li>尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</li></ol><h2 id="_101-sql-分哪几部分" tabindex="-1">101 SQL 分哪几部分 <a class="header-anchor" href="#_101-sql-分哪几部分" aria-hidden="true">#</a></h2><p>SQL 语言包括数据定义（DDL）、数据操纵（DML）、数据控制（DCL）、数据查询（DQL）四个部分。</p><ol><li>数据定义：create table \ alter table \ drop table \ crete index \ drop index 等等</li><li>数据操纵：select \ insert \ update \ delete</li><li>数据控制：grant \ revoke</li><li>数据查询：select</li></ol><h2 id="_102-锁" tabindex="-1">102 锁 <a class="header-anchor" href="#_102-锁" aria-hidden="true">#</a></h2><p>数据库是一个多用户使用的共享资源，当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况，若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p><ol><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ol><h2 id="_103-锁优化" tabindex="-1">103 锁优化 <a class="header-anchor" href="#_103-锁优化" aria-hidden="true">#</a></h2><ol><li>读写分离</li><li>分段加锁</li><li>减少锁持有的时间</li><li>多个线程尽量以相同的顺序去获取资源</li><li>不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放锁次数过多，反而效果不如一次加一把大锁。</li></ol><h2 id="_104-索引" tabindex="-1">104 索引 <a class="header-anchor" href="#_104-索引" aria-hidden="true">#</a></h2><ol><li>索引是一种特殊的文件（InnoDB数据表上的索引是表空间的一个组成部分），它们包含着对数据表里所有记录的引用指针。</li><li>普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。</li><li>普通索引允许被索引的数据列包含重复的值，如果能确定某个数据列将只包含批次各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。</li><li>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字PRIMARY KEY来创建。</li><li>索引可以覆盖多个数据列，如像INDEX(columnA，columnB)索引，这就是联合索引。</li><li>索引可极大的提高数据的查询速度，但是会降低插入、删除、更新表是速度，因为在执行这些写操作时，还要操作索引文件。</li></ol><div class="danger custom-block"><p class="custom-block-title">索引的负面影响</p><ul><li>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加。</li><li>索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间。</li><li>当对表进行增、删、改的时候索引也要动态维护，这样就降低了数据维护速度。</li></ul></div><h2 id="_105-事务" tabindex="-1">105 事务 <a class="header-anchor" href="#_105-事务" aria-hidden="true">#</a></h2><ol><li>事务是作为一个单元的一组有序的数据库操作，如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功，如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</li><li>事务的特性： <ul><li>原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。</li><li>一致性或可串性：事务的执行使得数据库从一种正确状态转换成另一中正确状态。</li></ul></li><li>隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务。</li><li>持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有其他故障，事务的处理结果也得到保存。</li></ol><div class="tip custom-block"><p class="custom-block-title">或者这样理解：</p><p>事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就会失败，以后操作就会回滚到操作前状态，或者是上一个节点。为了确保要么执行，要么不执行，就可以使用事务，要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。</p></div><h2 id="_106-交叉连接、内连接、外连接" tabindex="-1">106 交叉连接、内连接、外连接 <a class="header-anchor" href="#_106-交叉连接、内连接、外连接" aria-hidden="true">#</a></h2><ol><li>交叉连接：又称笛卡尔积，它指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</li><li>内连接：只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。</li><li>外连接：其结果集不仅包含符号连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接、右外连接、全外连接。</li></ol><blockquote><ul><li>左外连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。</li><li>右外连接，右表为主表，右表中的所有记录都会出现在结果集中。</li><li>左连接和右连接可互换。MySQL目前不支持全外连接。</li></ul></blockquote><h2 id="_107-数据完整性" tabindex="-1">107 数据完整性 <a class="header-anchor" href="#_107-数据完整性" aria-hidden="true">#</a></h2><ol><li>数据完整性是指数据的精确和可靠性。</li><li>实体完整性：规定表的每一行在表中是惟一的实体。</li><li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li><li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据一致性，防止数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件，用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ol><h2 id="_108-索引" tabindex="-1">108 索引 <a class="header-anchor" href="#_108-索引" aria-hidden="true">#</a></h2><ol><li>高效数据结构</li><li>索引往往存储在磁盘上的文件中的，可能存储在单独的索引文件中，也可能和数据一起存储在数据文件。</li><li>聚集索引、覆盖索引</li></ol><h2 id="_109-sql" tabindex="-1">109 SQL <a class="header-anchor" href="#_109-sql" aria-hidden="true">#</a></h2><ol><li>查询语句中不要使用 select *</li><li>尽量减少子查询，使用关联查询代替</li><li>减少使用 IN 或 NOT IN 使用 exists ，not exists 或者关联查询语句替代</li><li>or 的查询尽量用 union 或者 union all</li></ol><h2 id="_110-sql-执行" tabindex="-1">110 SQL 执行 <a class="header-anchor" href="#_110-sql-执行" aria-hidden="true">#</a></h2><ol><li>取得链接，使用 MySQL 中的连接器</li><li>查询缓存，key 为 SQL 语句，value 为查询结果，如果查到就直接返回。不建议使用次缓存，在 MySQL 8 版本已经将查询缓存删除，也就是说 MySQL 8 版本后不存在此功能。</li><li>分析器，分为词法分析和语法分析，此阶段只是做了一些 SQL 解析，语法校验。所以一般语法错误在此阶段。</li><li>优化器，是在表里有多个索引的时候，决定使用哪个索引，或者一个语句中存在多表关联的时候，决定各个表的连接顺序。</li><li>执行器，通过分析器让 SQL 知道你要干啥，通过优化器知道该怎么做，开始执行语句。执行语句的时候还有判断是否具备此权限，没有权限就直接返回提示没有权限的错误；有权限则打开表，根据表的引擎定义，去使用这个引擎提供的接口，获取这个表的第一行，判断 id 是都等于 1。如果是，直接返回；如果不是继续调用引擎接口去下一行，重复相同的判断，直到取到这个表的最后一行，最后返回。</li></ol><h2 id="_111-mysql-锁" tabindex="-1">111 MySQL 锁 <a class="header-anchor" href="#_111-mysql-锁" aria-hidden="true">#</a></h2><ol><li>共享锁：不阻塞，多个用户可以同一个时刻读取同一个资源，相互之间没有影响</li><li>排他锁：一个写操作阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源，</li><li>表锁：系统开销最小，会锁定整张表，MyISAM 使用表锁。</li><li>行锁：容易出现死锁，发生冲突概率低，并发高，InnoDB 支持行锁，必须有索引才能实现，否则会自动锁 全表，那么就不是行锁了。</li></ol><h2 id="_112-锁升级" tabindex="-1">112 锁升级 <a class="header-anchor" href="#_112-锁升级" aria-hidden="true">#</a></h2><ol><li>MySQL 行锁只能加上索引上，如果操作不走索引，就会升级为表锁。因为 InnoDB 的行数是加在索引上的，如果不走索引，自然就没法使用行锁了，原因是 InnoDB 是将 primary key index 和相关的行数据共同放在 B + 树的叶节点。</li><li>InnoDB 一定会有一个 primary key，secondary index 查找的时候，也是通过找到对应的 primary ，再找对应的数据行。</li><li>当非唯一索引上记录数据超过一定数量时，行锁也会升级为表锁，测试发现当非唯一索引相同的内容不少于整个表记录的二分之一时会升级为表锁。因为当非唯一索引相同的内容达到整个记录的二分之一时，索引需要的性能比全文检索还要大，查询语句优化时，会选择不走索引，造成索引失效，行锁自然就会升级为表锁。</li></ol><h2 id="_113-悲观锁-vs-乐观锁" tabindex="-1">113 悲观锁 vs 乐观锁 <a class="header-anchor" href="#_113-悲观锁-vs-乐观锁" aria-hidden="true">#</a></h2><ol><li>悲观锁 <ol><li>数据库被外界修改保持着保守态度，因此在整个数据修改过程中，将数据处于锁状态。</li><li>为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其他事务无法修改这些数据。</li><li>修改删除数据时也要加锁，其它事务无法读取这些数据。</li></ol></li><li>乐观锁 <ol><li>相对悲观锁，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能大量开销，特别是对长事务而言，这样的开销往往无法承受。</li><li>大多数基于数据版本记录机制，更新的时候加版本号。</li></ol></li></ol><h2 id="_114-尽量避免死锁的出现" tabindex="-1">114 尽量避免死锁的出现 <a class="header-anchor" href="#_114-尽量避免死锁的出现" aria-hidden="true">#</a></h2><ol><li>设置获取锁的超时时间，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁</li><li>设置按照同一顺序访问资源，类似于串行执行。</li><li>避免事务中的用户交叉</li><li>保持事务简短并在一个批处理中。</li><li>使用低隔离级别</li><li>使用绑定链接</li></ol><h2 id="_115-union-union-all" tabindex="-1">115 union &amp; union all <a class="header-anchor" href="#_115-union-union-all" aria-hidden="true">#</a></h2><blockquote><p><a href="https://huaweicloud.csdn.net/63356823d3efff3090b55f16.html" target="_blank" rel="noopener noreferrer">https://huaweicloud.csdn.net/63356823d3efff3090b55f16.html</a></p><p><a href="https://blog.csdn.net/zouxucong/article/details/73468979" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/zouxucong/article/details/73468979</a></p></blockquote><ol><li>union 操作符用于合并两个或多个 select 语句的结果集，这里需要注意的是：union 内部的 select 语句必须拥有相同的数量列，列也必须拥有相似的数据类型，同时，每条 select 语句中列的顺序必须相同。</li><li>union 操作符合并的结果集，不会允许重复值，如果允许有重复值的话，使用 union all</li></ol><h2 id="_116-性能优化" tabindex="-1">116 性能优化 <a class="header-anchor" href="#_116-性能优化" aria-hidden="true">#</a></h2><p>参考：<a href="https://blog.csdn.net/Xumuyang_/article/details/120975897" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/Xumuyang_/article/details/120975897</a></p><ol><li>选择最合适的字段属性</li><li>尽量把字段设置为NOT NULL</li><li>使用连接(JOIN)来代替子查询(Sub-Queries) 经过多方面的证实inner join性能比较快</li><li>使用联合(UNION)来代替手动创建的临时表</li><li>不使用子查询</li><li>避免函数索引</li><li>用IN来替换OR</li><li>LIKE双百分号无法使用到索引</li><li>读取适当的记录LIMIT M,N</li><li>避免数据类型不一致</li><li>分组统计可以禁止排序</li><li>避免随机函数取记录</li><li>禁止不必要的ORDER BY排序</li><li>批量INSERT插入</li></ol><h2 id="_117-优化语句" tabindex="-1">117 优化语句 <a class="header-anchor" href="#_117-优化语句" aria-hidden="true">#</a></h2><ol><li>避免在列上做运算，可能会导致索引失败</li><li>使用join时应该小结果集驱动大结果集，同时把复杂的join查询拆分成多个query，不然join越多表，会导致越多的锁定和堵塞</li><li>like避免使用%%</li><li>不要使用select *</li><li>使用批量插入语句，减少交互</li><li>limit基数较大时，使用between and</li><li>不要使用rand函数随机获取记录</li><li>避免使用null，建表时尽量设置not null</li><li>不要使用count(id)，应用使用count(*)</li><li>不要做无谓的排序，尽可能在索引中完成排序</li><li>from语句中一定不要使用子查询</li><li>使用where加以限制，缩小查找范围</li><li>合理运用索引</li><li>使用explain 查看sql性能</li></ol><h2 id="_118-优化分库" tabindex="-1">118 优化分库 <a class="header-anchor" href="#_118-优化分库" aria-hidden="true">#</a></h2><ol><li>先查询缓存进行优化</li><li>explain 的查询结果会告诉你索引主键是如何被利用的</li><li>只需要一行数据时使用 limit 1</li><li>为搜索字段添加索引</li><li>在关联表的时候使用相当类型的例，并将其索引</li><li>千万不要order by rand()</li><li>避免select *</li><li>永远为每张表设置一个ID</li><li>使用ENUM而不是varchar</li><li>从procedure analys()提取建议</li><li>尽可能的使用not null</li><li>java中使用prepared statements</li><li>无缓冲的查询</li><li>把ip地址存成unsigned int</li><li>固定表的长度</li><li>垂直分库：是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的</li><li>水平分库：是一种把数据库中的表按行变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的</li><li>越小的列会越快</li><li>选择正确的存储引擎</li><li>使用一个对象关系映射器</li><li>小心永久链接</li><li>拆分大的delete和insert语句</li></ol><h2 id="_119-优化索引" tabindex="-1">119 优化索引 <a class="header-anchor" href="#_119-优化索引" aria-hidden="true">#</a></h2><blockquote><p>在数据库表中对字段建立索引可以大大提高查询速度</p></blockquote><ol><li>Mysql索引类型 <ol><li>普通索引</li><li>唯一索引，值必须唯一允许有空值，如果是组合索引，则列值的组合必须唯一</li><li>主键索引，一种特殊的唯一索引，不允许有空值，一般在创建表的时候创建主键索引</li><li>组合索引，多字段建到一个索引里</li></ol></li><li>索引失效 <ol><li>条件有or，要想or生效，每个列都加上索引</li><li>like以%开头，失效</li><li>存在索引列的数据类型隐形转换，失效</li><li>where子句里对索引运算，失效</li><li>where子句对索引列使用函数，失效</li><li>使用全表扫描要比用索引快</li></ol></li><li>不推荐使用索引 <ol><li>数据唯一性差的字段不要使用索引</li><li>频繁更新的字段不要使用索引</li><li>字段不在where语句中出现时，不要添加索引，如果where后含 is null/is not null/like &quot;%输入符%&quot;等条件，不要使用索引</li><li>where子句里对索引使用不等于&lt;&gt;，不要使用索引</li></ol></li></ol><h2 id="_120-优化数据库" tabindex="-1">120 优化数据库 <a class="header-anchor" href="#_120-优化数据库" aria-hidden="true">#</a></h2><ol><li>用PreparedStatement，一般来说比Statement性能高：一个sql发给服务器去执行，涉及步骤：语法检查，语义分析，编译，缓存</li><li>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键</li><li>表中允许适当的冗余</li><li>union all要比union快很多，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用union all</li></ol></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-16T01:45:19.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>