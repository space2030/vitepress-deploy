<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java2 平台企业版</title>
    <meta name="description" content="VitePress">
    <link rel="stylesheet" href="/vitepress-deploy/assets/style.c6a8f29c.css">
    <link rel="modulepreload" href="/vitepress-deploy/assets/app.2a154df8.js">
    <link rel="modulepreload" href="/vitepress-deploy/assets/src_view_java_java-02-ee.md.06cece6f.lean.js">
    
    <link rel="icon" href="https://cn.vitejs.dev/logo-with-shadow.png">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-581d5782><!--[--><!--]--><!--[--><span tabindex="-1" data-v-2c02b834></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-2c02b834> Skip to content </a><!--]--><!----><header class="VPNav no-sidebar" data-v-581d5782 data-v-119e663c><div class="VPNavBar" data-v-119e663c data-v-1f7b674d><div class="container" data-v-1f7b674d><div class="VPNavBarTitle" data-v-1f7b674d data-v-ed531ba2><a class="title" href="/vitepress-deploy/" data-v-ed531ba2><!--[--><img class="VPImage logo" src="https://cn.vitejs.dev/logo-with-shadow.png" data-v-81172f9c><!--]--><!--[-->首页<!--]--></a></div><div class="content" data-v-1f7b674d><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1f7b674d data-v-192c109a><span id="main-nav-aria-label" class="visually-hidden" data-v-192c109a>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/view/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->问答<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/web/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->前端<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/deploy/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->部署<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/kit/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->工具<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress-deploy/src/case/index.html" data-v-192c109a data-v-4d31877c data-v-8dd034e6><!--[-->案例<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1f7b674d data-v-5cf7609e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-5cf7609e data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1f7b674d data-v-a767cbbe data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1f7b674d data-v-6a32f7d6 data-v-44cec2e6><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-44cec2e6><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-44cec2e6><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-44cec2e6><div class="VPMenu" data-v-44cec2e6 data-v-ddb22576><!----><!--[--><!--[--><!----><div class="group" data-v-6a32f7d6><div class="item appearance" data-v-6a32f7d6><p class="label" data-v-6a32f7d6>Appearance</p><div class="appearance-action" data-v-6a32f7d6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-6a32f7d6 data-v-766c3cb1 data-v-d6dfd774><span class="check" data-v-d6dfd774><span class="icon" data-v-d6dfd774><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-766c3cb1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-766c3cb1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-6a32f7d6><div class="item social-links" data-v-6a32f7d6><div class="VPSocialLinks social-links-list" data-v-6a32f7d6 data-v-e03f590e><!--[--><a class="VPSocialLink" href="https://github.com/space2030?tab=repositories" title="github" target="_blank" rel="noopener noreferrer" data-v-e03f590e data-v-3dd9970c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3dd9970c><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-3dd9970c>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1f7b674d data-v-3524c702><span class="container" data-v-3524c702><span class="top" data-v-3524c702></span><span class="middle" data-v-3524c702></span><span class="bottom" data-v-3524c702></span></span></button></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-581d5782 data-v-804f35da><div class="VPDoc" data-v-804f35da data-v-3886f8ec><div class="container" data-v-3886f8ec><div class="aside" data-v-3886f8ec><div class="aside-curtain" data-v-3886f8ec></div><div class="aside-container" data-v-3886f8ec><div class="aside-content" data-v-3886f8ec><div class="VPDocAside" data-v-3886f8ec data-v-a4f49d12><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-a4f49d12 data-v-2d325df8><div class="content" data-v-2d325df8><div class="outline-marker" data-v-2d325df8></div><div class="outline-title" data-v-2d325df8>目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-2d325df8><span class="visually-hidden" id="doc-outline-aria-label" data-v-2d325df8> Table of Contents for current page </span><ul class="root" data-v-2d325df8><!--[--><li style="" data-v-2d325df8><a class="outline-link" href="#jvm-性能优化" data-v-2d325df8>JVM 性能优化</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_01-java类加载过程" data-v-2d325df8>01 Java类加载过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_02-java内存分配" data-v-2d325df8>02 Java内存分配</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_03-jvm加载class文件的原理机制" data-v-2d325df8>03 JVM加载Class文件的原理机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_04-gc" data-v-2d325df8>04 GC</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_05-gc对象的判定" data-v-2d325df8>05 GC对象的判定</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_06-垃圾回收优点" data-v-2d325df8>06 垃圾回收优点</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_07-内存泄漏" data-v-2d325df8>07 内存泄漏</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_08-finalize方法" data-v-2d325df8>08 finalize方法</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_09-分布式垃圾回收" data-v-2d325df8>09 分布式垃圾回收</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_10-内存模型以及分区，需要详细到每个区放什么。" data-v-2d325df8>10 内存模型以及分区，需要详细到每个区放什么。</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_11-堆里面的分区：eden，survival-（from-to），老年代，各自的特点。" data-v-2d325df8>11 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_12-gc-的两种判定方法：" data-v-2d325df8>12 GC 的两种判定方法：</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_13-safepoint-是什么" data-v-2d325df8>13 SafePoint 是什么</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_14-循环的末尾-防止大循环的时候一直不进入-safepoint，而其他线程在等待它进入-safepoint" data-v-2d325df8>14 循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入 safepoint)</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_15-gc-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" data-v-2d325df8>15 GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_16-gc-收集器有哪些？cms-收集器与-g1-收集器的特点。" data-v-2d325df8>16 GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_17-minor-gc-与-full-gc-分别在什么时候发生？" data-v-2d325df8>17 Minor GC 与 Full GC 分别在什么时候发生？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_18-几种常用的内存调试工具：jmap、jstack、jconsole、jhat" data-v-2d325df8>18 几种常用的内存调试工具：jmap、jstack、jconsole、jhat</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_19-类加载过程" data-v-2d325df8>19 类加载过程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_20-jvm-内存分哪几个区，每个区的作用是什么" data-v-2d325df8>20 JVM 内存分哪几个区，每个区的作用是什么?</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_21-判断一个对象是否存活有两种方法" data-v-2d325df8>21 判断一个对象是否存活有两种方法:</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_22-垃圾回收机制" data-v-2d325df8>22 垃圾回收机制</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_23-垃圾收集的方法" data-v-2d325df8>23 垃圾收集的方法</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_24-内存模型" data-v-2d325df8>24 内存模型</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_25-java-类加载过程" data-v-2d325df8>25 java 类加载过程?</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_26-简述-java-类加载机制" data-v-2d325df8>26 简述 java 类加载机制?</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_27-类加载器双亲委派模型机制？" data-v-2d325df8>27 类加载器双亲委派模型机制？</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_28-类加载器" data-v-2d325df8>28 类加载器</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_29-简述-java-内存分配与回收策率以及-minor-gc-和-major-gc" data-v-2d325df8>29 简述 java 内存分配与回收策率以及 Minor GC 和 Major GC</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_30-网络编程" data-v-2d325df8>30 网络编程</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_31-网络协议" data-v-2d325df8>31 网络协议</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_32-tcp-ip参考模型" data-v-2d325df8>32 TCP/IP参考模型</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_33-tcp-vs-udp" data-v-2d325df8>33 TCP  vs  UDP</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_34-arp（address-resolution-protocol）" data-v-2d325df8>34 ARP（Address Resolution Protocol）</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_35-nat（network-address-translation，网络地址转换）" data-v-2d325df8>35 NAT（Network  Address  Translation，网络地址转换）</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_36-jvm-调优的工具" data-v-2d325df8>36 JVM 调优的工具</a><!----></li><li style="" data-v-2d325df8><a class="outline-link" href="#_37-jvm-调优" data-v-2d325df8>37 jvm 调优</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-a4f49d12></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-3886f8ec><div class="content-container" data-v-3886f8ec><!--[--><!--]--><main class="main" data-v-3886f8ec><div style="position:relative;" class="vp-doc _vitepress-deploy_src_view_java_java-02-ee" data-v-3886f8ec><div><h1 id="java2-平台企业版" tabindex="-1">Java2 平台企业版 <a class="header-anchor" href="#java2-平台企业版" aria-hidden="true">#</a></h1><h2 id="jvm-性能优化" tabindex="-1">JVM 性能优化 <a class="header-anchor" href="#jvm-性能优化" aria-hidden="true">#</a></h2><h2 id="_01-java类加载过程" tabindex="-1">01 Java类加载过程 <a class="header-anchor" href="#_01-java类加载过程" aria-hidden="true">#</a></h2><ol><li>加载。类加载的第一个过程，通过一个类的全限定名获取该类的二进制流。将该二进制流中的静态存储结构转化为方法去运行时数据结构，在内存中生成该类的Class对象，作为该类的数据访问入口。</li><li>验证。为了确保Class文件的字节流中的信息不会危害到虚拟机。文件格式验证、元数据验证、字节码验证、符号引用验证。</li><li>准备。为类的静态变量分配内存将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随对象一起分配在Java堆中。</li><li>解析。该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也可能在初始化之后。</li><li>初始化。初始化是类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可通过自定义类加载器参与之外，其余工作完全由虚拟机主导和控制。</li><li>使用</li><li>卸载</li></ol><h2 id="_02-java内存分配" tabindex="-1">02 Java内存分配 <a class="header-anchor" href="#_02-java内存分配" aria-hidden="true">#</a></h2><ol><li>寄存器：我们无法控制。</li><li>静态域：static定义的静态成员。</li><li>常量池：编译时被确定并保存在.class文件中常量值和一些文本修饰的符号引用。</li><li>非RAM存储：硬盘等永久存储空间。</li><li>栈内存：基本类型的变量和对象的引用变量，速度快，可共享，但大小和生存期必须确定，缺乏灵活性。</li><li>堆：JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动时被创建，对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没被垃圾收集器回收掉的对象，一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</li></ol><h2 id="_03-jvm加载class文件的原理机制" tabindex="-1">03 JVM加载Class文件的原理机制 <a class="header-anchor" href="#_03-jvm加载class文件的原理机制" aria-hidden="true">#</a></h2><ol><li>类只有被加载到JVM后才能运行。当运行指定程序时，JVM会将编译生成的.class文件按照需求和一定的规则加载到内存中，并组织成为一个完整的java应用程序，这个加载过程是由类加载器完成，具体，就是由ClassLoader和它的子类来实现的，类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。</li><li>类加载方式分为隐式加载和显示加载，隐式加载指的是程序在使用new等方式创建对象时，会隐式地调用类的加载器把对应的类加载到JVM中。显示加载指的是通过直接调用<code>class.forName()</code>方法来把所需的类加载到JVM中。</li><li>每个类或接口都对应一个.class文件，这些文件可被看成一个可被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件。</li><li>类加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类完全加载到JVM中，至于其他类，则在需要的时候才加载。</li></ol><blockquote><p>类加载的主要步骤：</p><ul><li>装载：根据查找路径找到相应的class文件，然后导入。</li><li>链接：检查待加载的class文件的正确性，准备给类中的静态变量分配存储空间，将符号引用转换为直接引用。</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul></blockquote><h2 id="_04-gc" tabindex="-1">04 GC <a class="header-anchor" href="#_04-gc" aria-hidden="true">#</a></h2><p>垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可自动监测对象，是否超过作用域从而达到自动回收内存的目的。</p><h2 id="_05-gc对象的判定" tabindex="-1">05 GC对象的判定 <a class="header-anchor" href="#_05-gc对象的判定" aria-hidden="true">#</a></h2><p>判断一个对象是否存活有两种方法：</p><ul><li><p>引用计数法</p><ul><li>给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用。</li><li>引用计数法有一个缺陷就是无法解决循环引用问题，当对象A引用对象B，对象B又引用对象A，那么此时AB对象的引用计数器都不为零，也就造成无法完成垃圾回收，所有主流的虚拟机都没采用这种算法。</li></ul></li><li><p>可达性算法（引用链法）</p><ul><li>该算法思想：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">在Java中可作为GC Roots的对象有以下几种：</p><ul><li>虚拟机栈中引用的对象。</li><li>方法区类静态属性引用的对象，方法区常量池引用的对象。</li><li>本地方法栈JNI引用的对象。</li></ul></div><blockquote><p>当一个对象不可达GC Root时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记。</p></blockquote><p>如果对象在可达性分析中没有与GC Root的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行<code>finalize()</code>方法。</p><blockquote><p>-当对象没有覆盖<code>finalize()</code>方法或者已被虚拟机调用过，那么就认为没必要。</p><ul><li>如果该对象有必要执行<code>finalize()</code>方法，那么这个对象将会放在一个称为<code>F-Queue</code>的队列中，虚拟机会触发一个<code>Finalize()</code>线程去执行，此时线程是低优先级的，并且虚拟机不会承若一直等待它运行完，这是因为如果<code>finalize()</code>执行缓慢或者发生死锁，那么就造成<code>F-Queue</code>队列一直等待，造成了内存回收系统的崩溃。</li><li>GC对处于<code>F-Queue</code>中的对象进行第二次被标记，这时，该对象将被移除。即将回收集合，等待回收。</li></ul></blockquote><h2 id="_06-垃圾回收优点" tabindex="-1">06 垃圾回收优点 <a class="header-anchor" href="#_06-垃圾回收优点" aria-hidden="true">#</a></h2><ul><li><p>Java编写程序的时候不再需要考虑内存管理。</p></li><li><p>垃圾回收可有效防止内存泄漏，有效的使用内存。</p></li><li><p>垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</p></li><li><p>回收机制有分代复制垃圾回收和标记回收，增量垃圾回收。</p></li></ul><h2 id="_07-内存泄漏" tabindex="-1">07 内存泄漏 <a class="header-anchor" href="#_07-内存泄漏" aria-hidden="true">#</a></h2><ul><li><p>内存泄漏就是指一个不再被程序使用的对象或变量一直被占据在内存中。</p></li><li><p>Java使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题。例如有两个对象相互引用，只要它们和根进程不可达，那么GC也是可回收它们的。</p></li><li><p>Java中内存泄漏的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为 长生命周期对象持有它的引用而导致不能被回收。例如：缓存系统，我们加载了一个对象放在缓存中（例如放在一个全局的map对象中），然后一直不再使用它，这对象一直被缓存引用，但却不再被使用。</p></li></ul><div class="tip custom-block"><p class="custom-block-title">场景</p><ul><li><p>（1）检查Java中的内存泄漏，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄漏。</p></li><li><p>（2）如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但是由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p></li><li><p>（3）当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则对象修改后的哈希值与最初存储进HashSet集合中的哈希值就不同了，这种情况下，<strong>即使在contains方法使用该对象的当前引用，作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，</strong> 这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p></li></ul></div><h2 id="_08-finalize方法" tabindex="-1">08 finalize方法 <a class="header-anchor" href="#_08-finalize方法" aria-hidden="true">#</a></h2><ul><li><p>最主要的作用是回收特殊渠道申请的内存。</p></li><li><p>JNI（Java Native Interface）调用 non-java 程序（C或C++），finalize()的工作就是回收这部分内存。</p></li></ul><h2 id="_09-分布式垃圾回收" tabindex="-1">09 分布式垃圾回收 <a class="header-anchor" href="#_09-分布式垃圾回收" aria-hidden="true">#</a></h2><ul><li><p>RMI使用DGC来做自动垃圾回收</p></li><li><p>RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。</p></li><li><p>DGC使用引用计数算法来给远程对象提供自动内存管理。</p></li></ul><h2 id="_10-内存模型以及分区，需要详细到每个区放什么。" tabindex="-1">10 内存模型以及分区，需要详细到每个区放什么。 <a class="header-anchor" href="#_10-内存模型以及分区，需要详细到每个区放什么。" aria-hidden="true">#</a></h2><ol><li>JVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面，</li><li>class 类信息常量池（static 常量和 static 变量）等放在方法区</li><li>方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据</li><li>堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配</li><li>栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类型，所以还是一个指向地址的指针</li><li>本地方法栈：主要为 Native 方法服务</li><li>程序计数器：记录当前线程执行的行号</li></ol><h2 id="_11-堆里面的分区：eden，survival-（from-to），老年代，各自的特点。" tabindex="-1">11 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。 <a class="header-anchor" href="#_11-堆里面的分区：eden，survival-（from-to），老年代，各自的特点。" aria-hidden="true">#</a></h2><ol><li>堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），</li><li>新生代包含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，</li><li>如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，</li><li>存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区</li><li>当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice 区，然后进行垃圾清理。</li><li>因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。</li><li>那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。</li><li>如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。</li></ol><h2 id="_12-gc-的两种判定方法：" tabindex="-1">12 GC 的两种判定方法： <a class="header-anchor" href="#_12-gc-的两种判定方法：" aria-hidden="true">#</a></h2><ul><li><p><strong>引用计数法</strong>：指的是如果某个地方引用了这个对象就+1，</p><ul><li>如果失效了就-1，当为 0 就会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）的情况</li></ul></li><li><p><strong>引用链法</strong>： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，</p><ul><li>如果有一条链能够到达 GC ROOT 就说明，不能到达 GC ROOT 就说明可以回收</li></ul></li></ul><h2 id="_13-safepoint-是什么" tabindex="-1">13 SafePoint 是什么 <a class="header-anchor" href="#_13-safepoint-是什么" aria-hidden="true">#</a></h2><p>比如 GC 的时候必须要等到 Java 线程都进入到 safepoint 的时候 VMThread 才能开始执行 GC，</p><h2 id="_14-循环的末尾-防止大循环的时候一直不进入-safepoint，而其他线程在等待它进入-safepoint" tabindex="-1">14 循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入 safepoint) <a class="header-anchor" href="#_14-循环的末尾-防止大循环的时候一直不进入-safepoint，而其他线程在等待它进入-safepoint" aria-hidden="true">#</a></h2><ol><li>方法返回前</li><li>调用方法的 call 之后</li><li>抛出异常的位置</li></ol><h2 id="_15-gc-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" tabindex="-1">15 GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？ <a class="header-anchor" href="#_15-gc-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" aria-hidden="true">#</a></h2><ul><li>先标记，标记完毕之后再清除，效率不高，会产生碎片</li><li>复制算法：分为 8：1 的 Eden 区和 survivor 区，就是上面谈到的 YGC</li><li>标记整理：标记完毕之后，让所有存活的对象向一端移动</li></ul><h2 id="_16-gc-收集器有哪些？cms-收集器与-g1-收集器的特点。" tabindex="-1">16 GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。 <a class="header-anchor" href="#_16-gc-收集器有哪些？cms-收集器与-g1-收集器的特点。" aria-hidden="true">#</a></h2><ul><li>并行收集器：串行收集器使用一个单独的线程进行收集，GC 时服务有停顿时间</li><li>串行收集器：次要回收中使用多线程来执行 CMS 收集器是基于“标记—清除”算法实现的，经过多次标记才会被清除 G1 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的</li></ul><h2 id="_17-minor-gc-与-full-gc-分别在什么时候发生？" tabindex="-1">17 Minor GC 与 Full GC 分别在什么时候发生？ <a class="header-anchor" href="#_17-minor-gc-与-full-gc-分别在什么时候发生？" aria-hidden="true">#</a></h2><p>新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC</p><h2 id="_18-几种常用的内存调试工具：jmap、jstack、jconsole、jhat" tabindex="-1">18 几种常用的内存调试工具：jmap、jstack、jconsole、jhat <a class="header-anchor" href="#_18-几种常用的内存调试工具：jmap、jstack、jconsole、jhat" aria-hidden="true">#</a></h2><p>jstack 可以看当前栈的情况，jmap 查看内存，jhat 进行 dump 堆的信息 mat（eclipse 的也要了解一下）</p><h2 id="_19-类加载过程" tabindex="-1">19 类加载过程 <a class="header-anchor" href="#_19-类加载过程" aria-hidden="true">#</a></h2><blockquote><p><strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>。然后是使用和卸载了</p></blockquote><ul><li>加载通过全限定名来加载生成 class 对象到内存中，然后进行验证这个 class 文件，包括文件格式校验、元数据验证，字节码校验等。</li><li>准备是对这个对象分配内存。</li><li>解析是将符号引用转化为直接引用（指针引用），</li><li>初始化就是开始执行构造器的代码</li></ul><h2 id="_20-jvm-内存分哪几个区，每个区的作用是什么" tabindex="-1">20 JVM 内存分哪几个区，每个区的作用是什么? <a class="header-anchor" href="#_20-jvm-内存分哪几个区，每个区的作用是什么" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">方法区</p><ol><li>方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。该区域是被线程共享的。</li><li>方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。</li><li>该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</li></ol></div><div class="tip custom-block"><p class="custom-block-title">虚拟机栈</p><ol><li>虚拟机栈也就是我们平常所称的栈内存,它为 java 方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</li><li>虚拟机栈是线程私有的，它的生命周期与线程相同。</li><li>局部变量表里存储的是基本数据类型、returnAddress 类型（指向一条字节码指令的地址）和对象引用，</li><li>这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。</li><li>局部变量所需的内存空间在编译器间确定操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</li><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，</li><li>持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</li></ol></div><div class="tip custom-block"><p class="custom-block-title">本地方法栈</p><p>本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。</p></div><div class="tip custom-block"><p class="custom-block-title">堆</p><p>java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p></div><div class="tip custom-block"><p class="custom-block-title">程序计数器</p><ul><li>内存空间小，字节码解释器工作时通过改变这个计数值，可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。</li><li>该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。</li></ul></div><h2 id="_21-判断一个对象是否存活有两种方法" tabindex="-1">21 判断一个对象是否存活有两种方法: <a class="header-anchor" href="#_21-判断一个对象是否存活有两种方法" aria-hidden="true">#</a></h2><div class="danger custom-block"><p class="custom-block-title">引用计数法</p><p>所谓引用计数法就是给每一个对象设置一个引用计数器，</p><ul><li>每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。</li><li>当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.</li><li>引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，</li><li>对象 B 又引用者对象 A，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</li></ul></div><div class="danger custom-block"><p class="custom-block-title">可达性算法(引用链法)</p><p>该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，</p><ol><li>如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。</li><li>在 java 中可以作为 GC Roots 的对象有以下几种: <ul><li>虚拟机栈中引用的对象</li><li>方法区类静态属性引用的对象</li><li>方法区常量池引用的对象</li><li>本地方法栈 JNI 引用的对象</li></ul></li><li>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。</li><li>当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，</li><li>若要被真正的回收需要经历两次标记如果对象在可达性分析中没有与 GC Root 的引用链，</li><li>那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize()方法。</li><li>当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。</li><li>如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，</li><li>虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，</li><li>这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 F�Queue 队列一直等待，造成了内存回收系统的崩溃。</li><li>GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。</li></ol></div><h2 id="_22-垃圾回收机制" tabindex="-1">22 垃圾回收机制 <a class="header-anchor" href="#_22-垃圾回收机制" aria-hidden="true">#</a></h2><ol><li>在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。</li><li>在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，</li><li>扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</li></ol><h2 id="_23-垃圾收集的方法" tabindex="-1">23 垃圾收集的方法 <a class="header-anchor" href="#_23-垃圾收集的方法" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">标记-清除:</p><ul><li>这是垃圾收集算法中最基础的，</li><li>根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。</li><li>这种方法很简单，但是会有两个主要问题：</li><li>1.效率不高，标记和清除的效率都很低；</li><li>2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">复制算法</p><ul><li>为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，</li><li>然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，</li><li>然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式内存的代价太高，每次基本上都要浪费一般的内存。</li><li>于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，</li><li>而是将内存划分为 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。</li><li>每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，</li><li>然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(java 堆又分为新生代和老年代)</li></ul></div><div class="tip custom-block"><p class="custom-block-title">标记-整理</p><ul><li>该算法主要是为了解决标记-清除，产生大量内存碎片的问题；</li><li>当对象存活率较高时，也解决了复制算法的效率问题。</li><li>它的不同之处就是在清除对象的时候现将可回收对象移动到一端，</li><li>然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">分代收集</p><ul><li>现在的虚拟机垃圾收集大多采用这种方式，</li><li>它根据对象的生存周期，将堆分为新生代和老年代。</li><li>在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。</li><li>老年代里的对象存活率较高，没有额外的空间进行分配担保，</li><li>所以可以使用标记-整理 或者 标记-清除。</li></ul></div><h2 id="_24-内存模型" tabindex="-1">24 内存模型 <a class="header-anchor" href="#_24-内存模型" aria-hidden="true">#</a></h2><ul><li>java 内存模型(JMM)是线程间通信的控制机制.</li><li>JMM 定义了主内存和线程之间抽象关系。</li><li>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），</li><li>本地内存中存储了该线程以读/写共享变量的副本。</li><li>本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</li></ul><h2 id="_25-java-类加载过程" tabindex="-1">25 java 类加载过程? <a class="header-anchor" href="#_25-java-类加载过程" aria-hidden="true">#</a></h2><p>java 类加载需要经历一下 7 个过程：</p><div class="tip custom-block"><p class="custom-block-title">加载</p><p>加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p><ul><li>通过一个类的全限定名获取该类的二进制流。</li><li>将该二进制流中的静态存储结构转化为方法去运行时数据结构。</li><li>在内存中生成该类的 Class 对象，作为该类的数据访问入口。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">验证</p><p>验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成 <strong>以下四钟验证:</strong></p><ul><li>文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</li><li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</li><li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转 指令是否正确等。</li><li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">准备</p><ul><li>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。</li><li>准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</li></ul><div class="language-java"><span class="copy"></span><pre><code><span class="line"><span style="color:#FF7B72;">public</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">static</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">int</span><span style="color:#FFA657;"> </span><span style="color:#C9D1D9;">value</span><span style="color:#FF7B72;">=</span><span style="color:#79C0FF;">123</span><span style="color:#C9D1D9;">;</span></span>
<span class="line"><span style="color:#8B949E;">// 在准备阶段 value 初始值为 0 。在初始化阶段才会变为 123 。</span></span>
<span class="line"></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">解析</p><p>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p></div></div><div class="tip custom-block"><p class="custom-block-title">初始化</p><p>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外， 其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</p></div><h2 id="_26-简述-java-类加载机制" tabindex="-1">26 简述 java 类加载机制? <a class="header-anchor" href="#_26-简述-java-类加载机制" aria-hidden="true">#</a></h2><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型。</p><h2 id="_27-类加载器双亲委派模型机制？" tabindex="-1">27 类加载器双亲委派模型机制？ <a class="header-anchor" href="#_27-类加载器双亲委派模型机制？" aria-hidden="true">#</a></h2><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p><h2 id="_28-类加载器" tabindex="-1">28 类加载器 <a class="header-anchor" href="#_28-类加载器" aria-hidden="true">#</a></h2><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。主要有一下四种类加载器:</p><ol><li>启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</li></ol><h2 id="_29-简述-java-内存分配与回收策率以及-minor-gc-和-major-gc" tabindex="-1">29 简述 java 内存分配与回收策率以及 Minor GC 和 Major GC <a class="header-anchor" href="#_29-简述-java-内存分配与回收策率以及-minor-gc-和-major-gc" aria-hidden="true">#</a></h2><ul><li>对象优先在堆的 Eden 区分配。</li><li>大对象直接进入老年代.</li><li>长期存活的对象将直接进入老年代. 当 Eden 区没有足够的空间进行分配时，</li><li>虚拟机会执行一次 Minor GC.Minor Gc 通常发生在新生代的 Eden 区，</li><li>在这个区的对象生存期短，往往发生 Gc 的频率较高，</li><li>回收速度比较快;Full Gc/Major GC 发生在老年代，</li><li>一般情况下，触发老年代 GC 的时候不会触发 Minor GC</li><li>但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。</li></ul><h2 id="_30-网络编程" tabindex="-1">30 网络编程 <a class="header-anchor" href="#_30-网络编程" aria-hidden="true">#</a></h2><ol><li>一个是如何准确的定位网络上一台或多台主机。</li><li>另一个就是找到主机后如何可靠高效的进行数据传输。</li><li>在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定Internet上的一台主机，而TCP层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象</li></ol><h2 id="_31-网络协议" tabindex="-1">31 网络协议 <a class="header-anchor" href="#_31-网络协议" aria-hidden="true">#</a></h2><p>在计算机网络要做到井井有条的交换数据，就必须遵守一些实现约定好的规则，比如交换数据的格式，是否需要发送一个应答信息，这些规则被称为网络协议。</p><h2 id="_32-tcp-ip参考模型" tabindex="-1">32 TCP/IP参考模型 <a class="header-anchor" href="#_32-tcp-ip参考模型" aria-hidden="true">#</a></h2><ol><li>应用层，最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务，网络服务协议：HTTP、HTTPS、FTP、TELNET等</li><li>传输层，建立了主机端到端的连接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题，该层向高层屏蔽了下层的数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的，可由用户控制和设定的、可靠的数据通路，TCP、UDP都在这一层，端口号既是这里的“端”</li><li>网络层，本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层，就是通常说的IP层，这一层就是经常说的IP协议层，IP协议是Internet的基础。</li><li>数据链路层，通过一些 规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路。</li></ol><h2 id="_33-tcp-vs-udp" tabindex="-1">33 TCP vs UDP <a class="header-anchor" href="#_33-tcp-vs-udp" aria-hidden="true">#</a></h2><ol><li>TCP面向连接的协议，发送数据前要先建立连接（发送方和接收方的成对的两个之间必须建立连接），TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达。</li><li>UDP它是属于TCP/IP协议族中的一种，是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议，因为不需要建立连接，所以在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都不能被保证的。</li><li>TCP是面向字节流的，UDP是面向报文的</li><li>TCP首部开销（20字节）比UDP首部开销（8字节）要大</li><li>UDP的主机不需要维持复杂的连接状态表</li></ol><h2 id="_34-arp（address-resolution-protocol）" tabindex="-1">34 ARP（Address Resolution Protocol） <a class="header-anchor" href="#_34-arp（address-resolution-protocol）" aria-hidden="true">#</a></h2><ol><li>ARP协议完成IP地址与物理地址的映射，每一个主机都设有一个ARP高速缓存，里面有所在的局域网上的各主机和路由器的IP地址到硬件地址的映射表。</li><li>当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有就向所在的局域网发起一个ARP请求的广播包（在发送自己的ARP请求时，同时会带上自己的IP地址到硬件地址的映射）。</li><li>收到请求的主机检查自己的IP地址和目的主机的IP地是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。</li><li>源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送，如果源主机一直没有收到响应，表示ARP查询失败。</li><li>如果所要找的主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。</li></ol><h2 id="_35-nat（network-address-translation，网络地址转换）" tabindex="-1">35 NAT（Network Address Translation，网络地址转换） <a class="header-anchor" href="#_35-nat（network-address-translation，网络地址转换）" aria-hidden="true">#</a></h2><p>用于解决内网中的主机要和因特网上的主机通信，由NAT路由将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到全球IP地址固定不变）和动态NAT转换。</p><h2 id="_36-jvm-调优的工具" tabindex="-1">36 JVM 调优的工具 <a class="header-anchor" href="#_36-jvm-调优的工具" aria-hidden="true">#</a></h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下， 其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li><p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</p></li><li><p>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p></li></ul><h2 id="_37-jvm-调优" tabindex="-1">37 jvm 调优 <a class="header-anchor" href="#_37-jvm-调优" aria-hidden="true">#</a></h2><ol><li>调优时机：</li></ol><ul><li>heap 内存（老年代）持续上涨达到设置的最大内存值：</li><li>full gc 次数频繁</li><li>gc 停顿时间过长（超过 1 秒）</li><li>应用中有使用本地缓存且占用大量内存空间</li><li>系统吞吐量与响应性能不高或下降</li></ul><ol start="2"><li>调优原则</li></ol><ul><li>多数的 java 应用不需要在服务器上进行 jvm 优化</li><li>多数导致 gc 问题的 java 应用，都不是因为我们参数设置错误，而是代码问题</li><li>在应用上线之前，先考虑将机器的 jvm 参数设置到最优（最适合）</li><li>减少创建对象的数量</li><li>减少使用全局变量和大对象</li><li>jvm 优化是到最后不得已才采用的手段</li><li>在实际使用中，分析 gc 情况优化代码比优化 jvm 参数更好。</li></ul><ol start="3"><li>调优目标</li></ol><ul><li>GC 低停顿</li><li>GC 低频率</li><li>低内存占用</li><li>高吞吐量</li></ul><ol start="4"><li>调优步骤</li></ol><ul><li>分析 GC 日志及 dump 文件，判断是否需要优化，确定瓶颈问题点。</li><li>确定 jvm 调优量化目标</li><li>确定 jvm 调优参数（根据历史 jvm 参数来调整）</li><li>调优一台服务器，对比观察调优前后的差异</li><li>不断的分析和调整，直到找到合适的 jvm 参数配置</li><li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续。</li></ul></div></div></main><footer class="VPDocFooter" data-v-3886f8ec data-v-4fc1a8f4><div class="edit-info" data-v-4fc1a8f4><div class="edit-link" data-v-4fc1a8f4><a class="VPLink link edit-link-button" href="https://github.com/space2030?tab=repositories" target="_blank" rel="noopener noreferrer" data-v-4fc1a8f4 data-v-8dd034e6><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-4fc1a8f4><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 github 上编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-4fc1a8f4><p class="VPLastUpdated" data-v-4fc1a8f4 data-v-537b088a>最后更新: <time datatime="2023-10-17T06:16:19.000Z" data-v-537b088a></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter" data-v-581d5782 data-v-3d0cd5b8><div class="container" data-v-3d0cd5b8><p class="message" data-v-3d0cd5b8>Released under the MIT License.</p><p class="copyright" data-v-3d0cd5b8>Copyright © 2023-present Evan You</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f37252e3\",\"src_case_example_aqs抽象队列同步器.md\":\"24756237\",\"src_case_example_arraylist扩容机制解析.md\":\"a4b8bed3\",\"src_case_example_arrays类sort()方法使用的排序算法.md\":\"ccfbb6ab\",\"src_case_example_concurrenthashmap为什么放弃了分段锁.md\":\"0a4ffee0\",\"src_case_example_es与mysql数据不一致.md\":\"d871661c\",\"src_case_example_redis与mysql数据不一致.md\":\"26418c82\",\"src_case_example_tomcat性能优化.md\":\"dfbb266f\",\"src_case_example_中间件设计.md\":\"468e8da7\",\"src_case_example_代码片段.md\":\"925caa6b\",\"src_case_example_分布式事务解决方案.md\":\"2f070cfb\",\"src_case_example_分布式唯一id.md\":\"23eadd1f\",\"src_case_example_分布式锁-基于数据库的实现.md\":\"4d8b29d2\",\"src_case_example_分库分表.md\":\"c52281c2\",\"src_case_example_如何处理千万级别mysql数据库锁表问题.md\":\"b4c0af50\",\"src_case_example_如何快速从千万级大表删除数据.md\":\"91fe5800\",\"src_case_example_批量处理数据.md\":\"78b0d9bb\",\"src_case_example_接口性能优化.md\":\"9d1792f7\",\"src_case_example_架构设计.md\":\"d307ccb7\",\"src_case_example_百万级别数据导入导出如何优化.md\":\"98a549ab\",\"src_case_example_百万级数据深度分页如何优化.md\":\"32c9674d\",\"src_case_example_秒杀.md\":\"fcad5d18\",\"src_case_example_系统设计规范.md\":\"15c311eb\",\"src_case_example_线上环境踩坑之并行流丢失数据.md\":\"1c3be8f9\",\"src_case_example_线程池.md\":\"e4225766\",\"src_case_example_综合面.md\":\"f493e2fa\",\"src_case_example_网络.md\":\"2753f5be\",\"src_case_example_设计接口.md\":\"38f526c0\",\"src_case_example_设计模式.md\":\"47a4706e\",\"src_case_example_重构.md\":\"f8b1bb82\",\"src_case_index.md\":\"e7293aa9\",\"src_case_norm_javascript规范.md\":\"9fb24129\",\"src_case_norm_java规范.md\":\"538dd69a\",\"src_case_norm_markdown规范.md\":\"2b32c5f2\",\"src_case_norm_vue规范.md\":\"898eb012\",\"src_case_norm_前后端规约.md\":\"e89a40a3\",\"src_case_norm_接口对接规范.md\":\"6d91f32f\",\"src_case_norm_日志规范.md\":\"f59ee845\",\"src_case_redis操作.md\":\"2f51e4c7\",\"src_deploy_index.md\":\"6cb4a725\",\"src_deploy_mongodb部署.md\":\"8a227b4a\",\"src_deploy_mysql部署.md\":\"11af5f81\",\"src_deploy_node部署.md\":\"fdf9e10a\",\"src_deploy_oracle部署.md\":\"f730433a\",\"src_deploy_redis部署.md\":\"ad57b569\",\"src_git_index.md\":\"1f809b9a\",\"src_index_index.md\":\"33da6e30\",\"src_kit_blog.md\":\"1c11ac7e\",\"src_kit_index.md\":\"04dd6794\",\"src_kit_nginx.md\":\"5c165844\",\"src_kit_tool.md\":\"d4ebdde9\",\"src_view_index.md\":\"dc64bfa6\",\"src_view_java_java-01-se.md\":\"d50e6d5e\",\"src_view_java_java-02-ee.md\":\"06cece6f\",\"src_view_java_java-03-tomcat.md\":\"4e071e95\",\"src_view_java_java-04-spring.md\":\"294e3736\",\"src_view_java_java-05-mybatis.md\":\"f08a45bf\",\"src_view_java_java-06-spring-boot.md\":\"0aff5c53\",\"src_view_java_java-07-maven.md\":\"cd8805f9\",\"src_view_java_java-08-spring-cloud.md\":\"9b8482f6\",\"src_view_java_java-09-mysql.md\":\"00f74996\",\"src_view_java_java-10-redis.md\":\"07f078ba\",\"src_view_java_java-11-oracle.md\":\"333de976\",\"src_view_java_java-12-gateway.md\":\"d8b6a793\",\"src_view_java_java-13-elasticsearch.md\":\"b01a920e\",\"src_view_java_java-14-mongodb.md\":\"a29b919f\",\"src_view_java_java-15-rocketmq.md\":\"2983da5e\",\"src_view_java_java-16-activemq.md\":\"d2aa5ffd\",\"src_view_java_java-17-rabbitmq.md\":\"ed854218\",\"src_view_java_java-18-zookeeper.md\":\"2bb8ca84\",\"src_view_java_java-19-kafka.md\":\"ef7bf4c5\",\"src_view_web_web-01-html.md\":\"f76a68db\",\"src_view_web_web-02-javascript.md\":\"560f2ce1\",\"src_view_web_web-03-vue.md\":\"e6cb6cc4\",\"src_web_index.md\":\"4759f761\",\"src_web_vitepress_vitepress快速开始.md\":\"86859a47\",\"src_web_vitepress_vitepress语法规则.md\":\"e4ba6974\",\"src_web_vitepress_vitepress项目发布.md\":\"246085db\"}")</script>
    <script type="module" async src="/vitepress-deploy/assets/app.2a154df8.js"></script>
    
  </body>
</html>